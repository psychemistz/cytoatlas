"""SQLite-backed repository for single-cell validation data (all cells).

Reads from singlecell_scatter.db generated by scripts/18_preprocess_singlecell_validation.py.
Contains per-target exact stats computed from ALL cells, density bins, and 50K sampled points.

DB schema:
    sc_targets  — per-target metadata (atlas, sigtype, stats from all cells)
    sc_density  — zlib-compressed 100x100 density bins
    sc_points   — zlib-compressed 50K sampled points
"""

from __future__ import annotations

import asyncio
import json
import logging
import sqlite3
import zlib
from functools import partial
from pathlib import Path
from typing import Any

from app.config import get_settings

logger = logging.getLogger(__name__)


class SQLiteSingleCellRepository:
    """Read-only repository over the singlecell_scatter.db SQLite file."""

    def __init__(self, db_path: Path | None = None):
        settings = get_settings()
        self._db_path = db_path or settings.sqlite_singlecell_db_path
        self._conn: sqlite3.Connection | None = None
        self._available: bool | None = None

    @property
    def available(self) -> bool:
        if self._available is None:
            self._available = Path(self._db_path).exists()
            if self._available:
                try:
                    self._get_conn()
                except Exception:
                    logger.warning(
                        "SC SQLite DB exists but failed to open: %s", self._db_path
                    )
                    self._available = False
        return self._available

    def _get_conn(self) -> sqlite3.Connection:
        if self._conn is None:
            self._conn = sqlite3.connect(str(self._db_path), check_same_thread=False)
            self._conn.row_factory = sqlite3.Row
            self._conn.execute("PRAGMA journal_mode=WAL")
            self._conn.execute("PRAGMA mmap_size=268435456")  # 256 MB
            self._conn.execute("PRAGMA cache_size=-65536")  # 64 MB
            self._conn.execute("PRAGMA query_only=ON")
        return self._conn

    def _run(self, fn, *args):
        loop = asyncio.get_running_loop()
        return loop.run_in_executor(None, partial(fn, *args))

    # ------------------------------------------------------------------ #
    #  Metadata queries                                                    #
    # ------------------------------------------------------------------ #

    def _list_atlases_sync(self) -> list[str]:
        conn = self._get_conn()
        rows = conn.execute(
            "SELECT DISTINCT atlas FROM sc_targets ORDER BY atlas"
        ).fetchall()
        return [r["atlas"] for r in rows]

    async def list_atlases(self) -> list[str]:
        return await self._run(self._list_atlases_sync)

    def _list_sigtypes_sync(self, atlas: str) -> list[str]:
        conn = self._get_conn()
        rows = conn.execute(
            "SELECT DISTINCT sigtype FROM sc_targets WHERE atlas=? ORDER BY sigtype",
            (atlas,),
        ).fetchall()
        return [r["sigtype"] for r in rows]

    async def list_sigtypes(self, atlas: str) -> list[str]:
        return await self._run(self._list_sigtypes_sync, atlas)

    # ------------------------------------------------------------------ #
    #  Target listing (metadata + stats, no points or density)             #
    # ------------------------------------------------------------------ #

    def _get_targets_sync(self, atlas: str, sigtype: str) -> list[dict]:
        conn = self._get_conn()
        rows = conn.execute(
            "SELECT target, gene, n_total, n_expressing, expressing_fraction, "
            "       rho, pval, fold_change, mann_whitney_p, "
            "       mean_act_expressing, mean_act_non_expressing "
            "FROM sc_targets "
            "WHERE atlas=? AND sigtype=?",
            (atlas, sigtype),
        ).fetchall()
        result = []
        for r in rows:
            entry: dict[str, Any] = {
                "target": r["target"],
                "gene": r["gene"],
                "n_total": r["n_total"],
                "n_expressing": r["n_expressing"],
                "expressing_fraction": r["expressing_fraction"],
                "rho": r["rho"],
                "pval": r["pval"],
                "fold_change": r["fold_change"],
                "mann_whitney_p": r["mann_whitney_p"],
                "mean_act_expressing": r["mean_act_expressing"],
                "mean_act_non_expressing": r["mean_act_non_expressing"],
                "significant": (r["pval"] or 1.0) < 0.05,
            }
            result.append(entry)
        return result

    async def get_targets(self, atlas: str, sigtype: str) -> list[dict]:
        return await self._run(self._get_targets_sync, atlas, sigtype)

    # ------------------------------------------------------------------ #
    #  Full scatter data (stats + density + sampled points)                #
    # ------------------------------------------------------------------ #

    def _get_scatter_sync(
        self, atlas: str, sigtype: str, target: str
    ) -> dict | None:
        conn = self._get_conn()
        row = conn.execute(
            "SELECT t.id, t.target, t.gene, t.n_total, t.n_expressing, "
            "       t.expressing_fraction, t.rho, t.pval, "
            "       t.fold_change, t.mann_whitney_p, "
            "       t.mean_act_expressing, t.mean_act_non_expressing, "
            "       t.celltype_stats_json, "
            "       d.bins_blob, p.points_blob "
            "FROM sc_targets t "
            "LEFT JOIN sc_density d ON d.target_id = t.id "
            "LEFT JOIN sc_points p ON p.target_id = t.id "
            "WHERE t.atlas=? AND t.sigtype=? AND t.target=?",
            (atlas, sigtype, target),
        ).fetchone()

        if row is None:
            return None

        entry: dict[str, Any] = {
            "target": row["target"],
            "gene": row["gene"],
            "n_total": row["n_total"],
            "n_expressing": row["n_expressing"],
            "expressing_fraction": row["expressing_fraction"],
            "rho": row["rho"],
            "pval": row["pval"],
            "fold_change": row["fold_change"],
            "mann_whitney_p": row["mann_whitney_p"],
            "mean_act_expressing": row["mean_act_expressing"],
            "mean_act_non_expressing": row["mean_act_non_expressing"],
        }

        # Celltype stats
        if row["celltype_stats_json"]:
            entry["celltype_stats"] = json.loads(row["celltype_stats_json"])

        # Density bins
        if row["bins_blob"]:
            entry["density"] = json.loads(zlib.decompress(row["bins_blob"]))

        # Sampled points
        if row["points_blob"]:
            entry["sampled"] = json.loads(zlib.decompress(row["points_blob"]))

        return entry

    async def get_scatter(
        self, atlas: str, sigtype: str, target: str
    ) -> dict | None:
        return await self._run(self._get_scatter_sync, atlas, sigtype, target)

    # ------------------------------------------------------------------ #
    #  Per-celltype stats only                                             #
    # ------------------------------------------------------------------ #

    def _get_celltype_stats_sync(
        self, atlas: str, sigtype: str, target: str
    ) -> list[dict]:
        conn = self._get_conn()
        row = conn.execute(
            "SELECT celltype_stats_json FROM sc_targets "
            "WHERE atlas=? AND sigtype=? AND target=?",
            (atlas, sigtype, target),
        ).fetchone()
        if row is None or not row["celltype_stats_json"]:
            return []
        return json.loads(row["celltype_stats_json"])

    async def get_celltype_stats(
        self, atlas: str, sigtype: str, target: str
    ) -> list[dict]:
        return await self._run(
            self._get_celltype_stats_sync, atlas, sigtype, target
        )

    def close(self):
        if self._conn is not None:
            self._conn.close()
            self._conn = None
