<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pan-Disease Cytokine Activity Atlas</title>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@400;600;700&family=Source+Sans+Pro:wght@400;600&family=Source+Code+Pro&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #1a5f7a;
            --secondary-color: #57a0d3;
            --accent-color: #ff6b6b;
            --bg-color: #fafafa;
            --text-color: #333;
            --muted-color: #666;
            --border-color: #e0e0e0;
            --card-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Source Sans Pro', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.7;
            color: var(--text-color);
            background: var(--bg-color);
            margin: 0;
            padding: 0;
        }

        /* Typography - Distill.pub inspired */
        h1, h2, h3, h4 {
            font-family: 'Source Serif Pro', Georgia, serif;
            font-weight: 600;
            line-height: 1.3;
        }

        h1 { font-size: 2.5rem; margin-bottom: 0.5rem; }
        h2 { font-size: 1.8rem; margin-top: 3rem; margin-bottom: 1rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; }
        h3 { font-size: 1.3rem; margin-top: 2rem; color: var(--primary-color); }

        p { margin: 1rem 0; }

        a { color: var(--primary-color); text-decoration: none; }
        a:hover { text-decoration: underline; }

        code {
            font-family: 'Source Code Pro', monospace;
            background: #f0f0f0;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 0.9em;
        }

        /* Layout */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .narrow {
            max-width: 800px;
        }

        /* Navigation */
        nav {
            position: sticky;
            top: 0;
            background: white;
            border-bottom: 1px solid var(--border-color);
            z-index: 1000;
            padding: 0.8rem 0;
            box-shadow: var(--card-shadow);
        }

        nav .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        nav .logo {
            font-family: 'Source Serif Pro', serif;
            font-weight: 700;
            font-size: 1.2rem;
            color: var(--primary-color);
        }

        nav ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            gap: 1.5rem;
        }

        nav a {
            color: var(--muted-color);
            font-size: 0.95rem;
            padding: 0.3rem 0;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        nav a:hover, nav a.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            text-decoration: none;
        }

        /* Hero */
        .hero {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 4rem 0;
            text-align: center;
        }

        .hero h1 {
            font-size: 2.8rem;
            margin-bottom: 1rem;
        }

        .hero p {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 700px;
            margin: 0 auto;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin: 2rem 0;
        }

        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary-color);
            line-height: 1;
        }

        .stat-label {
            color: var(--muted-color);
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        /* Sections */
        section {
            padding: 3rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        section:last-child {
            border-bottom: none;
        }

        /* Cards */
        .card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            margin: 1rem 0;
        }

        .card-title {
            font-family: 'Source Serif Pro', serif;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1rem 0;
            padding: 1rem;
            background: #f5f5f5;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .control-group label {
            font-size: 0.85rem;
            color: var(--muted-color);
            font-weight: 600;
        }

        select, input[type="range"] {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.95rem;
            min-width: 150px;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Visualization containers - Viewport-relative sizing */
        .viz-container {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: var(--card-shadow);
            margin: 1rem 0;
            min-height: min(450px, 70vh);
            max-height: 80vh;
            overflow: auto;
        }

        /* Larger panels (heatmaps, networks, forest plots) */
        .viz-container.large {
            min-height: min(600px, 75vh);
        }

        /* Compact panels (summary stats, small charts) */
        .viz-container.compact {
            min-height: min(300px, 50vh);
        }

        /* Full-height panels (organ maps, sankey diagrams) */
        .viz-container.full-height {
            min-height: min(700px, 85vh);
        }

        .viz-title {
            font-family: 'Source Serif Pro', serif;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-color);
        }

        .viz-subtitle {
            font-size: 0.85rem;
            color: var(--muted-color);
            margin-bottom: 1rem;
        }

        /* Two column layout */
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 900px) {
            .two-col {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .tabs {
                gap: 2px;
            }
            .tabs .tab {
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
            }
            .viz-container {
                min-height: min(350px, 60vh);
            }
            .viz-container.large {
                min-height: min(450px, 65vh);
            }
            h2 {
                font-size: 1.4rem;
            }
            .hero h1 {
                font-size: 1.8rem;
            }
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .controls {
                flex-direction: column;
            }
            .control-group {
                width: 100%;
            }
            select {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .tabs .tab {
                font-size: 0.75rem;
                padding: 0.3rem 0.5rem;
            }
            .container {
                padding: 0 1rem;
            }
            nav ul {
                gap: 0.5rem;
            }
            nav a {
                font-size: 0.85rem;
            }
        }

        /* Body map */
        .body-map-container {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
        }

        .body-map {
            flex: 0 0 300px;
        }

        .body-map svg {
            width: 100%;
            height: auto;
        }

        .organ-details {
            flex: 1;
        }

        .organ-path {
            fill: #e0e0e0;
            stroke: #999;
            stroke-width: 0.5;
            cursor: pointer;
            transition: fill 0.2s;
        }

        .organ-path:hover {
            fill: var(--secondary-color);
        }

        .organ-path.selected {
            fill: var(--primary-color);
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.8rem;
            font-size: 0.9rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            pointer-events: none;
            z-index: 1001;
            max-width: 300px;
        }

        .tooltip-title {
            font-weight: 600;
            margin-bottom: 0.3rem;
        }

        .tooltip-value {
            color: var(--primary-color);
            font-weight: 600;
        }

        /* Signature list */
        .signature-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .signature-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .signature-item:last-child {
            border-bottom: none;
        }

        .signature-name {
            font-weight: 600;
        }

        .signature-value {
            font-size: 0.9rem;
            color: var(--muted-color);
        }

        .signature-bar {
            height: 4px;
            background: var(--secondary-color);
            border-radius: 2px;
            margin-top: 0.3rem;
        }

        /* Loading */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 300px;
            color: var(--muted-color);
        }

        .loading::after {
            content: '';
            width: 30px;
            height: 30px;
            border: 3px solid var(--border-color);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 1rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .data-table th, .data-table td {
            padding: 0.6rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table th {
            background: #f5f5f5;
            font-weight: 600;
            color: var(--muted-color);
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        .data-table tr:hover {
            background: #fafafa;
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .badge-positive { background: #d4edda; color: #155724; }
        .badge-negative { background: #f8d7da; color: #721c24; }
        .badge-neutral { background: #e2e3e5; color: #383d41; }

        /* Footer */
        footer {
            background: #333;
            color: white;
            padding: 2rem 0;
            text-align: center;
            margin-top: 3rem;
        }

        footer a {
            color: var(--secondary-color);
        }

        /* Tabs */
        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1rem;
        }

        .tab {
            padding: 0.8rem 1.5rem;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 0.95rem;
            color: var(--muted-color);
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--primary-color);
        }

        .tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Search */
        .search-box {
            position: relative;
            margin-bottom: 1rem;
        }

        .search-box input {
            width: 100%;
            padding: 0.8rem 1rem;
            padding-left: 2.5rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
        }

        .search-box::before {
            content: "üîç";
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1rem;
        }

        /* Plotly modebar styling - small and bottom right */
        .modebar {
            top: auto !important;
            bottom: 10px !important;
            right: 10px !important;
            left: auto !important;
        }

        .modebar-btn {
            font-size: 12px !important;
        }

        .modebar-group {
            padding: 2px !important;
        }

        .modebar svg {
            width: 16px !important;
            height: 16px !important;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav>
        <div class="container">
            <span class="logo">Cytokine Activity Atlas</span>
            <ul>
                <li><a href="#overview" class="active">Overview</a></li>
                <li><a href="#cima">CIMA</a></li>
                <li><a href="#inflammation">Inflammation</a></li>
                <li><a href="#scatlas">scAtlas</a></li>
                <li><a href="#cross-atlas">Cross-Atlas</a></li>
                <li><a href="#methods">Methods</a></li>
            </ul>
        </div>
    </nav>

    <!-- Hero -->
    <div class="hero">
        <div class="container">
            <h1>Pan-Disease Cytokine Activity Atlas</h1>
            <p>Interactive exploration of cytokine signaling activities across healthy tissues, cell types, and disease states using single-cell RNA sequencing data.</p>
        </div>
    </div>

    <!-- Overview Section -->
    <section id="overview">
        <div class="container">
            <h2>Atlas Overview</h2>
            <p class="narrow">This atlas provides a comprehensive view of cytokine signaling activities computed from single-cell transcriptomic data using CytoSig and SecAct methods.</p>

            <div class="tabs">
                <button class="tab active" data-tab="overview-cima">CIMA</button>
                <button class="tab" data-tab="overview-inflammation">Inflammation Atlas</button>
                <button class="tab" data-tab="overview-scatlas">scAtlas</button>
            </div>

            <!-- CIMA Overview Tab -->
            <div class="tab-content active" id="tab-overview-cima">
                <div class="stats-grid" id="stats-grid-cima">
                    <div class="stat-card">
                        <div class="stat-number" id="stat-cima-samples">-</div>
                        <div class="stat-label">Healthy Donors</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-cima-cells">6.5M</div>
                        <div class="stat-label">Total Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-cima-celltypes">27</div>
                        <div class="stat-label">Cell Types</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-cima-metabolites">500</div>
                        <div class="stat-label">Metabolites Profiled</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-cima-biomarkers">19</div>
                        <div class="stat-label">Blood Biomarkers</div>
                    </div>
                </div>
                <p style="color: #666; margin-top: 1rem; font-size: 0.9rem;">
                    CIMA: Chinese Immune Multi-omics Atlas - Comprehensive immune monitoring atlas of healthy donors with matched blood biochemistry and plasma metabolomics data.
                </p>
                <p class="citation" style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                    <strong>Citation:</strong> Yin et al. (2026) <em>Science</em>.
                    <a href="https://www.science.org/doi/10.1126/science.adt3130" target="_blank" rel="noopener">DOI: 10.1126/science.adt3130</a>
                </p>
                <div class="card" style="margin-top: 1rem;">
                    <div class="card-title">CIMA Analysis Data Sources</div>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Analysis</th>
                                <th>Description</th>
                                <th>Records</th>
                            </tr>
                        </thead>
                        <tbody id="data-sources-cima">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Inflammation Atlas Overview Tab -->
            <div class="tab-content" id="tab-overview-inflammation">
                <div class="stats-grid" id="stats-grid-inflammation">
                    <div class="stat-card">
                        <div class="stat-number" id="stat-inflam-samples">-</div>
                        <div class="stat-label">Patient Samples</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-inflam-cells">-</div>
                        <div class="stat-label">Total Cells</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-inflam-celltypes">-</div>
                        <div class="stat-label">Cell Types</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-inflam-diseases">20</div>
                        <div class="stat-label">Diseases Studied</div>
                    </div>
                </div>
                <p style="color: #666; margin-top: 1rem; font-size: 0.9rem;">
                    Inflammation Atlas: Multi-disease cohort (4.9M cells, 817 samples) spanning RA, IBD (CD/UC), MS, SLE, COVID, sepsis, and other inflammatory conditions with treatment response prediction.
                </p>
                <p class="citation" style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                    <strong>Citation:</strong> Jim√©nez-Gracia et al. (2026) <em>Nature Medicine</em>.
                </p>
                <div class="card" style="margin-top: 1rem;">
                    <div class="card-title">Inflammation Atlas Analysis Data Sources</div>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Analysis</th>
                                <th>Description</th>
                                <th>Records</th>
                            </tr>
                        </thead>
                        <tbody id="data-sources-inflammation">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- scAtlas Overview Tab -->
            <div class="tab-content" id="tab-overview-scatlas">
                <div class="stats-grid" id="stats-grid-scatlas">
                    <div class="stat-card">
                        <div class="stat-number" id="stat-scatlas-donors">-</div>
                        <div class="stat-label">Donors (Normal / Cancer)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-scatlas-cells">-</div>
                        <div class="stat-label">Total Cells (Normal / Cancer)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-scatlas-organs">-</div>
                        <div class="stat-label">Organs Profiled</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-scatlas-celltypes">-</div>
                        <div class="stat-label">Cell Types (Normal / Cancer)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="stat-scatlas-cohorts">-</div>
                        <div class="stat-label">Cohorts (Normal / Cancer)</div>
                    </div>
                </div>
                <p style="color: #666; margin-top: 1rem; font-size: 0.9rem;">
                    scAtlas: Human Cell Atlas data spanning normal organs and pan-cancer datasets with detailed cell type annotations.
                </p>
                <p class="citation" style="font-size: 0.85rem; color: #666; margin-top: 0.5rem;">
                    <strong>Citation:</strong> Shi et al. (2025) <em>Nature</em>. Cross-tissue multicellular coordination and its rewiring in cancer.
                </p>
                <div class="card" style="margin-top: 1rem;">
                    <div class="card-title">scAtlas Analysis Data Sources</div>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Analysis</th>
                                <th>Description</th>
                                <th>Records</th>
                            </tr>
                        </thead>
                        <tbody id="data-sources-scatlas">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </section>

    <!-- CIMA Section -->
    <section id="cima">
        <div class="container">
            <h2>CIMA: Clinical Correlations</h2>
            <p class="narrow">Explore correlations between cytokine activities and clinical parameters in 421 healthy donors from the CIMA cohort.</p>

            <div class="tabs">
                <button class="tab active" data-tab="cima-celltypes">Cell Types</button>
                <button class="tab" data-tab="age-bmi">Age & BMI</button>
                <button class="tab" data-tab="age-bmi-boxplots">Age/BMI Stratified</button>
                <button class="tab" data-tab="biochemistry">Biochemistry</button>
                <button class="tab" data-tab="biochem-scatter">Biochem Scatter</button>
                <button class="tab" data-tab="metabolites">Metabolites</button>
                <button class="tab" data-tab="differential">Differential</button>
                <button class="tab" data-tab="cima-multiomics">Multi-omics</button>
                <button class="tab" data-tab="cima-population">Population</button>
                <button class="tab" data-tab="cima-eqtl">eQTL Browser</button>
            </div>

            <!-- Age/BMI Tab -->
            <div class="tab-content" id="tab-age-bmi">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="corr-signature-type">
                            <option value="CytoSig" selected>CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                </div>
                <p style="color: #666; margin-bottom: 1rem;">Showing top correlations sorted from high to low.</p>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 550px;">
                        <div class="viz-title">Age Correlations</div>
                        <div class="viz-subtitle">Spearman correlation with donor age (sorted high to low)</div>
                        <div id="age-lollipop" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 550px;">
                        <div class="viz-title">BMI Correlations</div>
                        <div class="viz-subtitle">Spearman correlation with body mass index (sorted high to low)</div>
                        <div id="bmi-lollipop" class="loading">Loading...</div>
                    </div>
                </div>

                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-title">Cell Type-Specific Correlations</div>
                    <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                        Heatmap showing how cytokine activities correlate with Age/BMI <strong>within each cell type</strong>.
                        Identifies which cell populations drive age- or BMI-related changes.
                        Red = positive correlation, Blue = negative correlation.
                    </p>
                    <div class="controls" style="margin-bottom: 1rem;">
                        <div class="control-group">
                            <label>Signature Type</label>
                            <select id="cima-ct-corr-sigtype">
                                <option value="CytoSig">CytoSig (43 cytokines)</option>
                                <option value="SecAct">SecAct (1,170 proteins)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Correlation With</label>
                            <select id="cima-ct-corr-feature">
                                <option value="age">Age</option>
                                <option value="bmi">BMI</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Show</label>
                            <select id="cima-ct-corr-metric">
                                <option value="rho">All correlations (œÅ)</option>
                                <option value="sig">Significant only (q&lt;0.05)</option>
                            </select>
                        </div>
                    </div>
                    <div class="viz-container" style="min-height: 550px;">
                        <div class="viz-title" id="cima-ct-corr-title">Age Correlation by Cell Type</div>
                        <div class="viz-subtitle">Spearman œÅ for each cytokine √ó cell type (27 cell types √ó 43 cytokines)</div>
                        <div id="cima-celltype-corr-heatmap" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Age/BMI Stratified Boxplots Tab -->
            <div class="tab-content" id="tab-age-bmi-boxplots">
                <div class="controls">
                    <div class="control-group">
                        <label>Stratify By</label>
                        <select id="stratify-by">
                            <option value="age">Age (decades)</option>
                            <option value="bmi">BMI (WHO categories)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cell Type</label>
                        <select id="boxplot-celltype">
                            <option value="All">All (sample-level)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="boxplot-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                            <option value="both">Both (22 shared)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Protein</label>
                        <select id="boxplot-signature-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="boxplot-signature-search" placeholder="Type to search..."
                               style="width: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off">
                        <div id="boxplot-signature-suggestions" style="position: absolute; top: 100%; left: 0; width: 150px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Age Bins:</strong> &lt;30, 30-39, 40-49, 50-59, 60-69, 70+ years<br>
                    <strong>BMI Categories:</strong> Underweight (&lt;18.5), Normal (18.5-25), Overweight (25-30), Obese I (30-35), Obese II+ (&gt;35)
                </div>

                <div class="viz-container" style="min-height: 500px;">
                    <div class="viz-title" id="boxplot-title">Age-Stratified Cytokine Activity</div>
                    <div class="viz-subtitle" id="boxplot-subtitle">Distribution of activity scores across age bins</div>
                    <div id="stratified-boxplot" class="loading">Loading...</div>
                </div>

                <!-- Cell Type Heatmap -->
                <div class="viz-container" style="min-height: 400px; margin-top: 2rem;">
                    <div class="viz-title" id="celltype-stratified-title">Cell Type-Specific Activity Heatmap</div>
                    <div class="viz-subtitle" id="celltype-stratified-subtitle">Median activity across cell types and age/BMI bins</div>
                    <div id="celltype-stratified-heatmap" class="loading">Loading...</div>
                </div>
            </div>

            <!-- Biochemistry Tab -->
            <div class="tab-content" id="tab-biochemistry">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="biochem-signature-type">
                            <option value="CytoSig">CytoSig (44 cytokines)</option>
                            <option value="SecAct">SecAct (1,249 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Protein</label>
                        <select id="biochem-protein-dropdown" style="width: 150px;">
                            <option value="">-- All --</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="biochem-protein-search" placeholder="Type to filter..."
                               style="width: 150px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off">
                        <div id="biochem-protein-suggestions" style="position: absolute; top: 100%; left: 0; width: 150px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                    <div class="control-group">
                        <label>Top N Proteins</label>
                        <select id="biochem-top-n">
                            <option value="20">Top 20</option>
                            <option value="50" selected>Top 50</option>
                            <option value="100">Top 100</option>
                            <option value="all">All</option>
                        </select>
                    </div>
                </div>

                <details class="card" style="margin-bottom: 1rem;">
                    <summary style="cursor: pointer; font-weight: 600; color: var(--primary-color);">Blood Marker Abbreviations (click to expand)</summary>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 0.5rem; margin-top: 1rem; font-size: 0.9rem;">
                        <div><strong>ALB</strong> - Albumin (liver function, nutrition)</div>
                        <div><strong>GLOB</strong> - Globulin (immune proteins)</div>
                        <div><strong>A/G</strong> - Albumin/Globulin ratio</div>
                        <div><strong>TP</strong> - Total Protein</div>
                        <div><strong>ALT</strong> - Alanine Aminotransferase (liver enzyme)</div>
                        <div><strong>AST</strong> - Aspartate Aminotransferase (liver/heart enzyme)</div>
                        <div><strong>AST/ALT</strong> - AST to ALT ratio (liver damage pattern)</div>
                        <div><strong>GGT</strong> - Gamma-Glutamyl Transferase (liver/bile duct)</div>
                        <div><strong>Tbil</strong> - Total Bilirubin (liver function)</div>
                        <div><strong>DBIL</strong> - Direct Bilirubin (conjugated)</div>
                        <div><strong>IBIL</strong> - Indirect Bilirubin (unconjugated)</div>
                        <div><strong>CHOL</strong> - Total Cholesterol</div>
                        <div><strong>HDL-C</strong> - HDL Cholesterol ("good" cholesterol)</div>
                        <div><strong>LDL-C</strong> - LDL Cholesterol ("bad" cholesterol)</div>
                        <div><strong>TG</strong> - Triglycerides (blood fat)</div>
                        <div><strong>GLU</strong> - Glucose (blood sugar)</div>
                        <div><strong>Cr</strong> - Creatinine (kidney function)</div>
                        <div><strong>UR</strong> - Urea/BUN (kidney function)</div>
                        <div><strong>UA</strong> - Uric Acid (gout, kidney)</div>
                    </div>
                </details>

                <div class="viz-container" style="min-height: 600px;">
                    <div class="viz-title">Biochemistry Correlation Heatmap</div>
                    <div class="viz-subtitle">Spearman correlations between cytokine activities and blood biochemistry parameters</div>
                    <div id="biochem-heatmap" class="loading">Loading...</div>
                </div>
            </div>

            <!-- Metabolites Tab -->
            <div class="tab-content" id="tab-metabolites">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="metab-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (top 100 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Metabolite Category</label>
                        <select id="metab-category">
                            <option value="all">All Categories</option>
                            <option value="lipid">Lipids</option>
                            <option value="amino_acid">Amino Acids</option>
                            <option value="carbohydrate">Carbohydrates</option>
                            <option value="nucleotide">Nucleotides</option>
                            <option value="cofactor">Cofactors & Vitamins</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Min |Correlation|</label>
                        <select id="metab-threshold">
                            <option value="0.2">0.2</option>
                            <option value="0.3" selected>0.3</option>
                            <option value="0.4">0.4</option>
                            <option value="0.5">0.5</option>
                        </select>
                    </div>
                </div>

                <p style="color: #666; margin-bottom: 1rem;">Showing top 500 cytokine-metabolite correlations from plasma metabolomics data.</p>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 600px;">
                        <div class="viz-title">Metabolite Correlation Network</div>
                        <div class="viz-subtitle">Force-directed graph of cytokine-metabolite associations</div>
                        <div id="metabolite-network" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 600px;">
                        <div class="viz-title">Top Metabolite Correlations</div>
                        <div class="viz-subtitle">Ranked by absolute correlation strength</div>
                        <div id="metabolite-lollipop" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Differential Tab -->
            <div class="tab-content" id="tab-differential">
                <div class="controls">
                    <div class="control-group">
                        <label>Comparison</label>
                        <select id="diff-comparison">
                            <option value="sex|Female|Male">Sex (Female vs Male)</option>
                            <optgroup label="Smoking Status">
                                <option value="smoking_status|current|never">Current vs Never</option>
                                <option value="smoking_status|current|past">Current vs Past</option>
                                <option value="smoking_status|never|past">Never vs Past</option>
                            </optgroup>
                            <optgroup label="Blood Type">
                                <option value="blood_type|O|A">O vs A</option>
                                <option value="blood_type|O|B">O vs B</option>
                                <option value="blood_type|O|AB">O vs AB</option>
                                <option value="blood_type|B|A">B vs A</option>
                                <option value="blood_type|B|AB">B vs AB</option>
                                <option value="blood_type|A|AB">A vs AB</option>
                            </optgroup>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="diff-signature-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Volcano Plot: Differential Activity</div>
                        <div class="viz-subtitle" id="volcano-subtitle">Effect size (Œî activity) vs significance (-log10 p-value)</div>
                        <div id="volcano-plot" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Top Differential Signatures</div>
                        <div class="viz-subtitle">Sorted by significance (|Œî activity| √ó -log10 p)</div>
                        <div id="cima-diff-bar" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- CIMA Cell Types Tab -->
            <div class="tab-content active" id="tab-cima-celltypes">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="cima-ct-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Protein</label>
                        <select id="cima-ct-protein-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="cima-ct-protein-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off" value="IFNG">
                        <div id="cima-ct-protein-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Cell Type Activity Profile</div>
                        <div class="viz-subtitle">Mean cytokine activity across 27 immune cell populations</div>
                        <div id="cima-celltype-bar" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Activity Heatmap</div>
                        <div class="viz-subtitle">Cell types x cytokine signatures</div>
                        <div id="cima-celltype-heatmap" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Biochemistry Scatter Tab -->
            <div class="tab-content" id="tab-biochem-scatter">
                <div class="controls">
                    <div class="control-group">
                        <label>X-Axis (Biochemistry)</label>
                        <select id="biochem-x-axis">
                            <option value="ALT">ALT (Liver enzyme)</option>
                            <option value="AST">AST (Liver enzyme)</option>
                            <option value="GGT">GGT (Liver/bile duct)</option>
                            <option value="CHOL">Total Cholesterol</option>
                            <option value="HDL-C">HDL Cholesterol</option>
                            <option value="LDL-C">LDL Cholesterol</option>
                            <option value="TG">Triglycerides</option>
                            <option value="GLU">Glucose</option>
                            <option value="Cr">Creatinine</option>
                            <option value="UA">Uric Acid</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="biochem-scatter-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Y-Axis (Protein)</label>
                        <select id="biochem-scatter-protein-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="biochem-scatter-protein-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off" value="IFNG">
                        <div id="biochem-scatter-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                    <div class="control-group">
                        <label>Color By</label>
                        <select id="biochem-color-by">
                            <option value="sex">Sex</option>
                            <option value="age_bin">Age Group</option>
                            <option value="bmi_bin">BMI Category</option>
                        </select>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container large">
                        <div class="viz-title">Biochemistry vs Cytokine Scatter</div>
                        <div class="viz-subtitle">Interactive exploration of clinical-cytokine relationships</div>
                        <div id="biochem-scatter-plot" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">Regression Statistics</div>
                        <div class="viz-subtitle">Linear and robust regression results</div>
                        <div id="biochem-regression-stats" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Multi-omics Integration Tab -->
            <div class="tab-content" id="tab-cima-multiomics">
                <div class="controls">
                    <div class="control-group">
                        <label>Analysis Type</label>
                        <select id="multiomics-analysis">
                            <option value="correlation">Correlation Network</option>
                            <option value="heatmap">Top Correlations Bar</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cytokine Subset</label>
                        <select id="multiomics-cytokines">
                            <option value="all">All CytoSig (43)</option>
                            <option value="inflammatory">Inflammatory (IL-1B, IL-6, TNF)</option>
                            <option value="regulatory">Regulatory (IL-10, TGF-Œ≤, IL-4)</option>
                            <option value="th17">Th17 axis (IL-17A, IL-21, IL-22)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Min |Correlation|</label>
                        <select id="multiomics-threshold">
                            <option value="0.2">0.2</option>
                            <option value="0.3" selected>0.3</option>
                            <option value="0.4">0.4</option>
                            <option value="0.5">0.5</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Multi-omics Integration:</strong> Integrates cytokine activity signatures with blood biochemistry (19 markers, 21,859 correlations) and plasma metabolomics (65 metabolites, 500 top correlations) from CIMA healthy donors.
                </div>

                <div class="two-col">
                    <div class="viz-container large">
                        <div class="viz-title">Multi-omics Network</div>
                        <div class="viz-subtitle">Real correlations between cytokines, biochemistry, and metabolites</div>
                        <div id="multiomics-network" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">Cross-omic Summary</div>
                        <div class="viz-subtitle">Top associations between data modalities</div>
                        <div id="multiomics-summary" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Population Stratification Tab -->
            <div class="tab-content" id="tab-cima-population">
                <div class="controls">
                    <div class="control-group">
                        <label>Stratification Variable</label>
                        <select id="pop-stratify">
                            <option value="sex">Sex (Male vs Female)</option>
                            <option value="age">Age Group (Older vs Young)</option>
                            <option value="bmi">BMI Category (Obese vs Normal)</option>
                            <option value="blood_type">Blood Type (O vs A)</option>
                            <option value="smoking">Smoking Status (Smoker vs Never)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="pop-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container">
                        <div class="viz-title">Population Distribution</div>
                        <div class="viz-subtitle">Sample distribution across stratification groups (N=421)</div>
                        <div id="pop-distribution" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">Top & Bottom Effect Sizes</div>
                        <div class="viz-subtitle">Top 10 + Bottom 10 + IFNG/TNF. Red = positive, Blue = negative.</div>
                        <div id="pop-effect-sizes" class="loading">Loading...</div>
                    </div>
                </div>

                <div class="viz-container large">
                    <div class="viz-title">Population-Stratified Heatmap</div>
                    <div class="viz-subtitle">Mean activity across demographic groups. Red = high, Blue = low.</div>
                    <div id="pop-heatmap" class="loading">Loading...</div>
                </div>
            </div>

            <!-- eQTL Browser Tab -->
            <div class="tab-content" id="tab-cima-eqtl">
                <div class="controls">
                    <div class="control-group">
                        <label>Search Gene/Variant</label>
                        <input type="text" id="eqtl-search" placeholder="e.g., IFNG, IL6, chr1_814733">
                    </div>
                    <div class="control-group">
                        <label>Cell Type</label>
                        <select id="eqtl-type">
                            <option value="all">All Cell Types (69)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Significance Threshold</label>
                        <select id="eqtl-threshold">
                            <option value="1e-3">p < 1e-3</option>
                            <option value="1e-5">p < 1e-5</option>
                            <option value="1e-8">p < 1e-8</option>
                            <option value="5e-8" selected>Genome-wide (5e-8)</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>cis-eQTL Browser:</strong> <span id="eqtl-count-display">71,530 cis-eQTLs</span> across 69 immune cell types.
                    Explore genetic variants (SNPs) associated with gene expression in immune cells.
                    <br><small style="color: #666;">Data: CIMA Lead cis-eQTL (study-wise FDR < 0.05). 9,600 genes with significant eQTLs.</small>
                </div>

                <div class="two-col">
                    <div class="viz-container large">
                        <div class="viz-title">cis-eQTL Manhattan Plot</div>
                        <div class="viz-subtitle">Genomic position vs -log10(p-value). Red line = genome-wide significance (5e-8)</div>
                        <div id="eqtl-manhattan" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">Top eQTL Results</div>
                        <div class="viz-subtitle">Most significant SNP-gene associations</div>
                        <div id="eqtl-table" class="loading">Loading...</div>
                    </div>
                </div>

                <div class="viz-container">
                    <div class="viz-title">eQTLs by Cell Type</div>
                    <div class="viz-subtitle">Distribution of significant eQTLs across immune cell populations</div>
                    <div id="eqtl-effect-plot" class="loading">Loading...</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Inflammation Atlas Section -->
    <section id="inflammation">
        <div class="container">
            <h2>Inflammation Atlas: Disease Signatures</h2>
            <p class="narrow">Explore cytokine activity signatures across 66 immune cell types from 817 patient samples (4.9M cells) spanning 20 inflammatory diseases including RA, IBD, MS, SLE, COVID, and sepsis.</p>

            <div class="tabs">
                <button class="tab active" data-tab="inflam-celltypes">Cell Types</button>
                <button class="tab" data-tab="inflam-age-bmi">Age & BMI</button>
                <button class="tab" data-tab="inflam-age-bmi-stratified">Age/BMI Stratified</button>
                <button class="tab" data-tab="disease-sankey">Disease Flow</button>
                <button class="tab" data-tab="inflam-disease">Disease</button>
                <button class="tab" data-tab="inflam-severity">Severity</button>
                <button class="tab" data-tab="inflam-differential">Differential</button>
                <button class="tab" data-tab="treatment-response">Treatment Response</button>
                <button class="tab" data-tab="cohort-validation">Validation</button>
                <button class="tab" data-tab="inflam-drivers">Cell Drivers</button>
            </div>

            <!-- Cell Types Tab -->
            <div class="tab-content active" id="tab-inflam-celltypes">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="inflam-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Signature</label>
                        <select id="inflam-signature-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="inflam-signature-search" placeholder="Search..." value="IFNG" style="width: 120px;">
                        <div id="inflam-signature-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Cell Type Activity Profile</div>
                        <div class="viz-subtitle">Mean cytokine activity across immune cell populations</div>
                        <div id="inflam-celltype-bar" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Activity Heatmap</div>
                        <div class="viz-subtitle">Top variable cell types x cytokines</div>
                        <div id="inflam-heatmap" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Age & BMI Tab -->
            <div class="tab-content" id="tab-inflam-age-bmi">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="inflam-corr-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                </div>
                <p style="color: #666; margin-bottom: 1rem;">Spearman correlations with patient age and BMI. Showing top correlations sorted from high to low.</p>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 550px;">
                        <div class="viz-title">Age Correlations</div>
                        <div class="viz-subtitle">Spearman correlation with patient age (sorted high to low)</div>
                        <div id="inflam-age-lollipop" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 550px;">
                        <div class="viz-title">BMI Correlations</div>
                        <div class="viz-subtitle">Spearman correlation with body mass index (sorted high to low)</div>
                        <div id="inflam-bmi-lollipop" class="loading">Loading...</div>
                    </div>
                </div>

                <!-- Cell Type-Specific Correlations -->
                <div class="card" style="margin-top: 2rem;">
                    <div class="controls">
                        <div class="control-group">
                            <label>Signature Type</label>
                            <select id="inflam-ct-corr-sigtype">
                                <option value="CytoSig">CytoSig (43 cytokines)</option>
                                <option value="SecAct">SecAct (1,170 proteins)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Feature</label>
                            <select id="inflam-ct-corr-feature">
                                <option value="age">Age</option>
                                <option value="bmi">BMI</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label>Display Mode</label>
                            <select id="inflam-ct-corr-metric">
                                <option value="rho">All correlations (œÅ)</option>
                                <option value="sig">Significant only (q&lt;0.05)</option>
                            </select>
                        </div>
                    </div>
                    <div class="viz-container" style="min-height: 550px;">
                        <div class="viz-title" id="inflam-ct-corr-title">Age Correlation by Cell Type</div>
                        <div class="viz-subtitle">Spearman œÅ for each cytokine √ó cell type (66 cell types √ó 43 cytokines)</div>
                        <div id="inflam-celltype-corr-heatmap" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Age/BMI Stratified Tab -->
            <div class="tab-content" id="tab-inflam-age-bmi-stratified">
                <div class="controls">
                    <div class="control-group">
                        <label>Stratify By</label>
                        <select id="inflam-stratify-by">
                            <option value="age">Age (decades)</option>
                            <option value="bmi">BMI (WHO categories)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cell Type</label>
                        <select id="inflam-boxplot-celltype">
                            <option value="All">All (sample-level)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="inflam-boxplot-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                            <option value="both">Both (22 shared)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Protein</label>
                        <select id="inflam-boxplot-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="inflam-boxplot-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off" value="IFNG">
                        <div id="inflam-boxplot-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Age Bins:</strong> &lt;30, 30-39, 40-49, 50-59, 60-69, 70+ years<br>
                    <strong>BMI Categories:</strong> Underweight (&lt;18.5), Normal (18.5-25), Overweight (25-30), Obese (&gt;30)
                </div>

                <div class="viz-container" style="min-height: 500px;">
                    <div class="viz-title" id="inflam-boxplot-title">Age-Stratified Cytokine Activity</div>
                    <div class="viz-subtitle" id="inflam-boxplot-subtitle">Distribution of activity scores across age bins</div>
                    <div id="inflam-stratified-boxplot" class="loading">Loading...</div>
                </div>

                <!-- Cell Type Heatmap -->
                <div class="viz-container" style="min-height: 400px; margin-top: 2rem;">
                    <div class="viz-title" id="inflam-celltype-stratified-title">Cell Type-Specific Activity Heatmap</div>
                    <div class="viz-subtitle" id="inflam-celltype-stratified-subtitle">Median activity across cell types and age/BMI bins</div>
                    <div id="inflam-celltype-stratified-heatmap" class="loading">Loading...</div>
                </div>
            </div>

            <!-- Disease Tab -->
            <div class="tab-content" id="tab-inflam-disease">
                <div class="controls">
                    <div class="control-group">
                        <label>Disease Group</label>
                        <select id="inflam-disease-group">
                            <option value="all">All Diseases</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="inflam-disease-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Signature</label>
                        <select id="inflam-disease-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="inflam-disease-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off" value="IFNG">
                        <div id="inflam-disease-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Disease-Cell Type Activity</div>
                        <div class="viz-subtitle">Activity profile across cell types per disease</div>
                        <div id="inflam-disease-bar" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Disease Activity Heatmap</div>
                        <div class="viz-subtitle">Diseases x Signatures</div>
                        <div id="inflam-disease-heatmap" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Disease Flow Tab -->
            <div class="tab-content" id="tab-disease-sankey">
                <div class="viz-container" style="min-height: 650px;">
                    <div class="viz-title">Sample Flow: Study ‚Üí Disease ‚Üí Disease Group</div>
                    <div class="viz-subtitle">Distribution of 1,047 samples across 25 studies, 20 diseases, and 6 disease groups</div>
                    <div id="disease-sankey" class="loading">Loading data...</div>
                </div>
            </div>

            <!-- Differential Tab (Disease vs Healthy) -->
            <div class="tab-content" id="tab-inflam-differential">
                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Disease vs Healthy Comparison:</strong> Wilcoxon rank-sum test comparing cytokine activity between disease and healthy samples.
                    <br><em style="color: #666;">
                    <strong>Study-matched:</strong> CD, COPD, COVID, HBV, HIV, HNSCC, MS, PS, PSA, RA, SLE, UC, asthma, flu, sepsis - compared to healthy from same study.
                    <br><strong style="color: #d62728;">Pooled healthy ‚ö†Ô∏è:</strong> BRCA, CRC, NPC, cirrhosis - no matched controls in study; compared to all healthy samples (interpret with caution).
                    </em>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Disease</label>
                        <select id="inflam-diff-disease">
                            <option value="all">All Diseases vs Healthy</option>
                            <!-- Populated dynamically with disease options -->
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="inflam-diff-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title" id="inflam-diff-volcano-title">Volcano Plot: Disease vs Healthy</div>
                        <div class="viz-subtitle" id="inflam-diff-volcano-subtitle">Effect size (activity difference) vs significance (-log10 p-value)</div>
                        <div id="inflam-diff-volcano" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title" id="inflam-diff-bar-title">Top Differential Signatures</div>
                        <div class="viz-subtitle" id="inflam-diff-bar-subtitle">Sorted by significance (|effect| √ó -log10 p)</div>
                        <div id="inflam-diff-bar" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Treatment Response Tab -->
            <div class="tab-content" id="tab-treatment-response">
                <div class="controls">
                    <div class="control-group">
                        <label>Disease</label>
                        <select id="treatment-disease">
                            <option value="all">All Diseases</option>
                            <option value="RA">Rheumatoid Arthritis (RA)</option>
                            <option value="PS">Psoriasis (PS)</option>
                            <option value="PSA">Psoriatic Arthritis (PSA)</option>
                            <option value="CD">Crohn's Disease (CD)</option>
                            <option value="UC">Ulcerative Colitis (UC)</option>
                            <option value="SLE">Systemic Lupus (SLE)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="treatment-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Model</label>
                        <select id="prediction-model">
                            <option value="all">All Models</option>
                            <option value="Logistic Regression">Logistic Regression</option>
                            <option value="Random Forest">Random Forest</option>
                        </select>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title">ROC Curves: Treatment Response Prediction</div>
                        <div class="viz-subtitle">AUC performance for responder vs non-responder classification</div>
                        <div id="treatment-roc" class="loading">Loading data...</div>
                    </div>
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title">Feature Importance</div>
                        <div class="viz-subtitle">Top predictive cytokine signatures</div>
                        <div id="treatment-importance" class="loading">Loading data...</div>
                    </div>
                </div>

                <div class="viz-container" style="min-height: 400px; margin-top: 1rem;">
                    <div class="viz-title">Response Prediction Scores</div>
                    <div class="viz-subtitle">Distribution of predicted probabilities for responders vs non-responders</div>
                    <div id="treatment-violin" class="loading">Loading data...</div>
                </div>
            </div>

            <!-- Cohort Validation Tab -->
            <div class="tab-content" id="tab-cohort-validation">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="validation-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Comparison</label>
                        <select id="validation-cohorts">
                            <option value="main-validation">Main vs Validation</option>
                            <option value="main-external">Main vs External</option>
                            <option value="validation-external">Validation vs External</option>
                        </select>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Cross-Cohort Correlation</div>
                        <div class="viz-subtitle">Signature activity correlation between cohorts</div>
                        <div id="cohort-scatter" class="loading">Loading data...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Consistency Metrics</div>
                        <div class="viz-subtitle">Per-signature correlation coefficients</div>
                        <div id="cohort-consistency" class="loading">Loading data...</div>
                    </div>
                </div>
            </div>

            <!-- Severity Correlation Tab -->
            <div class="tab-content" id="tab-inflam-severity">
                <div class="controls">
                    <div class="control-group">
                        <label>Disease</label>
                        <select id="severity-disease">
                            <!-- Populated dynamically from data -->
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="severity-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Signature</label>
                        <select id="severity-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="severity-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off" value="IFNG">
                        <div id="severity-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Disease Severity Analysis:</strong> Compare cytokine activity across severity stages within each disease.
                    <br><em style="color: #666;">Data from 11 diseases with clinical severity staging: COVID (7 stages), COPD (GOLD), SLE (Flare), Asthma (GINA), etc.</em>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title">Activity by Severity Stage</div>
                        <div class="viz-subtitle" id="severity-heatmap-subtitle">Mean activity across severity categories</div>
                        <div id="severity-heatmap" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title">Severity Progression</div>
                        <div class="viz-subtitle" id="severity-line-subtitle">Activity trend across severity stages</div>
                        <div id="severity-line" class="loading">Loading...</div>
                    </div>
                </div>

                <div class="viz-container" style="min-height: 400px;">
                    <div class="viz-title">Activity Distribution by Severity</div>
                    <div class="viz-subtitle" id="severity-boxplot-subtitle">Distribution across severity categories</div>
                    <div id="severity-boxplot" class="loading">Loading...</div>
                </div>
            </div>

            <!-- Cell Type Drivers Tab -->
            <div class="tab-content" id="tab-inflam-drivers">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="drivers-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (100 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Disease</label>
                        <select id="drivers-disease">
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Protein</label>
                        <select id="drivers-cytokine">
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="drivers-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off">
                        <div id="drivers-suggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 4px; max-height: 200px; overflow-y: auto; z-index: 100; box-shadow: 0 4px 6px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Driving Cell Populations:</strong> Identify which cell types contribute most to disease-specific cytokine signatures. Shows disease vs healthy differential activity stratified by cell type.
                </div>

                <div class="two-col">
                    <div class="viz-container large">
                        <div class="viz-title">Cell Type Contribution</div>
                        <div class="viz-subtitle">Disease vs Healthy effect size by cell type</div>
                        <div id="drivers-bar" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">Cell Type Heatmap</div>
                        <div class="viz-subtitle">Disease-specific signatures across cell types</div>
                        <div id="drivers-heatmap" class="loading">Loading...</div>
                    </div>
                </div>

                <div class="viz-container">
                    <div class="viz-title">Cell Type Importance Ranking</div>
                    <div class="viz-subtitle">Contribution to overall disease signature (variance explained)</div>
                    <div id="drivers-importance" class="loading">Loading...</div>
                </div>
            </div>
        </div>
    </section>

    <!-- scAtlas Section -->
    <section id="scatlas">
        <div class="container">
            <h2>scAtlas: Tissue & Cell Type Signatures</h2>
            <p class="narrow">Explore cytokine activity signatures across 35 organs and 376 cell types from the Human Cell Atlas.</p>

            <div class="tabs">
                <button class="tab active" data-tab="scatlas-celltypes">Cell Types</button>
                <button class="tab" data-tab="tissue-atlas">Tissue Atlas</button>
                <button class="tab" data-tab="differential-analysis">Differential Analysis</button>
                <button class="tab" data-tab="immune-infiltration">Immune Infiltration</button>
                <button class="tab" data-tab="tcell-function">T Cell State</button>
                <button class="tab" data-tab="exhaustion">Exhaustion Differential</button>
                <button class="tab" data-tab="caf-classification">CAF Types</button>
            </div>

            <!-- Tissue Atlas Tab (Combined Normal & Cancer) -->
            <div class="tab-content" id="tab-tissue-atlas">
                <div class="controls">
                    <div class="control-group">
                        <label>View Mode</label>
                        <select id="tissue-mode" onchange="updateTissueAtlas()">
                            <option value="normal">Normal Tissues (35 organs)</option>
                            <option value="cancer-only">Cancer Tissues (13 types)</option>
                            <option value="comparison">Cancer vs Normal (grouped boxplot)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="tissue-sig-type" onchange="updateTissueAtlas()">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Signature</label>
                        <select id="tissue-signature" onchange="syncTissueSearch(); updateTissueAtlas()" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="tissue-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off" value="IFNG"
                               oninput="showTissueSuggestions()" onkeyup="if(event.key==='Enter') { syncTissueDropdown(); updateTissueAtlas(); }">
                        <div id="tissue-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong id="tissue-atlas-description">Tissue Atlas:</strong>
                    <span id="tissue-atlas-desc-text">Compare cytokine activity across 35 normal human organs from scAtlas.</span>
                </div>

                <!-- Activity Boxplots (Cell-type agnostic) -->
                <div class="viz-container" style="min-height: 400px;">
                    <div class="viz-title" id="tissue-boxplot-title">Activity Distribution by Tissue</div>
                    <div class="viz-subtitle" id="tissue-boxplot-subtitle">Cell-type agnostic mean activity per tissue</div>
                    <div id="tissue-boxplot" class="loading">Loading...</div>
                </div>

                <!-- Heatmap -->
                <div class="viz-container" style="min-height: 500px; margin-top: 1rem;">
                    <div class="viz-title" id="tissue-heatmap-title">Signature √ó Tissue Heatmap</div>
                    <div class="viz-subtitle" id="tissue-heatmap-subtitle">Activity patterns across tissues</div>
                    <div id="tissue-heatmap" class="loading">Loading...</div>
                </div>
            </div>

            <!-- Cell Types Tab -->
            <div class="tab-content active" id="tab-scatlas-celltypes">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="ct-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins, top 50 in heatmap)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Filter by Organ</label>
                        <select id="ct-organ-filter">
                            <option value="">All Organs</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Select Protein</label>
                        <select id="scatlas-ct-protein-dropdown" style="width: 150px;">
                            <option value="IFNG">IFNG</option>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="control-group" style="position: relative;">
                        <label>Or Search</label>
                        <input type="text" id="scatlas-ct-protein-search" placeholder="Search..."
                               style="width: 120px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" autocomplete="off" value="IFNG">
                        <div id="scatlas-ct-suggestions" style="position: absolute; top: 100%; left: 0; width: 120px; max-height: 200px; overflow-y: auto; background: white; border: 1px solid #ddd; border-radius: 4px; display: none; z-index: 100; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></div>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Cell Type Activity Profile</div>
                        <div class="viz-subtitle" id="scatlas-celltype-bar-subtitle">Mean activity across cell types (376 total)</div>
                        <div id="scatlas-celltype-bar" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Activity Heatmap</div>
                        <div class="viz-subtitle" id="celltype-heatmap-subtitle">Top variable cell types x signatures</div>
                        <div id="celltype-heatmap" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Differential Analysis Tab (Unified Tissue Comparison) -->
            <div class="tab-content" id="tab-differential-analysis">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="diff-sigtype" onchange="updateDiffSignatureList(); updateDifferentialAnalysis()">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,249 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cancer Type</label>
                        <select id="diff-cancer-type" onchange="updateDifferentialAnalysis()">
                            <option value="all">All Cancers (Pan-Cancer)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature (for boxplot)</label>
                        <input type="text" id="diff-sig-search" placeholder="Search..."
                               oninput="filterDiffSignatures()"
                               style="width: 120px; padding: 0.4rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 4px;">
                        <select id="diff-signature" onchange="updateDiffBoxplot()" size="1" style="width: 180px;">
                            <option value="IFNG">IFNG</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;" id="diff-description-card">
                    <strong>Differential Analysis:</strong> Compare cytokine activity between tumor, adjacent, and normal tissue:
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                        <li><strong style="color:#d62728;">Tumor:</strong> Cancer tissue (pan-cancer, 147 cell type samples)</li>
                        <li><strong style="color:#ff7f0e;">Adjacent:</strong> Tumor-adjacent normal tissue (matched controls, 105 samples)</li>
                        <li><strong style="color:#2ca02c;">Normal:</strong> Healthy tissue from scAtlas normal organs (748 samples)</li>
                    </ul>
                </div>

                <div class="two-col">
                    <!-- Volcano plot -->
                    <div class="viz-container" style="min-height: 400px;">
                        <div class="viz-title">Differential Volcano Plot</div>
                        <div class="viz-subtitle" id="diff-volcano-subtitle">Tumor vs Adjacent: Œî activity vs significance</div>
                        <div id="diff-volcano" class="loading">Loading...</div>
                    </div>
                    <!-- Tissue Comparison Boxplot -->
                    <div class="viz-container" style="min-height: 400px;">
                        <div class="viz-title">Tissue Comparison</div>
                        <div class="viz-subtitle" id="diff-boxplot-subtitle">Activity distribution across tissue types</div>
                        <div id="diff-boxplot" class="loading">Loading...</div>
                    </div>
                </div>

                <!-- Top differential signatures (full width) -->
                <div class="viz-container" style="min-height: 350px; margin-top: 1rem;">
                    <div class="viz-title">Top Differential Signatures</div>
                    <div class="viz-subtitle">Ranked by absolute activity difference (Tumor vs Adjacent)</div>
                    <div id="diff-top-bar" class="loading">Loading...</div>
                </div>
            </div>

            <!-- Immune Infiltration Tab -->
            <div class="tab-content" id="tab-immune-infiltration">
                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Tumor Microenvironment Composition:</strong> Immune, malignant, and stromal cell proportions across cancer types.
                    <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 0.5rem; margin: 0.5rem 0;">
                        <strong>Data Source:</strong> Primary tumor tissue samples only (excludes PBMC/Blood, Adjacent, Metastasis)
                    </div>
                </div>

                <!-- TME Composition (full breakdown) -->
                <div class="viz-container" style="min-height: 350px; margin-bottom: 1rem;">
                    <div class="viz-title" id="tme-composition-title">Tumor Microenvironment Composition</div>
                    <div class="viz-subtitle" id="tme-composition-subtitle">Breakdown: Malignant cells, Immune cells, Stromal cells, Other</div>
                    <div id="tme-composition" class="loading">Loading data...</div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 400px;">
                        <div class="viz-title" id="infiltration-stacked-title">Immune Cell Composition</div>
                        <div class="viz-subtitle" id="infiltration-stacked-subtitle">Breakdown within tumor-infiltrating immune cells</div>
                        <div id="infiltration-stacked" class="loading">Loading data...</div>
                    </div>
                    <div class="viz-container" style="min-height: 400px;">
                        <div class="viz-title" id="infiltration-scatter-title">Clinical Ratios</div>
                        <div class="viz-subtitle" id="infiltration-scatter-subtitle">CD8:Treg and T:Myeloid ratios with data quality</div>
                        <div id="infiltration-scatter" class="loading">Loading data...</div>
                    </div>
                </div>
            </div>

            <!-- T Cell State Tab -->
            <div class="tab-content" id="tab-tcell-function">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="tcell-sigtype" onchange="updateTcellSignatureList(); updateTcellFunction()">
                            <option value="cytosig">CytoSig (43 cytokines)</option>
                            <option value="secact">SecAct (100 secreted proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cancer Type</label>
                        <select id="tcell-cancer" onchange="updateTcellFunction()">
                            <option value="all">All Cancers</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature (for boxplot)</label>
                        <input type="text" id="tcell-sig-search" placeholder="Search..."
                               oninput="filterTcellSignatures()"
                               style="width: 120px; padding: 0.4rem; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 4px;">
                        <select id="tcell-signature" onchange="updateTcellBoxplot()" size="1" style="width: 180px;">
                            <option value="top">Top 6 differential</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>T Cell Functional States:</strong> Classified by marker gene patterns in cell type annotations.
                    <div style="margin-top: 0.5rem;">
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #d62728; font-weight: bold;">‚óè Exhausted</span> - Dysfunctional T cells with inhibitory receptor expression<br>
                            <small style="color: #666; margin-left: 1rem;">Markers: PDCD1 (PD-1), CTLA4, LAG3, TIM3, TIGIT, Tex</small><br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: T01_CD8Tex_PDCD1, T09_CD8Tex_LAG3, CD8_exhausted_*, CD4_exhausted_*</small>
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #2ca02c; font-weight: bold;">‚óè Cytotoxic</span> - Effector T cells with cytolytic function<br>
                            <small style="color: #666; margin-left: 1rem;">Markers: GZMB (Granzyme B), GZMK, PRF1 (Perforin), GNLY</small><br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: T02_CD8Tc_GZMB, T03_CD8Tc_GZMK, CD8_cytotoxic_*, NK-like T cells</small>
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #1f77b4; font-weight: bold;">‚óè Memory</span> - Long-lived antigen-experienced T cells<br>
                            <small style="color: #666; margin-left: 1rem;">Markers: Tem (effector memory), Tcm (central memory)</small><br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: T05_CD8Tem, T06_CD8Tcm, CD4_memory_*, CD8_memory_*</small>
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #ff7f0e; font-weight: bold;">‚óè Naive</span> - Antigen-inexperienced T cells<br>
                            <small style="color: #666; margin-left: 1rem;">Markers: CCR7, Tn (naive)</small><br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: T07_CD8Tn, CD4_naive_*, CCR7+ T cells</small>
                        </div>
                        <div>
                            <span style="color: #9467bd; font-weight: bold;">‚óè Other T cells</span> - Specialized T cell subsets<br>
                            <small style="color: #666; margin-left: 1rem;">Includes: MAIT cells, Œ≥Œ¥ T cells, Tregs (FOXP3+), unclassified T cells</small>
                        </div>
                    </div>
                    <div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid #eee; font-size: 0.85rem; color: #666;">
                        <strong>Note:</strong> Classification is based on pattern matching in scAtlas cell type annotations. State availability varies by cancer type based on original study annotations.
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title" id="tcell-heatmap-title">Cytokine Activity by T Cell State</div>
                        <div class="viz-subtitle" id="tcell-heatmap-subtitle">Mean activity of top cytokines across functional states</div>
                        <div id="tcell-state-heatmap" class="loading">Loading data...</div>
                    </div>
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title" id="tcell-bar-title">State Distribution</div>
                        <div class="viz-subtitle" id="tcell-bar-subtitle">Cell counts by functional state</div>
                        <div id="tcell-state-bar" class="loading">Loading data...</div>
                    </div>
                </div>

                <div class="viz-container" style="min-height: 400px; margin-top: 1rem;">
                    <div class="viz-title">Cytokine Activity Distribution by State</div>
                    <div class="viz-subtitle">Box plots showing activity distribution for top differential signatures</div>
                    <div id="tcell-state-comparison" class="loading">Loading data...</div>
                </div>
            </div>

            <!-- Exhaustion Differential Tab -->
            <div class="tab-content" id="tab-exhaustion">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="exhaustion-sigtype" onchange="updateExhaustion()">
                            <option value="cytosig">CytoSig (43 cytokines)</option>
                            <option value="secact">SecAct (100 secreted proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cancer Type</label>
                        <select id="exhaustion-cancer" onchange="updateExhaustion()">
                            <option value="all">All Cancers</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Exhausted vs Non-exhausted T cells:</strong> Differential activity analysis between dysfunctional and functional T cells.
                    <div style="margin-top: 0.5rem;">
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #d62728; font-weight: bold;">‚óè Exhausted T cells</span> - Dysfunctional T cells with inhibitory receptor expression<br>
                            <small style="color: #666; margin-left: 1rem;">Markers: PDCD1 (PD-1), CTLA4, LAG3, TIM3, TIGIT, Tex</small><br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: T01_CD8Tex_PDCD1, T09_CD8Tex_LAG3, CD8_exhausted_*, CD4_exhausted_*, Tex_*, *_TIGIT+</small>
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #2166ac; font-weight: bold;">‚óè Non-exhausted T cells</span> - Functional T cells (combined from 3 groups):<br>
                            <small style="color: #666; margin-left: 1rem;"><strong>Cytotoxic:</strong> T02_CD8Tc_GZMB, T03_CD8Tc_GZMK, CD8_cytotoxic_*, NK-like T cells</small><br>
                            <small style="color: #666; margin-left: 1rem;"><strong>Memory:</strong> T05_CD8Tem, T06_CD8Tcm, CD4_memory_*, CD8_memory_*</small><br>
                            <small style="color: #666; margin-left: 1rem;"><strong>Other:</strong> MAIT cells, Œ≥Œ¥ T cells, Tregs (FOXP3+), unclassified T cells</small>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #eee; font-size: 0.85rem; color: #666;">
                        <strong>Interpretation:</strong> Positive Œî Activity = higher in exhausted; Negative = higher in non-exhausted (functional) T cells.
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title">Differential Cytokine Activity</div>
                        <div class="viz-subtitle">Activity difference: Exhausted vs Non-exhausted T cells</div>
                        <div id="exhaustion-heatmap" class="loading">Loading data...</div>
                    </div>
                    <div class="viz-container" style="min-height: 450px;">
                        <div class="viz-title">Activity Correlation</div>
                        <div class="viz-subtitle">Mean activity in exhausted vs non-exhausted T cells</div>
                        <div id="exhaustion-scatter" class="loading">Loading data...</div>
                    </div>
                </div>
            </div>

            <!-- CAF Classification Tab -->
            <div class="tab-content" id="tab-caf-classification">
                <div class="controls">
                    <div class="control-group">
                        <label>Cancer Type</label>
                        <select id="caf-cancer-type">
                            <option value="all">All Cancers</option>
                            <option value="Breast">Breast</option>
                            <option value="Lung">Lung</option>
                            <option value="Colon">Colon</option>
                            <option value="Pancreas">Pancreas</option>
                            <option value="Ovary">Ovarian</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="caf-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Cancer-Associated Fibroblast (CAF) Subtypes:</strong>
                    <div style="margin-top: 0.5rem;">
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #1f77b4; font-weight: bold;">‚óè myCAF</span> (myofibroblastic) - ECM remodeling, contractile markers (ACTA2, COL1A1)<br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: S23_myCAF_ACTA2</small>
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #ff7f0e; font-weight: bold;">‚óè iCAF</span> (inflammatory) - Cytokine secretion, immune modulation (IL6, CXCL12)<br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: S22_iCAF_IL6</small>
                        </div>
                        <div style="margin-bottom: 0.5rem;">
                            <span style="color: #2ca02c; font-weight: bold;">‚óè apCAF</span> (antigen-presenting) - MHC-II expression (HLA-DR, CD74)<br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: S24_apCAF_CD74</small>
                        </div>
                        <div>
                            <span style="color: #999; font-weight: bold;">‚óè Other Fibroblasts</span> (12 subtypes) - General fibroblast populations<br>
                            <small style="color: #666; margin-left: 1rem;">Cell types: S01_Fb_PI16, S02_Fb_C7, S03_Fb_LAMC1, S04_Fb_CD9, S05_Fb_DPEP1, S06_Fb_ARID5B, S07_Fb_TCF21, S08_Fb_PTGES, S09_Fb_CEBPB, S10_Fb_MXRA5, S11_Fb_IGFBP2, S12_Fb_MMP11</small>
                        </div>
                    </div>
                    <div style="margin-top: 0.75rem; padding-top: 0.5rem; border-top: 1px solid #eee; font-size: 0.85rem; color: #666;">
                        <strong>Note:</strong> CAF subtypes are classified based on scAtlas cell type annotations (S22-S24 prefixes). Other fibroblasts (S01-S12) represent diverse stromal populations not classified into canonical CAF subtypes.
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container large">
                        <div class="viz-title">CAF Subtype Activity Profile</div>
                        <div class="viz-subtitle">Cytokine signature activity across CAF subtypes</div>
                        <div id="caf-activity-bar" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">CAF Subtype Composition</div>
                        <div class="viz-subtitle">Breakdown by myCAF, iCAF, apCAF, Other per cancer type</div>
                        <div id="caf-proportions" class="loading">Loading...</div>
                    </div>
                </div>

                <div class="viz-container">
                    <div class="viz-title">CAF Signature Heatmap</div>
                    <div class="viz-subtitle">Cytokine activity across CAF subtypes and cancer types</div>
                    <div id="caf-heatmap" class="loading">Loading...</div>
                </div>
            </div>

        </div>
    </section>

    <!-- Cross-Atlas Section -->
    <section id="cross-atlas">
        <div class="container">
            <h2>Cross-Atlas Integration</h2>
            <p class="narrow">Compare cytokine activity patterns across CIMA (healthy), Inflammation (disease), and scAtlas (organs/cancer) to identify conserved and context-specific signatures.</p>

            <div class="tabs">
                <button class="tab active" data-tab="atlas-overview">Overview</button>
                <button class="tab" data-tab="celltype-mapping">Cell Type Mapping</button>
                <button class="tab" data-tab="atlas-comparison">Atlas Comparison</button>
                <button class="tab" data-tab="conserved-signatures">Conserved</button>
                <button class="tab" data-tab="meta-analysis">Meta-Analysis</button>
                <button class="tab" data-tab="signature-correlation">Signature Matrix</button>
                <button class="tab" data-tab="pathway-enrichment">Pathways</button>
            </div>

            <!-- Atlas Overview Tab -->
            <div class="tab-content active" id="tab-atlas-overview">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="cross-total-cells">19M+</div>
                        <div class="stat-label">Total Cells Analyzed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="cross-total-samples">1,500+</div>
                        <div class="stat-label">Patient/Donor Samples</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="cross-total-celltypes">400+</div>
                        <div class="stat-label">Unique Cell Types</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="cross-total-signatures">1,249</div>
                        <div class="stat-label">Secreted Protein Signatures</div>
                    </div>
                </div>

                <div class="viz-container" style="min-height: 500px;">
                    <div class="viz-title">Atlas Data Summary</div>
                    <div class="viz-subtitle">Comparison of cell counts, sample sizes, and coverage across atlases</div>
                    <div id="atlas-summary-chart" class="loading">Loading...</div>
                </div>
            </div>

            <!-- Cell Type Mapping Tab -->
            <div class="tab-content" id="tab-celltype-mapping">
                <div class="controls">
                    <div class="control-group">
                        <label>Mapping Level</label>
                        <select id="mapping-level">
                            <option value="coarse">Coarse (8 Lineages)</option>
                            <option value="fine">Fine (~32 Types)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cell Lineage Filter</label>
                        <select id="mapping-lineage">
                            <option value="all">All Lineages</option>
                            <option value="T_cell">T Cells (CD4, CD8, Unconventional)</option>
                            <option value="Myeloid">Myeloid (Mono, DC, Mac)</option>
                            <option value="B_cell">B Cells & Plasma</option>
                            <option value="NK_ILC">NK & ILC</option>
                        </select>
                    </div>
                </div>

                <div class="viz-container">
                    <div class="viz-title">Cell Type Harmonization</div>
                    <div class="viz-subtitle" id="celltype-mapping-subtitle">Mapping of cell types across atlases (Sankey diagram)</div>
                    <div id="celltype-sankey" class="loading" style="height: 420px;">Loading...</div>
                </div>

                <div class="viz-container" style="margin-top: 20px;">
                    <div class="viz-title" id="celltype-detail-title">Original Annotations per Lineage</div>
                    <div class="viz-subtitle" id="celltype-detail-subtitle">Number of atlas-specific cell type annotations mapped to each harmonized lineage</div>
                    <div id="celltype-detail-bar" style="height: 320px;"></div>
                </div>

                <div id="celltype-mapping-info" style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 0.9rem;"></div>
            </div>

            <!-- Conserved Signatures Tab -->
            <div class="tab-content" id="tab-conserved-signatures">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="conserved-sig-type">
                            <option value="cytosig">CytoSig (43 cytokines)</option>
                            <option value="secact">SecAct (secreted proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Filter</label>
                        <select id="conserved-filter">
                            <option value="all">All signatures</option>
                            <option value="highly_conserved">Highly conserved (r &gt; 0.7 in 2+ pairs)</option>
                            <option value="moderately_conserved">Moderately conserved (r &gt; 0.5 in 2+ pairs)</option>
                            <option value="atlas_specific">Atlas-specific (low correlation)</option>
                            <option value="insufficient_data">Insufficient data (1 pair only)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Search Signature</label>
                        <input type="text" id="conserved-search" list="conserved-signature-list" placeholder="Type to search..." style="padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px; width: 150px;">
                        <datalist id="conserved-signature-list"></datalist>
                    </div>
                </div>

                <!-- Signature Detail Panel (shown when a signature is selected) -->
                <div id="conserved-signature-detail" style="display: none; background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                        <div>
                            <div style="font-size: 1.25rem; font-weight: bold; color: #1565c0;" id="conserved-detail-name">-</div>
                            <div style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;" id="conserved-detail-category">-</div>
                        </div>
                        <button onclick="clearConservedSearch()" style="background: #1565c0; color: white; border: none; border-radius: 4px; padding: 0.25rem 0.75rem; cursor: pointer; font-size: 0.85rem;">Clear</button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-top: 1rem;" id="conserved-detail-correlations">
                        <!-- Filled by JS -->
                    </div>
                </div>

                <!-- Summary Cards -->
                <div class="summary-cards" id="conserved-summary-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                    <div class="stat-card" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #2e7d32;" id="conserved-highly-count">-</div>
                        <div style="font-size: 0.85rem; color: #1b5e20;">Highly Conserved</div>
                        <div style="font-size: 0.75rem; color: #666;">r &gt; 0.7 in 2+ pairs</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #e65100;" id="conserved-moderate-count">-</div>
                        <div style="font-size: 0.85rem; color: #bf360c;">Moderately Conserved</div>
                        <div style="font-size: 0.75rem; color: #666;">r &gt; 0.5 in 2+ pairs</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #fce4ec 0%, #f8bbd9 100%); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #c2185b;" id="conserved-specific-count">-</div>
                        <div style="font-size: 0.85rem; color: #880e4f;">Atlas-Specific</div>
                        <div style="font-size: 0.75rem; color: #666;">Low cross-atlas correlation</div>
                    </div>
                    <div class="stat-card" style="background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: bold; color: #616161;" id="conserved-insufficient-count">-</div>
                        <div style="font-size: 0.85rem; color: #424242;">Limited Data</div>
                        <div style="font-size: 0.75rem; color: #666;">Only 1 atlas pair</div>
                    </div>
                </div>

                <!-- Combined panel: Correlation Summary (top) + Category Distribution (bottom) -->
                <div class="viz-container" style="margin-bottom: 1.5rem; padding: 1rem;">
                    <div style="margin-bottom: 1rem;">
                        <div class="viz-title" id="conserved-corr-title">Cross-Atlas Correlation Summary</div>
                        <div class="viz-subtitle" id="conserved-corr-subtitle">Overall activity pattern correlation between atlas pairs</div>
                        <div id="conserved-pair-correlations" style="display: flex; gap: 1.5rem; justify-content: center; flex-wrap: wrap; margin-top: 0.5rem;">
                            <!-- Filled by JS -->
                        </div>
                    </div>
                    <div style="border-top: 1px solid #eee; padding-top: 1rem;">
                        <div class="viz-title">Conservation Category Distribution</div>
                        <div class="viz-subtitle">Breakdown of signatures by cross-atlas reliability</div>
                        <div id="conserved-category-chart" style="height: 150px;">Loading...</div>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title" id="conserved-heatmap-title">Per-Signature Cross-Atlas Correlation</div>
                        <div class="viz-subtitle" id="conserved-heatmap-subtitle">Correlation coefficient for each signature across cell types (sorted by mean r)</div>
                        <div id="conserved-heatmap" class="loading" style="height: 450px;">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Signature Reliability List</div>
                        <div class="viz-subtitle">Signatures ranked by cross-atlas consistency</div>
                        <div id="conserved-table" style="max-height: 450px; overflow-y: auto;">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Atlas Comparison Tab -->
            <div class="tab-content" id="tab-atlas-comparison">
                <div class="controls">
                    <div class="control-group">
                        <label>Atlas Pair</label>
                        <select id="atlas-comparison-type">
                            <option value="cima-inflam">CIMA vs Inflammation Atlas</option>
                            <option value="cima-scatlas">CIMA vs scAtlas (Normal)</option>
                            <option value="inflam-scatlas">Inflammation vs scAtlas (Normal)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="atlas-comp-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (100 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cell Type Level</label>
                        <select id="atlas-comp-level">
                            <option value="coarse">Coarse (8 lineages)</option>
                            <option value="fine">Fine (~21 types)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>View</label>
                        <select id="atlas-comp-view">
                            <option value="scatter">Pseudobulk Mean</option>
                            <option value="singlecell">Single-cell Mean</option>
                        </select>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title" id="atlas-scatter-title">Cross-Atlas Scatter</div>
                        <div class="viz-subtitle" id="atlas-scatter-subtitle">Signature activity correlation between atlases</div>
                        <div id="atlas-scatter" class="loading" style="height: 450px;">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title" id="atlas-diff-title">Per-Cell Type Correlation</div>
                        <div class="viz-subtitle" id="atlas-diff-subtitle">Activity correlation breakdown by harmonized cell type</div>
                        <div id="atlas-diff-bar" class="loading" style="height: 450px;">Loading...</div>
                    </div>
                </div>

                <div id="atlas-comparison-summary" style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 0.9rem;"></div>
            </div>

            <!-- Meta-Analysis Tab -->
            <div class="tab-content" id="tab-meta-analysis">
                <div class="controls">
                    <div class="control-group">
                        <label>Analysis Type</label>
                        <select id="meta-analysis-type">
                            <option value="age">Age Correlation</option>
                        </select>
                    </div>
                </div>

                <!-- Replication Summary -->
                <div id="meta-summary" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                    <div style="display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
                        <div style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #2e7d32;" id="meta-replicated-count">-</div>
                            <div style="font-size: 0.85rem; color: #1b5e20;">Replicated Signatures</div>
                            <div style="font-size: 0.75rem; color: #666;">Data from 2+ atlases</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #1565c0;" id="meta-consistent-count">-</div>
                            <div style="font-size: 0.85rem; color: #0d47a1;">Consistent Direction</div>
                            <div style="font-size: 0.75rem; color: #666;">Same sign across atlases</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 2rem; font-weight: bold; color: #7b1fa2;" id="meta-significant-count">-</div>
                            <div style="font-size: 0.85rem; color: #4a148c;">Significant Pooled</div>
                            <div style="font-size: 0.75rem; color: #666;">p &lt; 0.05 in meta-analysis</div>
                        </div>
                        <div style="flex: 1; min-width: 200px; text-align: left; padding-left: 1rem; border-left: 2px solid #a5d6a7;">
                            <div style="font-size: 0.9rem; color: #333;"><strong>Cross-Atlas Replication</strong></div>
                            <div style="font-size: 0.8rem; color: #666; margin-top: 0.25rem;">Shows signatures with age correlation data from multiple atlases (CIMA + Inflammation). Only replicated associations are displayed.</div>
                        </div>
                    </div>
                </div>

                <div class="two-col">
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Replicated Age Associations</div>
                        <div class="viz-subtitle">Forest plot showing effect sizes from each atlas and pooled estimate</div>
                        <div id="meta-forest" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container" style="min-height: 500px;">
                        <div class="viz-title">Replication Consistency</div>
                        <div class="viz-subtitle">I¬≤ = 0%: identical effects; I¬≤ > 75%: substantial heterogeneity</div>
                        <div id="meta-heterogeneity" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Signature Correlation Matrix Tab -->
            <div class="tab-content" id="tab-signature-correlation">
                <div class="controls">
                    <div class="control-group">
                        <label>Signature Type</label>
                        <select id="sigcorr-sig-type">
                            <option value="CytoSig">CytoSig (43 cytokines)</option>
                            <option value="SecAct">SecAct (1,170 proteins)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Correlation Method</label>
                        <select id="sigcorr-method">
                            <option value="spearman">Spearman</option>
                            <option value="pearson">Pearson</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Atlas</label>
                        <select id="sigcorr-atlas">
                            <option value="all">All Atlases Combined</option>
                            <option value="cima">CIMA (Healthy)</option>
                            <option value="inflammation">Inflammation (Disease)</option>
                            <option value="scatlas">scAtlas (Tissues)</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Signature Correlation Matrix:</strong> Reveals co-regulated cytokine programs. Clusters of highly correlated cytokines may share upstream regulators or functional pathways.
                </div>

                <div class="two-col">
                    <div class="viz-container large">
                        <div class="viz-title">Cytokine Correlation Matrix</div>
                        <div class="viz-subtitle">Pairwise correlations across samples (hierarchically clustered)</div>
                        <div id="sigcorr-matrix" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">Correlation Modules</div>
                        <div class="viz-subtitle">Identified cytokine clusters</div>
                        <div id="sigcorr-modules" class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Pathway Enrichment Tab -->
            <div class="tab-content" id="tab-pathway-enrichment">
                <div class="controls">
                    <div class="control-group">
                        <label>Pathway Database</label>
                        <select id="pathway-db">
                            <option value="kegg">KEGG Pathways</option>
                            <option value="reactome">Reactome</option>
                            <option value="hallmark">MSigDB Hallmarks</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cytokine Module</label>
                        <select id="pathway-module">
                            <option value="all">All Cytokines</option>
                            <option value="inflammatory">Inflammatory (IL-1, IL-6, TNF)</option>
                            <option value="th1">Th1 (IFN-Œ≥, IL-12)</option>
                            <option value="th2">Th2 (IL-4, IL-5, IL-13)</option>
                            <option value="th17">Th17 (IL-17, IL-22, IL-23)</option>
                            <option value="regulatory">Regulatory (IL-10, TGF-Œ≤)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Max Pathways</label>
                        <select id="pathway-max">
                            <option value="10">Top 10</option>
                            <option value="20" selected>Top 20</option>
                            <option value="30">Top 30</option>
                        </select>
                    </div>
                </div>

                <div class="card" style="margin-bottom: 1rem; padding: 1rem;">
                    <strong>Pathway Enrichment:</strong> Analyze biological pathways associated with cytokine activity patterns. Identifies upstream regulators and downstream effects of cytokine signatures.
                </div>

                <div class="two-col">
                    <div class="viz-container large">
                        <div class="viz-title">Enriched Pathways</div>
                        <div class="viz-subtitle">-log10(FDR) for top enriched pathways</div>
                        <div id="pathway-bar" class="loading">Loading...</div>
                    </div>
                    <div class="viz-container">
                        <div class="viz-title">Pathway-Cytokine Network</div>
                        <div class="viz-subtitle">Connections between pathways and cytokines</div>
                        <div id="pathway-network" class="loading">Loading...</div>
                    </div>
                </div>

                <div class="viz-container">
                    <div class="viz-title">Pathway Comparison Across Atlases</div>
                    <div class="viz-subtitle">Enrichment scores in CIMA, Inflammation, and scAtlas</div>
                    <div id="pathway-comparison" class="loading">Loading...</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Methods Section -->
    <section id="methods">
        <div class="container narrow">
            <h2>Methods</h2>

            <h3>Cytokine Activity Inference</h3>
            <p>Cytokine signaling activities were inferred from single-cell RNA-seq data using two complementary approaches:</p>
            <ul>
                <li><strong>CytoSig</strong>: Predicts activities of 44 cytokines based on their downstream transcriptional signatures (Jiang et al., 2021).</li>
                <li><strong>SecAct</strong>: Estimates activities of 1,249 secreted proteins using secreted protein signatures learned from spatial Moran's I autocorrelation.</li>
            </ul>
            <p>Activity scores represent z-scored coefficients from ridge regression of signature gene expression, where positive values indicate upregulation of downstream targets.</p>

            <h3>Data Sources</h3>
            <ul>
                <li><strong>CIMA (Healthy Immune)</strong>: 6.5M cells from 421 healthy donors with matched blood biochemistry and metabolomics</li>
                <li><strong>Inflammation Atlas</strong>: 4.9M cells from 817 samples across inflammatory diseases (RA, IBD, MS, SLE, etc.)</li>
                <li><strong>scAtlas Normal</strong>: 2.3M cells spanning 35 organs and 376 cell types from the Human Cell Atlas</li>
                <li><strong>scAtlas Cancer</strong>: 4.1M cells from pan-cancer datasets with 156 cell type annotations</li>
            </ul>

            <h3>Statistical Analysis</h3>
            <h4>Correlation Analysis</h4>
            <p>Spearman's rank correlation coefficient (œÅ) was used for continuous variables (age, BMI, biochemistry, metabolites). P-values were adjusted using Benjamini-Hochberg FDR correction.</p>

            <h4>Differential Analysis</h4>
            <p>Mann-Whitney U test (Wilcoxon rank-sum) was used for two-group comparisons (sex, disease vs. healthy). Effect sizes are reported as activity difference (z-score units).</p>

            <h4>Treatment Response Prediction</h4>
            <p>Logistic regression and Random Forest classifiers were trained using 5-fold cross-validation. ROC curves show model performance with AUC metrics. Feature importance was assessed using permutation importance for interpretability.</p>

            <h3>Cross-Atlas Integration Methods</h3>

            <h4>Cell Type Harmonization</h4>
            <p>Cell type annotations were harmonized across atlases using manual mapping dictionaries based on canonical marker genes and established nomenclature (Hao et al., 2021). The Sankey diagram shows mapping of atlas-specific annotations to common cell type categories.</p>

            <h4>Meta-Analysis</h4>
            <p>Fixed-effects meta-analysis combines effect sizes across atlases using inverse-variance weighting. Heterogeneity was assessed using the I¬≤ statistic (Higgins et al., 2003):</p>
            <ul>
                <li>I¬≤ &lt; 25%: Low heterogeneity (consistent effects)</li>
                <li>I¬≤ 25-50%: Moderate heterogeneity</li>
                <li>I¬≤ 50-75%: Substantial heterogeneity</li>
                <li>I¬≤ &gt; 75%: Considerable heterogeneity (effects vary across atlases)</li>
            </ul>

            <h4>Signature Correlation Matrix</h4>
            <p>Pairwise Spearman correlations between cytokine activities were computed across all samples. Hierarchical clustering (Ward's method) was applied to identify co-regulated cytokine modules.</p>

            <h4>Pathway Enrichment</h4>
            <p>Cytokine-pathway associations were derived from KEGG, Reactome, and MSigDB Hallmark databases. Over-representation was tested using Fisher's exact test with Benjamini-Hochberg correction (FDR &lt; 0.05).</p>

            <h4>Cross-Atlas Conservation Analysis</h4>
            <p>Signature conservation is assessed using two complementary approaches:</p>
            <ul>
                <li><strong>Cell-type Aware:</strong> For each signature, Spearman correlation is computed between activity values across harmonized cell types between atlas pairs. This measures whether signatures show consistent cell-type-specific patterns (e.g., IFNG high in CD8 T cells, low in B cells in both atlases).</li>
                <li><strong>Cell-type Agnostic:</strong> Overall mean activity (z-score) is compared across atlases regardless of cell type distribution. This assesses whether a signature is generally active or inactive at similar levels across datasets.</li>
            </ul>
            <p>Signatures are categorized based on cell-type aware correlation:</p>
            <ul>
                <li><strong>Highly Conserved:</strong> Spearman r &gt; 0.7 in at least 2 of 3 atlas pairs</li>
                <li><strong>Moderately Conserved:</strong> Spearman r &gt; 0.5 in at least 2 atlas pairs</li>
                <li><strong>Atlas-Specific:</strong> Low correlation across available pairs</li>
                <li><strong>Insufficient Data:</strong> Data available in only 1 atlas pair</li>
            </ul>

            <h3>Visualization Panels</h3>
            <table style="width:100%; border-collapse: collapse; margin: 1rem 0;">
                <tr style="background: #f5f5f5; border-bottom: 2px solid #ddd;">
                    <th style="padding: 0.5rem; text-align: left;">Panel</th>
                    <th style="padding: 0.5rem; text-align: left;">Description</th>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Age & BMI Correlations</strong></td>
                    <td style="padding: 0.5rem;">Spearman correlations between cytokine activities and continuous clinical variables</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Biochemistry Correlations</strong></td>
                    <td style="padding: 0.5rem;">Heatmap of cytokine-biochemistry correlations with hierarchical clustering</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Treatment Response</strong></td>
                    <td style="padding: 0.5rem;">ROC curves from cross-validated response prediction models</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Disease Differential</strong></td>
                    <td style="padding: 0.5rem;">Volcano plots showing disease-specific activity changes (Œî activity vs. -log10 p-value)</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Conserved Signatures</strong></td>
                    <td style="padding: 0.5rem;">Cross-atlas conservation with dual views: cell-type aware (pattern correlation) and cell-type agnostic (mean activity comparison)</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Atlas Comparison</strong></td>
                    <td style="padding: 0.5rem;">Scatter plots comparing mean activities between atlases with Spearman correlation</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Forest Plot</strong></td>
                    <td style="padding: 0.5rem;">Meta-analysis effect sizes with 95% confidence intervals and I¬≤ heterogeneity</td>
                </tr>
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 0.5rem;"><strong>Correlation Matrix</strong></td>
                    <td style="padding: 0.5rem;">Signature-signature correlation heatmap with identified modules</td>
                </tr>
            </table>

            <h3>References</h3>
            <ul>
                <li>Ru B, Gong L, Yang E, Park S, Zaki G, Aldape K, Wakefield L, Jiang P. (2026) <em>Nature Methods</em> (in press) - Inference of secreted protein activities in intercellular communication</li>
                <li>Jiang P, et al. (2021) <em>Nature Methods</em> - Systematic investigation of cytokine signaling activity at the tissue and single-cell levels</li>
                <li>Hao Y, et al. (2021) <em>Cell</em> - Integrated analysis of multimodal single-cell data</li>
                <li>Higgins JPT, et al. (2003) <em>BMJ</em> - Measuring inconsistency in meta-analyses</li>
                <li>Dom√≠nguez Conde C, et al. (2022) <em>Science</em> - Cross-tissue immune cell analysis reveals tissue-specific features in humans</li>
            </ul>
        </div>
    </section>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>Pan-Disease Cytokine Activity Atlas | Generated with SecActPy</p>
        </div>
    </footer>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <!-- Embedded data for instant loading -->
    <script src="data/embedded_data.js"></script>

    <script>
        // Embedded summary stats (for immediate display without server)
        const EMBEDDED_STATS = {
            "cima": {
                "n_samples": 421,
                "n_cell_types": 27,
                "n_celltype_records": 32751,
                "n_cytokines_cytosig": 43,
                "n_proteins_secact": 1170,
                "n_age_correlations": 1213,
                "n_bmi_correlations": 1213,
                "n_biochem_correlations": 21859,
                "n_metabolite_correlations": 606500,
                "n_differential": 12130,
                "n_eqtl_records": 71530,
                "n_eqtl_cell_types": 69,
                "n_eqtl_genes": 9600,
                "significant_age": 693,
                "significant_bmi": 580
            },
            "scatlas": {
                "n_organs": 35,
                "n_cell_types": 376,
                "n_cell_types_normal": 376,
                "n_cell_types_cancer": 119,
                "n_cancer_types": 29,
                "n_donors_normal": 317,
                "n_donors_cancer": 464,
                "n_cells_normal": 2293951,
                "n_cells_cancer": 4146975,
                "n_cohorts_normal": 26,
                "n_cohorts_cancer": 45,
                "n_organ_signatures": 42455,
                "n_celltype_signatures": 240174,
                "n_cancer_type_signatures": 15769,
                "n_tumor_adjacent": 1213,
                "n_immune_infiltration": 31538,
                "n_tcell_state": 15158,
                "n_exhaustion_comparison": 3432,
                "n_exhaustion_signatures": 43,
                "n_caf_signatures": 7654,
                "organs": ["Bladder","Blood","BoneMarrow","Breast","Colon","CommonBileDuct","Esophagus","Eye","Fat","Heart","Kidney","Liver","Lung","LymphNode","Nose","Omentum","Oral","Ovary","Pancreas","Prostate","Rectum","SalivaryGland","SkeletalMuscle","Skin","SmallIntestine","Spleen","Stomach","Testis","Thymus","Tongue","Trachea","Ureter","Uterus","Vagina","Vasculature"],
                "cytosig_signatures": ["Activin A","BDNF","BMP2","BMP4","BMP6","CD40L","CXCL12","EGF","FGF2","GCSF","GDF11","GMCSF","HGF","IFN1","IFNG","IFNL","IL10","IL12","IL13","IL15","IL17A","IL1A","IL1B","IL2","IL21","IL22","IL27","IL3","IL36","IL4","IL6","LIF","LTA","MCSF","NO","OSM","TGFB1","TGFB3","TNFA","TRAIL","TWEAK","VEGFA","WNT3A"]
            },
            "inflammation": {
                "n_samples": 817,
                "n_cell_types": 66,
                "n_celltype_records": 36390,
                "n_cells": 4918140,
                "n_diseases": 20,
                "n_disease_records": 1527167,
                "n_differential": 23047,
                "n_severity": 47307,
                "n_cell_drivers": 44695
            }
        };

        // Global state - use embedded data for instant loading
        const state = {
            data: {
                summarystats: EMBEDDED_STATS,
                // Load from embedded data if available
                cimacorrelations: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimacorrelations : null,
                cimadifferential: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimadifferential : null,
                cimacelltype: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimacelltype : null,
                cimacelltypecorrelations: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimacelltypecorrelations : null,
                cimametabolitestop: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimametabolitestop : null,
                cimabiochemscatter: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimabiochemscatter : null,
                cimapopulationstratification: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimapopulationstratification : null,
                cimaeqtl: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cimaeqtl : null,  // Full 71,530 eQTLs embedded
                scatlasorgans: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.scatlasorgans : null,
                scatlasorganstop: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.scatlasorganstop : null,
                scatlascelltypes: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.scatlascelltypes : null,
                cancercomparison: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cancercomparison : null,
                // New scAtlas data
                cancertypes: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cancertypes : null,
                immuneinfiltration: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.immuneinfiltration : null,
                exhaustion: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.exhaustion : null,
                cafsignatures: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cafsignatures : null,
                organcancermatrix: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.organcancermatrix : null,
                adjacenttissue: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.adjacenttissue : null,
                // Inflammation data
                inflammationcelltype: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.inflammationcelltype : null,
                inflammationcorrelations: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.inflammationcorrelations : null,
                inflammationcelltypecorrelations: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.inflammationcelltypecorrelations : null,
                inflammationdisease: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.inflammationdisease : null,
                inflammationdifferential: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.inflammationdifferential : null,
                inflammationcelldrivers: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.inflammationcelldrivers : null,
                inflammationseverity: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.inflammationseverity : null,
                diseasesankey: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.diseasesankey : null,
                agebmiboxplots: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.agebmiboxplots : null,
                treatmentresponse: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.treatmentresponse : null,
                cohortvalidation: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.cohortvalidation : null,
                crossatlas: (typeof EMBEDDED_DATA !== 'undefined') ? EMBEDDED_DATA.crossatlas : null
            },
            selectedOrgan: null,
            currentSignature: 'IFNG',
            // Track loaded signature types for boxplot data
            boxplotLoaded: { cytosig: false, secact: false },
            secactBoxplotData: null,  // Lazy loaded SecAct data
            fullBoxplotData: null     // Lazy loaded full boxplot data (fallback when embedded not available)
        };

        // Lazy load full boxplot data (CytoSig) when embedded data not available
        let boxplotDataLoading = false;
        async function loadBoxplotDataIfNeeded() {
            if (state.data.agebmiboxplots || state.fullBoxplotData || boxplotDataLoading) return;
            boxplotDataLoading = true;
            console.log('Loading boxplot data from JSON...');
            try {
                const response = await fetch('data/age_bmi_boxplots.json');
                if (response.ok) {
                    state.fullBoxplotData = await response.json();
                    state.data.agebmiboxplots = state.fullBoxplotData;
                    state.boxplotLoaded.cytosig = true;
                    console.log('Boxplot data loaded from JSON');
                }
            } catch (e) {
                console.warn('Could not load boxplot data:', e);
            }
            boxplotDataLoading = false;
        }

        // Lazy load SecAct boxplot data when needed
        async function loadSecActBoxplotData() {
            if (state.secactBoxplotData) return state.secactBoxplotData;
            if (state.boxplotLoaded.secact) return state.secactBoxplotData;

            console.log('Loading SecAct boxplot data...');
            try {
                const response = await fetch('data/age_bmi_boxplots_secact.json');
                if (response.ok) {
                    state.secactBoxplotData = await response.json();
                    state.boxplotLoaded.secact = true;
                    console.log('SecAct boxplot data loaded');
                    // Update signature lists for autocomplete
                    if (typeof updateSecActSignatures === 'function') {
                        updateSecActSignatures();
                    }
                    return state.secactBoxplotData;
                }
            } catch (e) {
                console.warn('Could not load SecAct boxplot data:', e);
            }
            return null;
        }

        // Get boxplot data for a specific signature type (handles lazy loading)
        async function getBoxplotData(atlas, sigType) {
            // Lazy load boxplot data if not embedded
            await loadBoxplotDataIfNeeded();

            // For CytoSig, use embedded data (or lazy loaded data)
            if (sigType === 'CytoSig') {
                return state.data.agebmiboxplots?.[atlas];
            }
            // For SecAct, lazy load if needed
            if (sigType === 'SecAct') {
                const secactData = await loadSecActBoxplotData();
                return secactData?.[atlas];
            }
            // For 'both', combine CytoSig (embedded) and SecAct (lazy loaded)
            const cytosigData = state.data.agebmiboxplots?.[atlas];
            const secactData = await loadSecActBoxplotData();
            if (!cytosigData && !secactData) return null;

            // Merge data from both sources
            return {
                age: [...(cytosigData?.age || []), ...(secactData?.[atlas]?.age || [])],
                bmi: [...(cytosigData?.bmi || []), ...(secactData?.[atlas]?.bmi || [])],
                signatures: [...(cytosigData?.signatures || []), ...(secactData?.[atlas]?.signatures || [])],
                cell_types: cytosigData?.cell_types || secactData?.[atlas]?.cell_types || [],
                age_bins: cytosigData?.age_bins || secactData?.[atlas]?.age_bins || [],
                bmi_bins: cytosigData?.bmi_bins || secactData?.[atlas]?.bmi_bins || []
            };
        }

        // Initialize section (no loading needed with embedded data)
        async function initSection(section) {
            if (section === 'cima') {
                updateCorrelationPlots();
                updateCelltypeCorrelationHeatmap();
                initBiochemProteins();
                populateProteinDropdown('biochem-protein-dropdown', 'biochem-signature-type');
                updateBiochemHeatmap();
                updateVolcanoPlot();
                updateCimaCelltypeViz();
                populateProteinDropdown('cima-ct-protein-dropdown', 'cima-ct-sig-type');
                updateStratifiedBoxplot(); updateCelltypeStratifiedHeatmap();
                populateProteinDropdown('boxplot-signature-dropdown', 'boxplot-sig-type');
                updateMetabolitesViz();
                // New CIMA panels
                updateBiochemScatter();
                populateProteinDropdown('biochem-scatter-protein-dropdown', 'biochem-scatter-sig-type');
                updateMultiomicsViz();
                await updatePopulationStratification();
                await updateEqtlBrowser();
            } else if (section === 'inflammation') {
                updateInflammationViz();
                populateProteinDropdown('inflam-signature-dropdown', 'inflam-sig-type');
                updateInflamCorrelations();
                updateInflamCelltypeCorrelationHeatmap();
                await initInflamBoxplotSignatures();
                populateProteinDropdown('inflam-boxplot-dropdown', 'inflam-boxplot-sig-type');
                await updateInflamStratifiedBoxplot();
                await updateInflamCelltypeStratifiedHeatmap();
                updateInflamDisease();
                populateProteinDropdown('inflam-disease-dropdown', 'inflam-disease-sig-type');
                initInflamDifferentialDiseases();
                updateInflamDifferential();
                updateTreatmentResponse();
                updateDiseaseSankey();
                updateCohortValidation();
                // New Inflammation panels
                initSeverityPanel();
                populateProteinDropdown('severity-dropdown', 'severity-sig-type');
                updateSeverityCorrelation();
                updateCellDrivers();
            } else if (section === 'scatlas') {
                // Cell Types tab (first)
                populateScatlasCelltypeDropdown();
                updateScatlasCelltypeBar();
                updateCelltypeHeatmap();
                // Tissue Atlas tab (combined normal + cancer)
                updateTissueAtlas();
                // Differential Analysis tab (consolidated tumor/adjacent/normal)
                updateDiffSignatureList();
                updateDifferentialAnalysis();
                updateImmuneInfiltration();
                updateTcellFunction();
                updateExhaustion();
                // New scAtlas panels
                updateCafClassification();
            } else if (section === 'cross-atlas') {
                updateAtlasOverview();
                updateConservedSignatures();
                updateAtlasComparison();
                updateCelltypeMapping();
                updateMetaAnalysis();
                // New Cross-Atlas panels
                updateSignatureCorrelation();
                updatePathwayEnrichment();
            }
        }

        function loadData() {
            console.log('Initializing visualization...');

            // Check if embedded data loaded successfully
            if (typeof EMBEDDED_DATA === 'undefined') {
                console.error('EMBEDDED_DATA not loaded. Make sure to serve this file via HTTP server.');
                showDataLoadError();
                return;
            }

            console.log('EMBEDDED_DATA loaded successfully:', {
                correlations: !!state.data.cimacorrelations,
                differential: !!state.data.cimadifferential,
                cimaCelltype: !!state.data.cimacelltype,
                organs: !!state.data.scatlasorgans,
                celltypes: !!state.data.scatlascelltypes,
                inflammation: !!state.data.inflammationcelltype
            });

            // All data is already loaded - just initialize UI
            updateStats();
            populateSignatureDropdowns();
            setupEventListeners();

            // Initialize all sections immediately (no lazy loading needed with embedded data)
            console.log('Initializing all sections...');
            initSection('cima');
            initSection('inflammation');
            initSection('scatlas');
            initSection('cross-atlas');
            console.log('All sections initialized');
        }

        function showDataLoadError() {
            const errorMsg = `
                <div style="text-align: center; padding: 2rem; color: #721c24; background: #f8d7da; border-radius: 8px; margin: 1rem;">
                    <h3 style="margin-bottom: 1rem;">Data Loading Error</h3>
                    <p>The visualization data could not be loaded.</p>
                    <p style="margin-top: 1rem; font-size: 0.9rem;">
                        <strong>To fix:</strong> Serve this directory via HTTP server instead of opening the file directly.<br>
                        Run one of these commands in the visualization directory:
                    </p>
                    <code style="display: block; margin: 1rem auto; padding: 0.5rem; background: #fff; max-width: 400px;">
                        python -m http.server 8000<br>
                        # Then open http://localhost:8000
                    </code>
                </div>
            `;
            // Show error in all loading containers
            document.querySelectorAll('.loading').forEach(el => {
                el.classList.remove('loading');
                el.innerHTML = errorMsg;
            });
        }

        // Update overview stats
        function updateStats() {
            const stats = state.data.summarystats;
            if (!stats) return;

            // CIMA stats
            document.getElementById('stat-cima-samples').textContent = stats.cima.n_samples.toLocaleString();

            // Inflammation Atlas stats
            document.getElementById('stat-inflam-samples').textContent = stats.inflammation?.n_samples?.toLocaleString() || '-';
            document.getElementById('stat-inflam-cells').textContent = stats.inflammation?.n_cells ? (stats.inflammation.n_cells / 1e6).toFixed(1) + 'M' : '-';
            document.getElementById('stat-inflam-celltypes').textContent = stats.inflammation?.n_cell_types || '-';

            // scAtlas stats
            document.getElementById('stat-scatlas-donors').textContent =
                `${stats.scatlas.n_donors_normal} / ${stats.scatlas.n_donors_cancer}`;
            document.getElementById('stat-scatlas-cells').textContent =
                `${(stats.scatlas.n_cells_normal / 1e6).toFixed(1)}M / ${(stats.scatlas.n_cells_cancer / 1e6).toFixed(1)}M`;
            document.getElementById('stat-scatlas-organs').textContent = stats.scatlas.n_organs;
            document.getElementById('stat-scatlas-celltypes').textContent =
                `${stats.scatlas.n_cell_types_normal} / ${stats.scatlas.n_cell_types_cancer}`;
            document.getElementById('stat-scatlas-cohorts').textContent =
                `${stats.scatlas.n_cohorts_normal} / ${stats.scatlas.n_cohorts_cancer}`;

            // CIMA data sources table - matches 10 analysis tabs (Age & BMI split = 11 items)
            const cimaData = [
                ['Age Correlations', '1,213 proteins √ó Age', stats.cima.n_age_correlations.toLocaleString()],
                ['BMI Correlations', '1,213 proteins √ó BMI', stats.cima.n_bmi_correlations.toLocaleString()],
                ['Age/BMI Stratified', '1,213 proteins √ó 28 cell types √ó 9 bins', '21,366'],
                ['Biochemistry', '1,190 proteins √ó 19 biomarkers', stats.cima.n_biochem_correlations.toLocaleString()],
                ['Biochem Scatter', '396 samples √ó 19 biomarkers √ó (43 CytoSig + 1,170 SecAct)', (396 * (43 + 1170)).toLocaleString()],
                ['Metabolites', '1,213 proteins √ó 500 metabolites (top)', stats.cima.n_metabolite_correlations.toLocaleString()],
                ['Differential', '1,213 proteins √ó 10 categories', stats.cima.n_differential.toLocaleString()],
                ['Cell Types', '27 cell types √ó (43 CytoSig + 1,170 SecAct)', '32,751'],
                ['Cell Type Correlations', '27 cell types √ó (43 CytoSig + 100 SecAct) √ó 2 (age, BMI)', '7,722'],
                ['Multi-omics', 'Cytokine-Biochemistry (21,859) + Cytokine-Metabolite (500)', '22,359'],
                ['Population', '421 donors √ó demographic subgroups (sex, age, BMI, blood type, smoking)', '6,065'],
                ['eQTL Browser', '71,530 significant cis-eQTLs across 69 cell types (9,600 genes)', '71,530']
            ];
            document.getElementById('data-sources-cima').innerHTML = cimaData.map(row =>
                `<tr><td>${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td></tr>`
            ).join('');

            // Inflammation Atlas data sources table (10 analyses)
            const inflamData = [
                ['Cell Types', '66 cell types √ó (43 CytoSig + 504 SecAct proteins)', '36,390'],
                ['Age/BMI Correlations', 'Sample-level (1,213) + cell type-level (9,438 each)', '20,089'],
                ['Age/BMI Stratified', 'Activity boxplots by age decade and BMI category', '164,255'],
                ['Disease', '20 diseases √ó 66 cell types √ó (43 CytoSig + 186 SecAct)', '310,973'],
                ['Differential', 'Disease vs healthy differential (study-matched controls)', '4,693'],
                ['Severity', 'Disease severity correlation with cytokine activity', '9,633'],
                ['Treatment Response', 'ROC curves (28) + feature importance (560) + predictions', '1,780'],
                ['Validation', 'Cross-cohort correlation (main vs validation vs external)', '1,219'],
                ['Disease Flow', 'Sankey: 20 diseases ‚Üí 6 disease groups ‚Üí 3 cohorts', '116'],
                ['Cell Drivers', '15 diseases √ó 66 cell types √ó 143 signatures (study-matched)', '44,695']
            ];
            document.getElementById('data-sources-inflammation').innerHTML = inflamData.map(row =>
                `<tr><td>${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td></tr>`
            ).join('');

            // scAtlas data sources table - matches 7 analysis tabs
            const scatlasData = [
                ['Cell Types', '376 cell types √ó (43 CytoSig + 1,170 SecAct) across 35 organs', stats.scatlas.n_celltype_signatures.toLocaleString()],
                ['Tissue Atlas', `35 organs (${stats.scatlas.n_organ_signatures.toLocaleString()}) + 13 cancer types (${stats.scatlas.n_cancer_type_signatures.toLocaleString()})`, (stats.scatlas.n_organ_signatures + stats.scatlas.n_cancer_type_signatures).toLocaleString()],
                ['Differential', 'Tumor vs Adjacent vs Normal tissue √ó (43 CytoSig + 1,170 SecAct)', stats.scatlas.n_tumor_adjacent.toLocaleString()],
                ['Immune Infiltration', '13 cancer types √ó TME composition √ó (43 CytoSig + 1,170 SecAct)', stats.scatlas.n_immune_infiltration.toLocaleString()],
                ['T Cell State', '7 cancer types √ó 5 states √ó (43 CytoSig + 1,170 SecAct)', stats.scatlas.n_tcell_state.toLocaleString()],
                ['Exhaustion Diff', 'Exhausted vs non-exhausted T cells √ó (43 CytoSig + 1,170 SecAct)', stats.scatlas.n_exhaustion_comparison.toLocaleString()],
                ['CAF Types', '5 cancer types √ó 4 CAF subtypes √ó (43 CytoSig + 1,170 SecAct)', stats.scatlas.n_caf_signatures.toLocaleString()]
            ];
            document.getElementById('data-sources-scatlas').innerHTML = scatlasData.map(row =>
                `<tr><td>${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td></tr>`
            ).join('');
        }

        // Populate signature dropdowns
        function populateSignatureDropdowns() {
            const stats = state.data.summarystats;
            if (!stats) return;

            // Initial population of organ signatures (CytoSig default)
            populateOrganSignatures();

            // Organ filter for cell types
            const organSelect = document.getElementById('ct-organ-filter');
            organSelect.innerHTML = '<option value="">All Organs</option>' +
                stats.scatlas.organs.map(o => `<option value="${o}">${o}</option>`).join('');

            // Populate eQTL cell types
            populateEqtlCellTypes();

            // Populate cell drivers dropdowns
            populateCellDriversDropdowns();
        }

        // Populate cell drivers dropdowns from real data
        function populateCellDriversDropdowns() {
            const data = state.data.inflammationcelldrivers;
            if (!data || !data.effects || data.effects.length === 0) {
                console.log('populateCellDriversDropdowns: No cell drivers data available');
                return;
            }

            const sigType = document.getElementById('drivers-sig-type')?.value || 'CytoSig';

            // Get unique diseases and signatures for the selected signature type
            const filtered = data.effects.filter(d => d.signature_type === sigType);
            const diseases = [...new Set(filtered.map(d => d.disease))].sort();
            const signatures = [...new Set(filtered.map(d => d.signature))].sort();

            // Populate disease dropdown
            const diseaseSelect = document.getElementById('drivers-disease');
            if (diseaseSelect) {
                const currentDisease = diseaseSelect.value;
                diseaseSelect.innerHTML = diseases.map(d =>
                    `<option value="${d}">${d}</option>`
                ).join('');
                // Restore selection or default
                if (diseases.includes(currentDisease)) {
                    diseaseSelect.value = currentDisease;
                } else if (diseases.includes('RA')) {
                    diseaseSelect.value = 'RA';
                } else if (diseases.length > 0) {
                    diseaseSelect.value = diseases[0];
                }
            }

            // Populate signature dropdown
            const signatureSelect = document.getElementById('drivers-cytokine');
            const searchInput = document.getElementById('drivers-search');
            if (signatureSelect) {
                const currentSig = signatureSelect.value;
                signatureSelect.innerHTML = signatures.map(s =>
                    `<option value="${s}">${s}</option>`
                ).join('');
                // Restore selection or default
                if (signatures.includes(currentSig)) {
                    signatureSelect.value = currentSig;
                } else if (signatures.includes('IFNG')) {
                    signatureSelect.value = 'IFNG';
                } else if (signatures.length > 0) {
                    signatureSelect.value = signatures[0];
                }
                // Sync search input with dropdown
                if (searchInput) {
                    searchInput.value = signatureSelect.value;
                }
            }

            console.log(`populateCellDriversDropdowns: ${diseases.length} diseases, ${signatures.length} signatures for ${sigType}`);
        }

        // Populate organ signatures based on selected signature type
        function populateOrganSignatures() {
            const organData = state.data.scatlasorgans;
            if (!organData) {
                console.log('populateOrganSignatures: No organ data available');
                return;
            }

            const sigType = document.getElementById('organ-sig-type')?.value || 'CytoSig';
            console.log('populateOrganSignatures: sigType =', sigType, ', total records =', organData.length);

            let signatures;
            if (sigType === 'both') {
                // For 'both' mode: only signatures present in BOTH CytoSig AND SecAct
                const cytosigSigs = new Set(organData.filter(d => d.signature_type === 'CytoSig').map(d => d.signature));
                const secactSigs = new Set(organData.filter(d => d.signature_type === 'SecAct').map(d => d.signature));
                signatures = [...cytosigSigs].filter(s => secactSigs.has(s)).sort();
                console.log('populateOrganSignatures: signatures in BOTH CytoSig AND SecAct =', signatures.length);
            } else {
                // Single type: all signatures of that type
                const filtered = organData.filter(d => d.signature_type === sigType);
                signatures = [...new Set(filtered.map(d => d.signature))].sort();
            }
            console.log('populateOrganSignatures: unique signatures =', signatures.length);

            // Store valid signatures for validation
            state.organSignatures = signatures;

            const input = document.getElementById('organ-signature');
            const datalist = document.getElementById('organ-signature-list-data');
            if (datalist && signatures.length > 0) {
                datalist.innerHTML = signatures.map(s => `<option value="${s}">`).join('');

                // Set default value: IFNG if available, otherwise first signature
                const defaultSig = signatures.includes('IFNG') ? 'IFNG' : signatures[0];
                if (input) {
                    input.value = defaultSig;
                    input.placeholder = `Search ${signatures.length} shared signatures...`;
                }
            } else if (datalist) {
                console.log('populateOrganSignatures: No signatures found for', sigType);
                datalist.innerHTML = '';
                if (input) {
                    input.value = '';
                    input.placeholder = 'No shared signatures available';
                }
            }
        }

        // Create lollipop chart
        function createLollipopChart(containerId, data, title) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            container.classList.remove('loading');

            if (!data || data.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">No significant results</p>';
                return;
            }

            // Sort by correlation value
            data.sort((a, b) => b.rho - a.rho);

            const margin = {top: 20, right: 30, bottom: 40, left: 100};
            const width = container.clientWidth - margin.left - margin.right;
            const height = Math.max(300, data.length * 20);

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain([Math.min(-0.5, d3.min(data, d => d.rho)), Math.max(0.5, d3.max(data, d => d.rho))])
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(data.map(d => d.protein))
                .range([0, height])
                .padding(0.3);

            // Zero line
            svg.append('line')
                .attr('x1', x(0))
                .attr('x2', x(0))
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', '#ccc')
                .attr('stroke-dasharray', '3,3');

            // Lines
            svg.selectAll('.lollipop-line')
                .data(data)
                .enter()
                .append('line')
                .attr('class', 'lollipop-line')
                .attr('x1', x(0))
                .attr('x2', d => x(d.rho))
                .attr('y1', d => y(d.protein) + y.bandwidth() / 2)
                .attr('y2', d => y(d.protein) + y.bandwidth() / 2)
                .attr('stroke', d => d.rho > 0 ? '#f4a6a6' : '#a8d4e6')
                .attr('stroke-width', 2);

            // Circles
            svg.selectAll('.lollipop-circle')
                .data(data)
                .enter()
                .append('circle')
                .attr('class', 'lollipop-circle')
                .attr('cx', d => x(d.rho))
                .attr('cy', d => y(d.protein) + y.bandwidth() / 2)
                .attr('r', 6)
                .attr('fill', d => d.rho > 0 ? '#f4a6a6' : '#a8d4e6')
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    showTooltip(event, `
                        <div class="tooltip-title">${d.protein}</div>
                        <div>œÅ = <span class="tooltip-value">${d.rho.toFixed(3)}</span></div>
                        <div>q-value = ${d.qvalue.toExponential(2)}</div>
                        <div>n = ${d.n}</div>
                    `);
                })
                .on('mouseout', hideTooltip);

            // Y axis
            svg.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .style('font-size', '11px');

            // X axis
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(5));

            // X axis label
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + 35)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .text('Spearman œÅ');
        }

        // Update correlation plots - sorted from high to low correlation
        function updateCorrelationPlots() {
            const correlations = state.data.cimacorrelations;
            if (!correlations) return;

            const sigType = document.getElementById('corr-signature-type')?.value || 'CytoSig';

            // Get top 10 AND bottom 10 correlations (sorted high to low), always include IFNG and TNFA
            function getTopBottomCorrelations(data, sigType) {
                const filtered = data.filter(d => d.signature === sigType);
                // Sort by rho descending (high to low)
                const sorted = [...filtered].sort((a, b) => b.rho - a.rho);
                // Get top 10 (highest) and bottom 10 (lowest)
                const top10 = sorted.slice(0, 10);
                const bottom10 = sorted.slice(-10);
                // Combine: top 10 first, then bottom 10 (all sorted high to low)
                let result = [...top10, ...bottom10];
                // Always include IFNG and TNFA if not already in the list
                const alwaysInclude = ['IFNG', 'TNFA'];
                for (const protein of alwaysInclude) {
                    const hasProtein = result.some(d => d.protein === protein);
                    if (!hasProtein) {
                        const found = filtered.find(d => d.protein === protein);
                        if (found) {
                            result.push(found);
                        }
                    }
                }
                // Re-sort after adding
                result.sort((a, b) => b.rho - a.rho);
                return result;
            }

            // Get SecAct values for specific protein IDs (selected by CytoSig)
            function getSecActForProteins(data, proteinIds) {
                const secActData = data.filter(d => d.signature === 'SecAct');
                // Find SecAct values for the same proteins, maintain order
                // Use 0 for missing values to show all 20 IDs
                return proteinIds.map(id => {
                    const match = secActData.find(d => d.protein === id);
                    return match || {protein: id, rho: 0, signature: 'SecAct'};
                });
            }

            if (sigType === 'both') {
                // CytoSig top 10 + bottom 10 selections
                const ageCytoSig = getTopBottomCorrelations(correlations.age, 'CytoSig');
                // Get SecAct values for the same proteins selected by CytoSig
                const ageCytoSigIds = ageCytoSig.map(d => d.protein);
                const ageSecAct = getSecActForProteins(correlations.age, ageCytoSigIds);
                createDualLollipopChart('age-lollipop', ageCytoSig, ageSecAct, 'Age');

                const bmiCytoSig = getTopBottomCorrelations(correlations.bmi, 'CytoSig');
                const bmiCytoSigIds = bmiCytoSig.map(d => d.protein);
                const bmiSecAct = getSecActForProteins(correlations.bmi, bmiCytoSigIds);
                createDualLollipopChart('bmi-lollipop', bmiCytoSig, bmiSecAct, 'BMI');
            } else {
                // Show only selected signature type (top 10 + bottom 10)
                const ageData = getTopBottomCorrelations(correlations.age, sigType);
                createDualLollipopChart('age-lollipop', ageData, [], 'Age');

                const bmiData = getTopBottomCorrelations(correlations.bmi, sigType);
                createDualLollipopChart('bmi-lollipop', bmiData, [], 'BMI');
            }
        }

        // Consistent pastel colors: red (#f4a6a6) = high/positive, blue (#a8d4e6) = low/negative
        const COLOR_HIGH = '#f4a6a6';  // pastel red
        const COLOR_LOW = '#a8d4e6';   // pastel blue

        // Create dual lollipop chart showing CytoSig at top and SecAct at bottom
        function createDualLollipopChart(containerId, cytoSigData, secActData, title) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            container.classList.remove('loading');

            // For Plotly, y-axis is drawn bottom to top
            // We want: CytoSig at TOP, SecAct at BOTTOM
            // So in array order: SecAct first (reversed), then CytoSig (reversed)

            const hasBoth = secActData && secActData.length > 0;

            // Combine data: SecAct at bottom, CytoSig at top
            let combinedY = [];
            let combinedX = [];
            let combinedColors = [];
            let combinedText = [];

            if (hasBoth) {
                // SecAct section (bottom) - reversed so high values are at top of SecAct section
                const secActReversed = [...secActData].reverse();
                for (const d of secActReversed) {
                    combinedY.push(d.protein + ' (SecAct)');
                    combinedX.push(d.rho);
                    combinedColors.push(d.rho > 0 ? COLOR_HIGH : COLOR_LOW);
                    combinedText.push(d.rho?.toFixed(3) || 'N/A');
                }

                // Add separator
                combinedY.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                combinedX.push(0);
                combinedColors.push('#ffffff');
                combinedText.push('');

                // CytoSig section (top) - reversed so high values are at top
                const cytoSigReversed = [...cytoSigData].reverse();
                for (const d of cytoSigReversed) {
                    combinedY.push(d.protein + ' (CytoSig)');
                    combinedX.push(d.rho);
                    combinedColors.push(d.rho > 0 ? COLOR_HIGH : COLOR_LOW);
                    combinedText.push(d.rho?.toFixed(3));
                }
            } else {
                // Single signature type - no label needed
                const cytoSigReversed = cytoSigData ? [...cytoSigData].reverse() : [];
                for (const d of cytoSigReversed) {
                    combinedY.push(d.protein);
                    combinedX.push(d.rho);
                    combinedColors.push(d.rho > 0 ? COLOR_HIGH : COLOR_LOW);
                    combinedText.push(d.rho?.toFixed(3));
                }
            }

            // Determine text position based on bar size - place outside if bar is small
            const textPositions = combinedX.map(x => Math.abs(x) < 0.1 ? 'outside' : 'inside');

            const trace = {
                y: combinedY,
                x: combinedX,
                type: 'bar',
                orientation: 'h',
                marker: { color: combinedColors },
                text: combinedText,
                textposition: textPositions,
                textfont: { size: 9, color: '#333' },
                cliponaxis: false,  // Allow text to extend outside plot area
                hovertemplate: '<b>%{y}</b><br>œÅ = %{x:.3f}<extra></extra>'
            };

            // Calculate height based on number of entries
            const totalEntries = combinedY.length;
            const chartHeight = Math.max(500, totalEntries * 20 + 80);

            // Calculate axis range to accommodate outside text
            const maxAbs = Math.max(...combinedX.map(Math.abs));
            const range = [-maxAbs - 0.15, maxAbs + 0.15];

            Plotly.newPlot(container, [trace], {
                margin: {l: 160, r: 50, t: 30, b: 50},
                xaxis: {title: 'Spearman œÅ', zeroline: true, zerolinecolor: '#ccc', range: range},
                yaxis: {automargin: true},
                height: chartHeight,
                showlegend: false
            }, {responsive: true});
        }

        // Update cell type-specific correlation heatmap
        function updateCelltypeCorrelationHeatmap() {
            const container = document.getElementById('cima-celltype-corr-heatmap');
            if (!container) return;
            container.classList.remove('loading');

            const sigType = document.getElementById('cima-ct-corr-sigtype')?.value || 'CytoSig';
            const feature = document.getElementById('cima-ct-corr-feature')?.value || 'age';
            const metric = document.getElementById('cima-ct-corr-metric')?.value || 'rho';

            // Get data - structure is {age: [...], bmi: [...]} with signature field in records
            const corrData = state.data.cimacelltypecorrelations;
            if (!corrData || !corrData[feature]) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Cell type correlation data not available. Run preprocessing to generate.</p>';
                return;
            }

            // Filter by signature type
            const allData = corrData[feature];
            const dataArray = allData.filter(d => d.signature === sigType);

            if (!dataArray || dataArray.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available for this signature type.</p>';
                return;
            }

            // Extract unique cell types and proteins from filtered data
            const cellTypes = [...new Set(dataArray.map(d => d.cell_type))].sort();
            const proteins = [...new Set(dataArray.map(d => d.protein))].sort();
            const nSig = dataArray.filter(d => d.qvalue < 0.05).length;

            // Update title
            const titleEl = document.getElementById('cima-ct-corr-title');
            const subtitle = sigType === 'SecAct' ? ` (${proteins.length} proteins)` : ` (${proteins.length} cytokines)`;
            if (titleEl) titleEl.textContent = `${feature === 'age' ? 'Age' : 'BMI'} Correlation by Cell Type - ${sigType}${subtitle} - ${nSig} significant`;

            // Filter significant only if selected
            let filteredData = dataArray;
            if (metric === 'sig') {
                filteredData = dataArray.filter(d => d.qvalue < 0.05);
            }

            // Create lookup map for fast access
            const dataMap = {};
            dataArray.forEach(d => {
                const key = `${d.cell_type}|${d.protein}`;
                dataMap[key] = d;
            });

            // Create matrix for heatmap
            const zValues = [];
            const hoverText = [];

            for (const ct of cellTypes) {
                const row = [];
                const hoverRow = [];
                for (const protein of proteins) {
                    const key = `${ct}|${protein}`;
                    const record = dataMap[key];
                    if (record) {
                        if (metric === 'sig' && record.qvalue >= 0.05) {
                            row.push(null);
                            hoverRow.push(`${ct}<br>${protein}<br>Not significant (q=${record.qvalue.toFixed(4)})`);
                        } else {
                            row.push(record.rho);
                            const sig = record.qvalue < 0.05 ? ' *' : '';
                            hoverRow.push(`<b>${ct}</b><br>${protein}<br>œÅ = ${record.rho.toFixed(3)}${sig}<br>q = ${record.qvalue?.toFixed(4) || 'N/A'}<br>n = ${record.n}`);
                        }
                    } else {
                        row.push(null);
                        hoverRow.push(`${ct}<br>${protein}<br>No data`);
                    }
                }
                zValues.push(row);
                hoverText.push(hoverRow);
            }

            // Adjust font size based on number of proteins
            const xTickSize = proteins.length > 50 ? 7 : 10;
            const height = sigType === 'SecAct' ? 700 : 600;

            const trace = {
                z: zValues,
                x: proteins,
                y: cellTypes,
                type: 'heatmap',
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                
                zmid: 0,
                zmin: -0.6,
                zmax: 0.6,
                hoverinfo: 'text',
                text: hoverText,
                colorbar: {
                    title: 'Spearman œÅ',
                    titleside: 'right'
                }
            };

            Plotly.newPlot(container, [trace], {
                xaxis: { title: sigType === 'CytoSig' ? 'Cytokine' : 'Secreted Protein', tickangle: 45, tickfont: { size: xTickSize } },
                yaxis: { title: 'Cell Type', tickfont: { size: 10 } },
                margin: { t: 30, b: 150, l: 150, r: 80 },
                height: height
            }, { responsive: true });
        }

        // Store biochemistry proteins for autocomplete
        let biochemAllProteins = { cytosig: [], secact: [] };

        function initBiochemProteins() {
            const correlations = state.data.cimacorrelations;
            if (!correlations || !correlations.biochemistry) return;

            const data = correlations.biochemistry;
            biochemAllProteins.cytosig = [...new Set(data.filter(d => d.signature === 'CytoSig').map(d => d.protein))].sort();
            biochemAllProteins.secact = [...new Set(data.filter(d => d.signature === 'SecAct').map(d => d.protein))].sort();
        }

        function getBiochemProteins() {
            const sigType = document.getElementById('biochem-signature-type')?.value || 'CytoSig';
            return sigType === 'CytoSig' ? biochemAllProteins.cytosig : biochemAllProteins.secact;
        }

        function showBiochemSuggestions(query) {
            const suggestionsDiv = document.getElementById('biochem-protein-suggestions');
            if (!suggestionsDiv) return;

            const proteins = getBiochemProteins();
            const filtered = proteins.filter(p => p.toLowerCase().includes(query.toLowerCase())).slice(0, 20);

            if (filtered.length === 0 || query.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            suggestionsDiv.innerHTML = filtered.map(p =>
                `<div class="suggestion-item" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                     onmouseover="this.style.background='#f0f0f0'"
                     onmouseout="this.style.background='white'"
                     onclick="selectBiochemProtein('${p}')">${p}</div>`
            ).join('');
            suggestionsDiv.style.display = 'block';
        }

        function selectBiochemProtein(protein) {
            const searchInput = document.getElementById('biochem-protein-search');
            const suggestionsDiv = document.getElementById('biochem-protein-suggestions');
            if (searchInput) searchInput.value = protein;
            if (suggestionsDiv) suggestionsDiv.style.display = 'none';
            updateBiochemHeatmap();
        }

        // Update biochemistry heatmap
        function updateBiochemHeatmap() {
            const container = document.getElementById('biochem-heatmap');
            const sigType = document.getElementById('biochem-signature-type').value;
            const searchQuery = document.getElementById('biochem-protein-search')?.value?.trim() || '';
            const topN = document.getElementById('biochem-top-n')?.value || '50';

            const correlations = state.data.cimacorrelations;
            if (!correlations) return;

            let data = correlations.biochemistry.filter(d => d.signature === sigType);

            // Get all unique proteins and their max correlations
            const proteinMaxCorr = {};
            data.forEach(d => {
                const absRho = Math.abs(d.rho);
                if (!proteinMaxCorr[d.protein] || absRho > proteinMaxCorr[d.protein]) {
                    proteinMaxCorr[d.protein] = absRho;
                }
            });

            let proteins;

            // If search query provided, filter proteins that match
            if (searchQuery) {
                const matchingProteins = Object.keys(proteinMaxCorr)
                    .filter(p => p.toLowerCase().includes(searchQuery.toLowerCase()));

                // Sort by correlation strength
                proteins = matchingProteins
                    .sort((a, b) => proteinMaxCorr[b] - proteinMaxCorr[a]);

                // Limit to reasonable number
                if (proteins.length > 100) {
                    proteins = proteins.slice(0, 100);
                }
            } else {
                // No search - use top N
                const limit = topN === 'all' ? Object.keys(proteinMaxCorr).length : parseInt(topN);
                proteins = Object.entries(proteinMaxCorr)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, limit)
                    .map(([protein]) => protein);
            }

            // Filter data to selected proteins
            data = data.filter(d => proteins.includes(d.protein));

            const features = [...new Set(data.map(d => d.feature))];

            const zData = proteins.map(protein =>
                features.map(feature => {
                    const match = data.find(d => d.protein === protein && d.feature === feature);
                    return match ? match.rho : 0;
                })
            );

            const hoverText = proteins.map(protein =>
                features.map(feature => {
                    const match = data.find(d => d.protein === protein && d.feature === feature);
                    return match ?
                        `${protein} vs ${feature}<br>œÅ = ${match.rho.toFixed(3)}<br>q = ${match.qvalue.toExponential(2)}` :
                        '';
                })
            );

            container.classList.remove('loading');

            // Adjust height based on number of proteins
            const height = Math.max(400, proteins.length * 15 + 150);

            Plotly.newPlot(container, [{
                z: zData,
                x: features,
                y: proteins,
                type: 'heatmap',
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                zmid: 0,
                zmin: -0.5,
                zmax: 0.5,
                hoverinfo: 'text',
                text: hoverText,
                colorbar: {
                    title: 'Spearman œÅ',
                    titleside: 'right'
                }
            }], {
                margin: {l: 100, r: 50, t: 30, b: 80},
                xaxis: {tickangle: 45},
                height: height
            }, {responsive: true});
        }

        // Update volcano plot
        function updateVolcanoPlot() {
            const container = document.getElementById('volcano-plot');
            const comparisonValue = document.getElementById('diff-comparison').value;
            const sigType = document.getElementById('diff-signature-type').value;

            // Parse comparison value: "comparison|group1|group2"
            const [comparison, group1, group2] = comparisonValue.split('|');

            const diffData = state.data.cimadifferential;
            if (!diffData) return;

            // Filter and compute activity_diff (z-score difference) on the fly
            // This handles both pre-computed activity_diff and raw median values
            let data = diffData
                .filter(d =>
                    d.comparison === comparison &&
                    d.group1 === group1 &&
                    d.group2 === group2 &&
                    d.signature === sigType
                )
                .map(d => {
                    // Compute activity_diff from median z-scores if not present
                    // activity_diff = median_g1 - median_g2 (difference between z-scores)
                    const activityDiff = d.activity_diff !== undefined ? d.activity_diff : (d.median_g1 - d.median_g2);
                    // Compute -log10(pvalue) if not present
                    const negLog10Pval = d.neg_log10_pval !== undefined ? d.neg_log10_pval : -Math.log10(Math.max(d.pvalue, 1e-300));
                    return {
                        ...d,
                        activity_diff: activityDiff,
                        neg_log10_pval: negLog10Pval
                    };
                })
                .filter(d => !isNaN(d.activity_diff) && isFinite(d.neg_log10_pval));

            // For SecAct (many proteins), limit to top 200 by significance score
            if (sigType === 'SecAct' && data.length > 200) {
                // Sort by combined score of significance and effect size
                data = [...data].sort((a, b) => {
                    const scoreA = a.neg_log10_pval * Math.abs(a.activity_diff);
                    const scoreB = b.neg_log10_pval * Math.abs(b.activity_diff);
                    return scoreB - scoreA;
                }).slice(0, 200);
            }

            container.classList.remove('loading');

            // Handle empty data
            if (data.length === 0) {
                container.innerHTML = `<p style="text-align: center; color: #666; padding: 2rem;">No data available for ${group1} vs ${group2} (${sigType})</p>`;
                return;
            }

            // Split data into three groups for consistent volcano style
            const significantUp = data.filter(d => d.activity_diff > 0.3 && (d.qvalue || d.pvalue || 1) < 0.05);
            const significantDown = data.filter(d => d.activity_diff < -0.3 && (d.qvalue || d.pvalue || 1) < 0.05);
            const notSig = data.filter(d => Math.abs(d.activity_diff) <= 0.3 || (d.qvalue || d.pvalue || 1) >= 0.05);

            // Dynamic axis ranges
            const maxAbsFC = Math.max(3, Math.ceil(Math.max(...data.map(d => Math.abs(d.activity_diff)))));
            const maxY = Math.max(4, Math.ceil(Math.max(...data.map(d => d.neg_log10_pval))));

            // Update subtitle with counts
            const subtitleEl = container.closest('.viz-container').querySelector('.viz-subtitle');
            if (subtitleEl) {
                const nSigUp = significantUp.length;
                const nSigDown = significantDown.length;
                subtitleEl.textContent = `${nSigUp + nSigDown} significant (|Œî|>0.3, q<0.05): ${nSigUp} higher in ${group1}, ${nSigDown} higher in ${group2}`;
            }

            Plotly.newPlot(container, [
                {
                    type: 'scatter', mode: 'markers+text', name: `Higher in ${group1}`,
                    x: significantUp.map(d => d.activity_diff), y: significantUp.map(d => d.neg_log10_pval),
                    text: significantUp.map(d => d.protein), textposition: 'top center', textfont: { size: 9 },
                    marker: { color: '#d62728', size: 10 },
                    hovertemplate: '<b>%{text}</b><br>Œî Activity: %{x:.3f}<br>-log10(p): %{y:.2f}<extra></extra>'
                },
                {
                    type: 'scatter', mode: 'markers+text', name: `Higher in ${group2}`,
                    x: significantDown.map(d => d.activity_diff), y: significantDown.map(d => d.neg_log10_pval),
                    text: significantDown.map(d => d.protein), textposition: 'top center', textfont: { size: 9 },
                    marker: { color: '#2ca02c', size: 10 },
                    hovertemplate: '<b>%{text}</b><br>Œî Activity: %{x:.3f}<br>-log10(p): %{y:.2f}<extra></extra>'
                },
                {
                    type: 'scatter', mode: 'markers', name: 'Not significant',
                    x: notSig.map(d => d.activity_diff), y: notSig.map(d => d.neg_log10_pval),
                    text: notSig.map(d => d.protein), marker: { color: '#ccc', size: 6 },
                    hovertemplate: '<b>%{text}</b><br>Œî Activity: %{x:.3f}<br>-log10(p): %{y:.2f}<extra></extra>'
                }
            ], {
                xaxis: {
                    title: `Œî Activity (${group1} - ${group2})`,
                    zeroline: true,
                    range: [-maxAbsFC, maxAbsFC]
                },
                yaxis: {
                    title: '-log10(p-value)',
                    range: [0, maxY * 1.1]
                },
                shapes: [
                    { type: 'line', x0: 0.3, y0: 0, x1: 0.3, y1: maxY * 1.1, line: { dash: 'dot', color: '#999' } },
                    { type: 'line', x0: -0.3, y0: 0, x1: -0.3, y1: maxY * 1.1, line: { dash: 'dot', color: '#999' } },
                    { type: 'line', x0: -maxAbsFC, y0: -Math.log10(0.05), x1: maxAbsFC, y1: -Math.log10(0.05), line: { dash: 'dot', color: '#999' } }
                ],
                margin: { l: 60, r: 30, t: 30, b: 50 },
                legend: { orientation: 'h', y: -0.15 },
                height: 400
            }, { responsive: true });

            // Update the bar chart for top differential signatures
            updateCimaDiffBar(data, group1, group2);
        }

        // CIMA Differential Bar Chart - top signatures sorted by significance score
        function updateCimaDiffBar(data, group1, group2) {
            const container = document.getElementById('cima-diff-bar');
            if (!container) return;

            container.classList.remove('loading');
            Plotly.purge(container);

            if (!data || data.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available</p>';
                return;
            }

            // Calculate significance score and sort
            const scoredData = data.map(d => ({
                ...d,
                score: Math.abs(d.activity_diff) * d.neg_log10_pval
            }));

            // Sort by score descending and take top 20
            const sorted = [...scoredData].sort((a, b) => b.score - a.score);
            const top20 = sorted.slice(0, 20).reverse();  // Reverse for horizontal bar (top at top)

            // Color to match volcano: red for group1, green for group2
            Plotly.newPlot(container, [{
                type: 'bar',
                orientation: 'h',
                y: top20.map(d => d.protein),
                x: top20.map(d => d.activity_diff),
                marker: {
                    color: top20.map(d => d.activity_diff > 0 ? '#d62728' : '#2ca02c')
                },
                text: top20.map(d => d.activity_diff.toFixed(2)),
                textposition: 'outside',
                textfont: { size: 9 },
                hovertemplate: '<b>%{y}</b><br>Œî Activity: %{x:.3f}<br>q = %{customdata}<extra></extra>',
                customdata: top20.map(d => d.qvalue?.toExponential(2) || 'N/A')
            }], {
                xaxis: { title: `Œî Activity (${group1} - ${group2})`, zeroline: true, zerolinecolor: '#ccc' },
                yaxis: { automargin: true, tickfont: { size: 10 } },
                margin: { l: 120, r: 50, t: 30, b: 50 },
                height: 400
            }, { responsive: true });
        }

        // Update organ bar chart - single signature across organs
        function updateOrganBarChart() {
            const container = document.getElementById('organ-bar-chart');
            const signature = document.getElementById('organ-signature').value;
            const sigType = document.getElementById('organ-sig-type').value;

            const organData = state.data.scatlasorgans;
            if (!organData || !signature) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Select a signature to view its activity across organs</p>';
                return;
            }

            // For "both" mode, use CytoSig data
            const dataType = sigType === 'both' ? 'CytoSig' : sigType;

            const data = organData.filter(d =>
                d.signature === signature && d.signature_type === dataType
            );

            if (data.length === 0) {
                Plotly.purge(container);
                container.innerHTML = `<p style="text-align: center; color: #666; padding: 2rem;">No data for "${signature}" in ${dataType}</p>`;
                return;
            }

            // Sort by activity
            data.sort((a, b) => b.mean_activity - a.mean_activity);
            const organs = data.map(d => d.organ);
            const values = data.map(d => d.mean_activity);

            // Update title
            document.getElementById('organ-bar-title').textContent = `${signature} Activity Across Organs`;
            document.getElementById('organ-bar-subtitle').textContent = `${dataType} activity z-scores (${organs.length} organs)`;

            Plotly.purge(container);
            Plotly.newPlot(container, [{
                y: organs,
                x: values,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: values,
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    cmid: 0
                },
                hovertemplate: '<b>%{y}</b><br>Activity: %{x:.3f}<extra></extra>'
            }], {
                margin: {l: 100, r: 30, t: 10, b: 40},
                xaxis: {title: 'Mean Activity'},
                height: 350
            }, {responsive: true});
        }

        // Update organ heatmap - signatures √ó organs matrix
        function updateOrganHeatmap() {
            const container = document.getElementById('organ-heatmap');
            const sigType = document.getElementById('organ-sig-type').value;

            const organData = state.data.scatlasorgans;
            if (!organData) return;

            // For "both" mode, use CytoSig data (search only accepts signatures in both)
            const dataType = sigType === 'both' ? 'CytoSig' : sigType;

            // Filter data by signature type
            let filteredData = organData.filter(d => d.signature_type === dataType);

            if (filteredData.length === 0) {
                Plotly.purge(container);
                container.innerHTML = `<p style="text-align: center; color: #666; padding: 2rem;">No ${dataType} data available.</p>`;
                return;
            }

            // Get unique organs and all signatures
            const organs = [...new Set(filteredData.map(d => d.organ))].sort();
            const signatures = [...new Set(filteredData.map(d => d.signature))].sort();

            // Build heatmap matrix (signatures √ó organs)
            const zValues = [];
            const hoverText = [];

            for (const sig of signatures) {
                const row = [];
                const textRow = [];
                for (const organ of organs) {
                    const record = filteredData.find(d => d.signature === sig && d.organ === organ);
                    const val = record ? record.mean_activity : null;
                    row.push(val);
                    textRow.push(`${sig}<br>${organ}<br>Activity: ${val !== null ? val.toFixed(3) : 'N/A'}`);
                }
                zValues.push(row);
                hoverText.push(textRow);
            }

            // Update subtitle
            const subtitle = document.getElementById('organ-heatmap-subtitle');
            if (subtitle) {
                subtitle.textContent = `${signatures.length} ${dataType} signatures √ó ${organs.length} organs (click cell to select)`;
            }

            // Dynamic height based on number of signatures (min 400, max 800)
            const heatmapHeight = Math.min(800, Math.max(400, signatures.length * 15 + 150));

            Plotly.purge(container);
            Plotly.newPlot(container, [{
                z: zValues,
                x: organs,
                y: signatures,
                type: 'heatmap',
                colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                zmid: 0,
                text: hoverText,
                hovertemplate: '%{text}<extra></extra>',
                colorbar: {
                    title: 'Activity',
                    titleside: 'right'
                }
            }], {
                margin: {l: 100, r: 80, t: 20, b: 100},
                height: heatmapHeight,
                xaxis: {
                    title: 'Organ',
                    tickangle: -45
                },
                yaxis: {
                    title: 'Signature',
                    autorange: 'reversed'
                }
            }, {responsive: true});

            // Add click handler
            container.on('plotly_click', function(clickData) {
                const sig = clickData.points[0].y;
                const organ = clickData.points[0].x;
                console.log('Clicked:', sig, organ);
                // Update search box and bar chart with selected signature
                document.getElementById('organ-signature').value = sig;
                updateOrganBarChart();
            });
        }

        // Tissue Atlas - Unified Normal + Cancer view
        function getTissueSignatures() {
            const mode = document.getElementById('tissue-mode')?.value || 'normal';
            const sigType = document.getElementById('tissue-sig-type')?.value || 'CytoSig';

            if (mode === 'normal') {
                const organData = state.data.scatlasorgans;
                if (!organData) return [];
                return [...new Set(organData.filter(d => d.signature_type === sigType).map(d => d.signature))].sort();
            } else {
                const matrixData = state.data.organcancermatrix;
                if (!matrixData) return [];
                return sigType === 'CytoSig' ? (matrixData.cytosig_signatures || []) : (matrixData.secact_signatures || []);
            }
        }

        function showTissueSuggestions() {
            const input = document.getElementById('tissue-search');
            const div = document.getElementById('tissue-suggestions');
            if (!input || !div) return;

            const query = input.value.toLowerCase();
            const sigs = getTissueSignatures();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query)).slice(0, 15);

            if (filtered.length === 0) { div.style.display = 'none'; return; }

            div.innerHTML = filtered.map(s =>
                `<div style="padding:6px 10px;cursor:pointer;border-bottom:1px solid #eee"
                     onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'"
                     onclick="selectTissueSig('${s}')">${s}</div>`
            ).join('');
            div.style.display = 'block';
        }

        function selectTissueSig(sig) {
            const input = document.getElementById('tissue-search');
            const dropdown = document.getElementById('tissue-signature');
            const div = document.getElementById('tissue-suggestions');
            if (input) input.value = sig;
            if (dropdown) dropdown.value = sig;
            if (div) div.style.display = 'none';
            updateTissueAtlas();
        }

        // Sync functions for dropdown ‚Üî search box
        function syncTissueSearch() {
            const dropdown = document.getElementById('tissue-signature');
            const input = document.getElementById('tissue-search');
            if (dropdown && input) input.value = dropdown.value;
        }

        function syncTissueDropdown() {
            const input = document.getElementById('tissue-search');
            const dropdown = document.getElementById('tissue-signature');
            if (input && dropdown && input.value.trim()) {
                const sigs = getTissueSignatures();
                if (sigs.includes(input.value.trim())) {
                    dropdown.value = input.value.trim();
                }
            }
        }

        function updateTissueAtlas() {
            const boxplotContainer = document.getElementById('tissue-boxplot');
            const heatmapContainer = document.getElementById('tissue-heatmap');

            if (!boxplotContainer) return;

            const mode = document.getElementById('tissue-mode')?.value || 'normal';
            const sigType = document.getElementById('tissue-sig-type')?.value || 'CytoSig';
            const searchVal = document.getElementById('tissue-search')?.value?.trim();
            const selectedSig = searchVal || document.getElementById('tissue-signature')?.value || 'IFNG';

            // Populate signature dropdown
            const sigDropdown = document.getElementById('tissue-signature');
            const sigs = getTissueSignatures();
            if (sigDropdown && sigs.length > 0) {
                const currentVal = sigDropdown.value;
                sigDropdown.innerHTML = sigs.slice(0, 100).map(s => `<option value="${s}">${s}</option>`).join('');
                if (sigs.includes(currentVal)) sigDropdown.value = currentVal;
                else if (sigs.includes('IFNG')) sigDropdown.value = 'IFNG';
            }

            // Update description
            const descText = document.getElementById('tissue-atlas-desc-text');
            if (descText) {
                if (mode === 'normal') {
                    descText.textContent = 'Compare cytokine activity across 35 normal human organs from scAtlas.';
                } else if (mode === 'cancer-only') {
                    descText.textContent = 'Compare cytokine activity across 13 cancer types from pan-cancer scAtlas.';
                } else {
                    descText.textContent = 'Compare cytokine activity between cancer types and their matched normal organs.';
                }
            }

            if (mode === 'normal') {
                updateTissueAtlasNormal(boxplotContainer, heatmapContainer, sigType, selectedSig);
            } else if (mode === 'cancer-only') {
                updateTissueAtlasCancerOnly(boxplotContainer, heatmapContainer, sigType, selectedSig);
            } else {
                updateTissueAtlasCancer(boxplotContainer, heatmapContainer, sigType, selectedSig);
            }
        }

        function updateTissueAtlasNormal(boxplotContainer, heatmapContainer, sigType, selectedSig) {
            const organData = state.data.scatlasorgans;

            if (!organData || organData.length === 0) {
                [boxplotContainer, heatmapContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Normal organ data not available.</p>';
                    }
                });
                return;
            }

            // Filter by signature type
            const filtered = organData.filter(d => d.signature_type === sigType);
            const organs = [...new Set(filtered.map(d => d.organ))].sort();
            const signatures = [...new Set(filtered.map(d => d.signature))].sort();

            // 1. Boxplot: Single signature across organs
            boxplotContainer.classList.remove('loading');
            Plotly.purge(boxplotContainer);

            const sigData = filtered.filter(d => d.signature === selectedSig);
            if (sigData.length > 0) {
                sigData.sort((a, b) => b.mean_activity - a.mean_activity);

                Plotly.newPlot(boxplotContainer, [{
                    type: 'bar',
                    orientation: 'h',
                    y: sigData.map(d => d.organ),
                    x: sigData.map(d => d.mean_activity),
                    marker: {
                        color: sigData.map(d => d.mean_activity),
                        colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                        cmid: 0
                    },
                    hovertemplate: '<b>%{y}</b><br>Activity: %{x:.3f}<extra></extra>'
                }], {
                    xaxis: { title: `${selectedSig} Activity (z-score)`, zeroline: true },
                    yaxis: { automargin: true },
                    margin: { l: 120, r: 30, t: 20, b: 50 },
                    height: Math.max(350, sigData.length * 12)
                }, { responsive: true });

                document.getElementById('tissue-boxplot-title').textContent = `${selectedSig} Activity Across Normal Organs`;
                document.getElementById('tissue-boxplot-subtitle').textContent = `${sigType} activity across ${sigData.length} organs`;
            }

            // 2. Heatmap: Signatures √ó Organs
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                const dispSigs = sigType === 'CytoSig' ? signatures : signatures.slice(0, 50);
                const zMatrix = dispSigs.map(sig =>
                    organs.map(org => {
                        const item = filtered.find(d => d.signature === sig && d.organ === org);
                        return item ? item.mean_activity : 0;
                    })
                );

                Plotly.newPlot(heatmapContainer, [{
                    type: 'heatmap',
                    z: zMatrix,
                    x: organs,
                    y: dispSigs,
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    zmid: 0,
                    colorbar: { title: 'Activity' },
                    hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.3f}<extra></extra>'
                }], {
                    xaxis: { tickangle: 45, tickfont: { size: 9 } },
                    yaxis: { automargin: true, tickfont: { size: 9 } },
                    margin: { l: 100, r: 50, t: 20, b: 100 },
                    height: Math.min(600, Math.max(350, dispSigs.length * 12))
                }, { responsive: true });

                document.getElementById('tissue-heatmap-title').textContent = 'Normal Organ Activity Heatmap';
                document.getElementById('tissue-heatmap-subtitle').textContent = `${dispSigs.length} ${sigType} signatures √ó ${organs.length} organs`;
            }
        }

        function updateTissueAtlasCancerOnly(boxplotContainer, heatmapContainer, sigType, selectedSig) {
            const matrixData = state.data.organcancermatrix;
            const cancerTypesData = state.data.cancertypes;

            // Use organ_cancer_matrix data (has mean_cancer) or cancer_types data
            if (!matrixData?.comparisons?.length && !cancerTypesData?.data?.length) {
                [boxplotContainer, heatmapContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Cancer tissue data not available.</p>';
                    }
                });
                return;
            }

            // Get cancer data from matrix (has cancer activity values)
            const filtered = matrixData?.comparisons?.filter(d => d.signature_type === sigType) || [];
            const cancerTypes = matrixData?.cancer_types || [];
            const labels = matrixData?.cancer_labels || {};
            const signatures = sigType === 'CytoSig'
                ? (matrixData?.cytosig_signatures || [])
                : (matrixData?.secact_signatures?.slice(0, 50) || []);

            // 1. Boxplot: Cancer activity for selected signature
            boxplotContainer.classList.remove('loading');
            Plotly.purge(boxplotContainer);

            const sigData = filtered.filter(d => d.signature === selectedSig);
            if (sigData.length > 0) {
                sigData.sort((a, b) => b.mean_cancer - a.mean_cancer);

                Plotly.newPlot(boxplotContainer, [{
                    type: 'bar',
                    orientation: 'h',
                    y: sigData.map(d => labels[d.cancer_type] || d.cancer_type),
                    x: sigData.map(d => d.mean_cancer),
                    marker: {
                        color: sigData.map(d => d.mean_cancer),
                        colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                        cmid: 0
                    },
                    hovertemplate: '<b>%{y}</b><br>Activity: %{x:.3f}<extra></extra>'
                }], {
                    xaxis: { title: `${selectedSig} Activity (z-score)`, zeroline: true },
                    yaxis: { automargin: true },
                    margin: { l: 150, r: 30, t: 20, b: 50 },
                    height: Math.max(350, sigData.length * 30)
                }, { responsive: true });

                document.getElementById('tissue-boxplot-title').textContent = `${selectedSig} Activity Across Cancer Types`;
                document.getElementById('tissue-boxplot-subtitle').textContent = `${sigType} activity in ${sigData.length} cancer types`;
            } else {
                boxplotContainer.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data for selected signature.</p>';
            }

            // 2. Heatmap: Cancer types √ó Signatures
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                const dispSigs = signatures;
                const zMatrix = cancerTypes.map(ct =>
                    dispSigs.map(sig => {
                        const item = filtered.find(d => d.cancer_type === ct && d.signature === sig);
                        return item ? item.mean_cancer : 0;
                    })
                );

                Plotly.newPlot(heatmapContainer, [{
                    type: 'heatmap',
                    z: zMatrix,
                    x: dispSigs,
                    y: cancerTypes.map(ct => labels[ct] || ct),
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    zmid: 0,
                    colorbar: { title: 'Activity' },
                    hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.3f}<extra></extra>'
                }], {
                    xaxis: { tickangle: 45, tickfont: { size: 9 } },
                    yaxis: { automargin: true },
                    margin: { l: 150, r: 50, t: 20, b: 100 },
                    height: Math.max(350, cancerTypes.length * 30)
                }, { responsive: true });

                document.getElementById('tissue-heatmap-title').textContent = 'Cancer Type Activity Heatmap';
                document.getElementById('tissue-heatmap-subtitle').textContent = `${cancerTypes.length} cancer types √ó ${dispSigs.length} ${sigType} signatures`;
            }
        }

        function updateTissueAtlasCancer(boxplotContainer, heatmapContainer, sigType, selectedSig) {
            const matrixData = state.data.organcancermatrix;

            if (!matrixData || !matrixData.comparisons?.length) {
                [boxplotContainer, heatmapContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Cancer comparison data not available.</p>';
                    }
                });
                return;
            }

            const filtered = matrixData.comparisons.filter(d => d.signature_type === sigType);
            const cancerTypes = matrixData.cancer_types || [];
            const labels = matrixData.cancer_labels || {};
            const organMap = matrixData.organ_mapping || {};
            const signatures = sigType === 'CytoSig' ? matrixData.cytosig_signatures : matrixData.secact_signatures?.slice(0, 50);

            // 1. Paired dot plot: Normal vs Cancer for selected signature
            boxplotContainer.classList.remove('loading');
            Plotly.purge(boxplotContainer);

            const sigData = filtered.filter(d => d.signature === selectedSig);
            if (sigData.length > 0) {
                sigData.sort((a, b) => b.activity_diff - a.activity_diff);

                // Create paired dot plot with connecting lines
                const yLabels = sigData.map(d => labels[d.cancer_type] || d.cancer_type);

                // Line traces connecting Normal to Cancer
                const lineTraces = sigData.map((d, i) => ({
                    type: 'scatter',
                    mode: 'lines',
                    x: [d.mean_normal, d.mean_cancer],
                    y: [yLabels[i], yLabels[i]],
                    line: { color: '#999', width: 2 },
                    showlegend: false,
                    hoverinfo: 'skip'
                }));

                // Normal dots
                const normalTrace = {
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Normal',
                    x: sigData.map(d => d.mean_normal),
                    y: yLabels,
                    marker: { color: '#2166ac', size: 12, symbol: 'circle' },
                    hovertemplate: '<b>%{y}</b><br>Normal: %{x:.3f}<extra></extra>'
                };

                // Cancer dots
                const cancerTrace = {
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Cancer',
                    x: sigData.map(d => d.mean_cancer),
                    y: yLabels,
                    marker: { color: '#b2182b', size: 12, symbol: 'circle' },
                    hovertemplate: '<b>%{y}</b><br>Cancer: %{x:.3f}<extra></extra>'
                };

                Plotly.newPlot(boxplotContainer, [...lineTraces, normalTrace, cancerTrace], {
                    xaxis: { title: `${selectedSig} Activity (z-score)`, zeroline: true },
                    yaxis: { automargin: true },
                    legend: { orientation: 'h', y: 1.08 },
                    margin: { l: 150, r: 30, t: 40, b: 50 },
                    height: Math.max(350, sigData.length * 30)
                }, { responsive: true });

                document.getElementById('tissue-boxplot-title').textContent = `${selectedSig}: Normal vs Cancer Comparison`;
                document.getElementById('tissue-boxplot-subtitle').textContent = `Paired comparison across ${sigData.length} cancer types (blue=normal, red=cancer)`;
            }

            // 2. Heatmap: Activity Difference Cancer vs Normal
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                const dispSigs = signatures || [];
                const zMatrix = cancerTypes.map(ct =>
                    dispSigs.map(sig => {
                        const item = filtered.find(d => d.cancer_type === ct && d.signature === sig);
                        return item ? item.activity_diff : 0;
                    })
                );

                Plotly.newPlot(heatmapContainer, [{
                    type: 'heatmap',
                    z: zMatrix,
                    x: dispSigs,
                    y: cancerTypes.map(ct => labels[ct] || ct),
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    zmid: 0,
                    colorbar: { title: 'Œî Activity' },
                    hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.3f}<extra></extra>'
                }], {
                    xaxis: { tickangle: 45, tickfont: { size: 9 } },
                    yaxis: { automargin: true },
                    margin: { l: 150, r: 50, t: 20, b: 100 },
                    height: Math.max(350, cancerTypes.length * 30)
                }, { responsive: true });

                document.getElementById('tissue-heatmap-title').textContent = 'Cancer vs Normal Activity Difference';
                document.getElementById('tissue-heatmap-subtitle').textContent = `${cancerTypes.length} cancer types √ó ${dispSigs.length} ${sigType} signatures (red = higher in cancer)`;
            }
        }

        // scAtlas Cell Types - Search functions
        function getScatlasCelltypeSignatures() {
            const ctData = state.data.scatlascelltypes;
            if (!ctData) return [];
            const sigType = document.getElementById('ct-sig-type')?.value || 'CytoSig';
            return sigType === 'CytoSig'
                ? (ctData.cytosig_signatures || [])
                : (ctData.secact_signatures || []);
        }

        function showScatlasCelltypeSuggestions() {
            const input = document.getElementById('scatlas-ct-protein-search');
            const div = document.getElementById('scatlas-ct-suggestions');
            if (!input || !div) return;

            const query = input.value.toLowerCase();
            const sigs = getScatlasCelltypeSignatures();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query)).slice(0, 15);

            if (filtered.length === 0) { div.style.display = 'none'; return; }

            div.innerHTML = filtered.map(s =>
                `<div style="padding:6px 10px;cursor:pointer;border-bottom:1px solid #eee"
                     onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'"
                     onclick="selectScatlasCelltypeSig('${s}')">${s}</div>`
            ).join('');
            div.style.display = 'block';
        }

        function selectScatlasCelltypeSig(sig) {
            const input = document.getElementById('scatlas-ct-protein-search');
            const dropdown = document.getElementById('scatlas-ct-protein-dropdown');
            const div = document.getElementById('scatlas-ct-suggestions');
            if (input) input.value = sig;
            if (dropdown) dropdown.value = sig;
            if (div) div.style.display = 'none';
            updateScatlasCelltypeBar();
        }

        function populateScatlasCelltypeDropdown() {
            const dropdown = document.getElementById('scatlas-ct-protein-dropdown');
            const searchInput = document.getElementById('scatlas-ct-protein-search');
            if (!dropdown) return;

            const sigs = getScatlasCelltypeSignatures();
            if (sigs.length === 0) return;

            // Limit dropdown to 100 options for performance (user can search for others)
            const dropdownSigs = sigs.slice(0, 100);

            const currentValue = dropdown.value;
            dropdown.innerHTML = dropdownSigs.map(s =>
                `<option value="${s}">${s}</option>`
            ).join('');

            // Restore selection or default
            if (dropdownSigs.includes(currentValue)) {
                dropdown.value = currentValue;
            } else if (dropdownSigs.includes('IFNG')) {
                dropdown.value = 'IFNG';
            } else {
                dropdown.value = dropdownSigs[0] || '';
            }

            // Sync search input
            if (searchInput) {
                searchInput.value = dropdown.value;
            }
        }

        // scAtlas Cell Type Bar Chart
        function updateScatlasCelltypeBar() {
            const container = document.getElementById('scatlas-celltype-bar');
            if (!container) return;

            const ctData = state.data.scatlascelltypes;
            if (!ctData) {
                container.classList.remove('loading');
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Cell type data not available.</p>';
                return;
            }

            const sigType = document.getElementById('ct-sig-type')?.value || 'CytoSig';
            const organFilter = document.getElementById('ct-organ-filter')?.value || '';
            const searchInput = document.getElementById('scatlas-ct-protein-search')?.value?.trim();
            const signature = searchInput || document.getElementById('scatlas-ct-protein-dropdown')?.value || 'IFNG';

            // Filter data by signature type and signature
            let data = ctData.data.filter(d => d.signature_type === sigType && d.signature === signature);

            // Filter by organ if selected
            if (organFilter) {
                data = data.filter(d => d.organ === organFilter);
            }

            if (data.length === 0) {
                container.classList.remove('loading');
                container.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No data for ${signature} in selected organ.</p>`;
                return;
            }

            // Aggregate by cell type (average across organs if not filtered)
            const cellTypeMap = {};
            data.forEach(d => {
                if (!cellTypeMap[d.cell_type]) {
                    cellTypeMap[d.cell_type] = { sum: 0, count: 0 };
                }
                cellTypeMap[d.cell_type].sum += d.mean_activity;
                cellTypeMap[d.cell_type].count += 1;
            });

            const barData = Object.entries(cellTypeMap)
                .map(([ct, v]) => ({ cell_type: ct, mean: v.sum / v.count }))
                .sort((a, b) => b.mean - a.mean)
                .slice(0, 25);

            // Update subtitle
            const subtitle = document.getElementById('scatlas-celltype-bar-subtitle');
            if (subtitle) {
                const organText = organFilter ? ` in ${organFilter}` : ' across all organs';
                subtitle.textContent = `${signature} activity${organText} (top 25 cell types)`;
            }

            container.classList.remove('loading');
            Plotly.purge(container);

            Plotly.newPlot(container, [{
                type: 'bar',
                orientation: 'h',
                y: barData.map(d => d.cell_type),
                x: barData.map(d => d.mean),
                marker: {
                    color: barData.map(d => d.mean >= 0 ? '#1f77b4' : '#d62728')
                },
                hovertemplate: '<b>%{y}</b><br>Activity: %{x:.3f}<extra></extra>'
            }], {
                xaxis: { title: `${signature} Activity (z-score)`, zeroline: true },
                yaxis: { automargin: true },
                margin: { l: 150, r: 30, t: 20, b: 50 },
                height: Math.max(400, barData.length * 20)
            }, { responsive: true });
        }

        // Update cell type heatmap
        function updateCelltypeHeatmap() {
            const container = document.getElementById('celltype-heatmap');
            const sigType = document.getElementById('ct-sig-type')?.value || 'CytoSig';
            const organFilter = document.getElementById('ct-organ-filter')?.value || '';

            const ctData = state.data.scatlascelltypes;
            if (!ctData) return;

            // Filter data by signature type
            let data = ctData.data.filter(d => d.signature_type === sigType);

            // Filter by organ if selected
            if (organFilter) {
                data = data.filter(d => d.organ === organFilter);
            }

            // Get signatures for this type - limit SecAct to 50 for heatmap performance
            let signatures = sigType === 'CytoSig'
                ? (ctData.cytosig_signatures || [...new Set(data.map(d => d.signature))].sort())
                : (ctData.secact_signatures || [...new Set(data.map(d => d.signature))].sort()).slice(0, 50);

            // Get unique cell types from filtered data - limit to 50 for performance
            let cellTypes = [...new Set(data.map(d => d.cell_type))].slice(0, 50);

            // Update subtitle
            const subtitle = document.getElementById('celltype-heatmap-subtitle');
            if (subtitle) {
                const organText = organFilter ? ` in ${organFilter}` : '';
                const sigCount = sigType === 'SecAct' ? ' (top 50 signatures)' : '';
                subtitle.textContent = `${sigType} activity${sigCount} across cell types${organText} (${cellTypes.length} cell types)`;
            }

            container.classList.remove('loading');
            Plotly.purge(container);

            if (cellTypes.length === 0 || signatures.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available for this selection</p>';
                return;
            }

            // Build lookup map for O(1) access instead of O(n) filtering
            const dataMap = {};
            data.forEach(d => {
                const key = `${d.cell_type}|${d.signature}`;
                if (!dataMap[key]) dataMap[key] = [];
                dataMap[key].push(d.mean_activity);
            });

            // Create matrix using lookup map
            const zData = cellTypes.map(ct => {
                return signatures.map(sig => {
                    const key = `${ct}|${sig}`;
                    const values = dataMap[key];
                    if (!values || values.length === 0) return 0;
                    return values.reduce((a, b) => a + b, 0) / values.length;
                });
            });

            Plotly.newPlot(container, [{
                z: zData,
                x: signatures,
                y: cellTypes,
                type: 'heatmap',
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                
                zmid: 0,
                colorbar: {
                    title: 'Activity',
                    titleside: 'right'
                },
                hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.2f}<extra></extra>'
            }], {
                margin: {l: 200, r: 50, t: 30, b: 100},
                xaxis: {tickangle: 45},
                height: 650
            }, {responsive: true});
        }

        // Differential Analysis (Unified Tissue Comparison)
        function updateDifferentialAnalysis() {
            const volcanoContainer = document.getElementById('diff-volcano');
            const barContainer = document.getElementById('diff-top-bar');

            if (!volcanoContainer) return;

            const adjData = state.data.adjacenttissue;

            // Get signature type from dropdown
            const sigType = document.getElementById('diff-sigtype')?.value || 'CytoSig';

            // Populate cancer type dropdown
            const cancerDropdown = document.getElementById('diff-cancer-type');
            if (cancerDropdown && adjData?.cancer_types) {
                const currentCancer = cancerDropdown.value;
                const options = ['<option value="all">All Cancers (Pan-Cancer)</option>'];
                adjData.cancer_types.forEach(ct => {
                    options.push(`<option value="${ct}">${ct}</option>`);
                });
                cancerDropdown.innerHTML = options.join('');
                if (currentCancer && (currentCancer === 'all' || adjData.cancer_types.includes(currentCancer))) {
                    cancerDropdown.value = currentCancer;
                }
            }
            const selectedCancer = cancerDropdown?.value || 'all';

            if (!adjData || !adjData.tumor_vs_adjacent?.length) {
                [volcanoContainer, barContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Differential analysis data not available.</p>';
                    }
                });
                return;
            }

            // Update description card based on cancer and signature type selection
            const descCard = document.getElementById('diff-description-card');
            const sigLabel = sigType === 'CytoSig' ? 'cytokine' : 'secreted protein';
            if (descCard) {
                if (selectedCancer === 'all') {
                    descCard.innerHTML = `<strong>Differential Analysis (${sigType}):</strong> Compare ${sigLabel} activity across tissue types (Pan-Cancer):
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                        <li><strong style="color:#d62728;">Tumor:</strong> Cancer tissue from pan-cancer scAtlas (${adjData.summary?.n_tumor_samples || 147} cell type samples)</li>
                        <li><strong style="color:#ff7f0e;">Adjacent:</strong> Tumor-adjacent normal tissue - sample-matched controls from cancer patients (${adjData.summary?.n_adjacent_samples || 105} samples)</li>
                        <li><strong style="color:#2ca02c;">Normal:</strong> Healthy tissue from scAtlas normal organs - independent healthy donors (not patient-matched)</li>
                    </ul>`;
                } else {
                    const cancerStats = adjData.by_cancer_type?.find(d => d.cancer_type === selectedCancer && d.signature_type === sigType);
                    const nTumor = cancerStats?.tumor?.n || 'N/A';
                    const nAdj = cancerStats?.adjacent?.n || 'N/A';
                    const organMap = adjData.cancer_organ_map || {};
                    const matchedOrgan = organMap[selectedCancer] || 'matching organ';
                    descCard.innerHTML = `<strong>Differential Analysis (${sigType}):</strong> Compare ${sigLabel} activity for <strong>${selectedCancer}</strong>:
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem;">
                        <li><strong style="color:#d62728;">Tumor:</strong> ${selectedCancer} tumor tissue (${nTumor} samples)</li>
                        <li><strong style="color:#ff7f0e;">Adjacent:</strong> ${selectedCancer} tumor-adjacent normal tissue (${nAdj} samples)</li>
                    </ul>
                    <small style="color:#666;">Note: Normal tissue reference (${matchedOrgan}) available in Pan-Cancer view.</small>`;
                }
            }

            // Filter data by signature type and cancer type
            let filtered;
            if (selectedCancer === 'all') {
                filtered = adjData.tumor_vs_adjacent.filter(d => d.signature_type === sigType);
            } else {
                filtered = (adjData.by_cancer_type || []).filter(d => d.signature_type === sigType && d.cancer_type === selectedCancer);
            }

            // Volcano plot
            if (volcanoContainer) {
                volcanoContainer.classList.remove('loading');
                Plotly.purge(volcanoContainer);

                const diffData = filtered.map(d => ({
                    signature: d.signature,
                    activity_diff: d.activity_diff || 0,
                    pvalue: d.pvalue || 1,
                    negLogP: d.neg_log10_pval || -Math.log10(Math.max(d.pvalue || 1, 1e-100))
                }));

                const significantUp = diffData.filter(d => d.activity_diff > 0.3 && d.pvalue < 0.05);
                const significantDown = diffData.filter(d => d.activity_diff < -0.3 && d.pvalue < 0.05);
                const notSig = diffData.filter(d => Math.abs(d.activity_diff) <= 0.3 || d.pvalue >= 0.05);

                // Update subtitle
                const volcanoSubtitle = document.getElementById('diff-volcano-subtitle');
                if (volcanoSubtitle) {
                    const nSigUp = significantUp.length;
                    const nSigDown = significantDown.length;
                    const sigTypeLabel = sigType === 'CytoSig' ? 'CytoSig' : 'SecAct';
                    if (selectedCancer === 'all') {
                        volcanoSubtitle.textContent = `${sigTypeLabel}: ${nSigUp + nSigDown} significant (p<0.05) | Pan-Cancer: ${adjData.summary?.n_tumor_samples || 0} tumor vs ${adjData.summary?.n_adjacent_samples || 0} adjacent`;
                    } else {
                        const sampleEntry = filtered[0];
                        const nTumor = sampleEntry?.tumor?.n || 'N/A';
                        const nAdj = sampleEntry?.adjacent?.n || 'N/A';
                        volcanoSubtitle.textContent = `${sigTypeLabel}: ${nSigUp + nSigDown} significant (p<0.05) | ${selectedCancer}: ${nTumor} tumor vs ${nAdj} adjacent`;
                    }
                }

                Plotly.newPlot(volcanoContainer, [
                    {
                        type: 'scatter', mode: 'markers+text', name: 'Higher in Adjacent',
                        x: significantUp.map(d => d.activity_diff), y: significantUp.map(d => d.negLogP),
                        text: significantUp.map(d => d.signature), textposition: 'top center', textfont: { size: 9 },
                        marker: { color: '#ff7f0e', size: 10 }
                    },
                    {
                        type: 'scatter', mode: 'markers+text', name: 'Higher in Tumor',
                        x: significantDown.map(d => d.activity_diff), y: significantDown.map(d => d.negLogP),
                        text: significantDown.map(d => d.signature), textposition: 'top center', textfont: { size: 9 },
                        marker: { color: '#d62728', size: 10 }
                    },
                    {
                        type: 'scatter', mode: 'markers', name: 'Not significant',
                        x: notSig.map(d => d.activity_diff), y: notSig.map(d => d.negLogP),
                        text: notSig.map(d => d.signature), marker: { color: '#ccc', size: 6 },
                        hovertemplate: '<b>%{text}</b><br>Œî Activity: %{x:.3f}<br>-log10(p): %{y:.2f}<extra></extra>'
                    }
                ], {
                    xaxis: { title: 'Œî Activity (Adjacent - Tumor)', zeroline: true },
                    yaxis: { title: '-log10(p-value)' },
                    shapes: [
                        { type: 'line', x0: 0.3, y0: 0, x1: 0.3, y1: 10, line: { dash: 'dot', color: '#999' } },
                        { type: 'line', x0: -0.3, y0: 0, x1: -0.3, y1: 10, line: { dash: 'dot', color: '#999' } },
                        { type: 'line', x0: -3, y0: -Math.log10(0.05), x1: 3, y1: -Math.log10(0.05), line: { dash: 'dot', color: '#999' } }
                    ],
                    margin: { l: 60, r: 30, t: 30, b: 50 },
                    legend: { orientation: 'h', y: -0.15 },
                    height: 380
                }, { responsive: true });
            }

            // 3. Top differential bar chart
            if (barContainer) {
                barContainer.classList.remove('loading');
                Plotly.purge(barContainer);

                const sorted = [...filtered].sort((a, b) => Math.abs(b.activity_diff || 0) - Math.abs(a.activity_diff || 0));
                const top15 = sorted.slice(0, 15);

                Plotly.newPlot(barContainer, [{
                    type: 'bar',
                    orientation: 'h',
                    y: top15.map(d => d.signature),
                    x: top15.map(d => d.activity_diff || 0),
                    marker: {
                        color: top15.map(d => (d.pvalue || 1) < 0.05 ? ((d.activity_diff || 0) > 0 ? '#ff7f0e' : '#d62728') : '#ccc')
                    },
                    text: top15.map(d => (d.activity_diff || 0).toFixed(3)),
                    textposition: 'auto',
                    hovertemplate: '<b>%{y}</b><br>Œî Activity: %{x:.3f}<br>p = %{customdata:.2e}<extra></extra>',
                    customdata: top15.map(d => d.pvalue || 1)
                }], {
                    xaxis: { title: 'Œî Activity (Adjacent - Tumor)', zeroline: true },
                    yaxis: { automargin: true },
                    margin: { l: 100, r: 50, t: 30, b: 50 },
                    height: 380
                }, { responsive: true });
            }

            // Update boxplot
            updateDiffBoxplot();
        }

        // Populate signature dropdown for differential boxplot
        function updateDiffSignatureList() {
            const adjData = state.data.adjacenttissue;
            if (!adjData?.boxplot_data) return;

            const sigType = document.getElementById('diff-sigtype')?.value || 'CytoSig';
            const dropdown = document.getElementById('diff-signature');
            if (!dropdown) return;

            // Get unique signatures for this type
            const signatures = adjData.boxplot_data
                .filter(d => d.signature_type === sigType)
                .map(d => d.signature)
                .filter((v, i, a) => a.indexOf(v) === i)
                .sort();

            dropdown.innerHTML = signatures.map(s => `<option value="${s}">${s}</option>`).join('');

            // Default to IFNG or first signature
            if (signatures.includes('IFNG')) {
                dropdown.value = 'IFNG';
            }
        }

        // Filter signatures by search text
        function filterDiffSignatures() {
            const searchInput = document.getElementById('diff-sig-search');
            const dropdown = document.getElementById('diff-signature');
            if (!searchInput || !dropdown) return;

            const searchText = searchInput.value.toLowerCase();
            const adjData = state.data.adjacenttissue;
            if (!adjData?.boxplot_data) return;

            const sigType = document.getElementById('diff-sigtype')?.value || 'CytoSig';
            const allSigs = adjData.boxplot_data
                .filter(d => d.signature_type === sigType)
                .map(d => d.signature)
                .filter((v, i, a) => a.indexOf(v) === i)
                .sort();

            const filtered = searchText ? allSigs.filter(s => s.toLowerCase().includes(searchText)) : allSigs;
            dropdown.innerHTML = filtered.map(s => `<option value="${s}">${s}</option>`).join('');

            if (filtered.length > 0) {
                updateDiffBoxplot();
            }
        }

        // Update tissue comparison boxplot
        function updateDiffBoxplot() {
            const container = document.getElementById('diff-boxplot');
            if (!container) return;

            const adjData = state.data.adjacenttissue;
            if (!adjData?.boxplot_data?.length) {
                container.classList.remove('loading');
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Boxplot data not available.</p>';
                return;
            }

            const sigType = document.getElementById('diff-sigtype')?.value || 'CytoSig';
            const selectedSig = document.getElementById('diff-signature')?.value || 'IFNG';
            const selectedCancer = document.getElementById('diff-cancer-type')?.value || 'all';

            // Find boxplot data for selected signature
            let boxData;
            if (selectedCancer === 'all') {
                // Use boxplot_data for pan-cancer (includes normal tissue)
                boxData = adjData.boxplot_data?.find(d =>
                    d.signature === selectedSig &&
                    d.signature_type === sigType &&
                    d.cancer_type === 'all'
                );
            } else {
                // Use by_cancer_type for specific cancer (tumor + adjacent only)
                boxData = adjData.by_cancer_type?.find(d =>
                    d.signature === selectedSig &&
                    d.signature_type === sigType &&
                    d.cancer_type === selectedCancer
                );
            }

            if (!boxData) {
                container.classList.remove('loading');
                container.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No data for ${selectedSig} in ${selectedCancer === 'all' ? 'Pan-Cancer' : selectedCancer}.</p>`;
                return;
            }

            container.classList.remove('loading');
            Plotly.purge(container);

            // Update subtitle
            const subtitle = document.getElementById('diff-boxplot-subtitle');
            if (subtitle) {
                if (selectedCancer === 'all') {
                    subtitle.textContent = `${selectedSig} activity: Tumor (n=${boxData.tumor?.n || 0}) vs Adjacent (n=${boxData.adjacent?.n || 0}) vs Normal (n=${boxData.normal?.n || 0})`;
                } else {
                    subtitle.textContent = `${selectedSig} activity in ${selectedCancer}: Tumor (n=${boxData.tumor?.n || boxData.n_tumor || 0}) vs Adjacent (n=${boxData.adjacent?.n || boxData.n_adjacent || 0})`;
                }
            }

            // Create box traces for each tissue type
            const traces = [];

            // Tumor
            if (boxData.tumor) {
                traces.push({
                    type: 'box',
                    name: 'Tumor',
                    y: [boxData.tumor.min, boxData.tumor.q1, boxData.tumor.median, boxData.tumor.q3, boxData.tumor.max],
                    lowerfence: [boxData.tumor.min],
                    upperfence: [boxData.tumor.max],
                    q1: [boxData.tumor.q1],
                    median: [boxData.tumor.median],
                    q3: [boxData.tumor.q3],
                    mean: [boxData.tumor.mean],
                    boxmean: true,
                    marker: { color: '#d62728' },
                    line: { color: '#d62728' },
                    fillcolor: 'rgba(214, 39, 40, 0.3)',
                    hovertemplate: `<b>Tumor</b><br>Median: ${boxData.tumor.median.toFixed(3)}<br>Mean: ${boxData.tumor.mean.toFixed(3)}<br>Q1-Q3: ${boxData.tumor.q1.toFixed(2)} - ${boxData.tumor.q3.toFixed(2)}<br>n=${boxData.tumor.n}<extra></extra>`
                });
            }

            // Adjacent
            if (boxData.adjacent) {
                traces.push({
                    type: 'box',
                    name: 'Adjacent',
                    y: [boxData.adjacent.min, boxData.adjacent.q1, boxData.adjacent.median, boxData.adjacent.q3, boxData.adjacent.max],
                    lowerfence: [boxData.adjacent.min],
                    upperfence: [boxData.adjacent.max],
                    q1: [boxData.adjacent.q1],
                    median: [boxData.adjacent.median],
                    q3: [boxData.adjacent.q3],
                    mean: [boxData.adjacent.mean],
                    boxmean: true,
                    marker: { color: '#ff7f0e' },
                    line: { color: '#ff7f0e' },
                    fillcolor: 'rgba(255, 127, 14, 0.3)',
                    hovertemplate: `<b>Adjacent</b><br>Median: ${boxData.adjacent.median.toFixed(3)}<br>Mean: ${boxData.adjacent.mean.toFixed(3)}<br>Q1-Q3: ${boxData.adjacent.q1.toFixed(2)} - ${boxData.adjacent.q3.toFixed(2)}<br>n=${boxData.adjacent.n}<extra></extra>`
                });
            }

            // Normal
            if (boxData.normal) {
                traces.push({
                    type: 'box',
                    name: 'Normal',
                    y: [boxData.normal.min, boxData.normal.q1, boxData.normal.median, boxData.normal.q3, boxData.normal.max],
                    lowerfence: [boxData.normal.min],
                    upperfence: [boxData.normal.max],
                    q1: [boxData.normal.q1],
                    median: [boxData.normal.median],
                    q3: [boxData.normal.q3],
                    mean: [boxData.normal.mean],
                    boxmean: true,
                    marker: { color: '#2ca02c' },
                    line: { color: '#2ca02c' },
                    fillcolor: 'rgba(44, 160, 44, 0.3)',
                    hovertemplate: `<b>Normal</b><br>Median: ${boxData.normal.median.toFixed(3)}<br>Mean: ${boxData.normal.mean.toFixed(3)}<br>Q1-Q3: ${boxData.normal.q1.toFixed(2)} - ${boxData.normal.q3.toFixed(2)}<br>n=${boxData.normal.n}<extra></extra>`
                });
            }

            Plotly.newPlot(container, traces, {
                yaxis: { title: 'Activity (z-score)', zeroline: true },
                margin: { l: 60, r: 30, t: 30, b: 50 },
                showlegend: true,
                legend: { orientation: 'h', y: -0.15 },
                height: 380
            }, { responsive: true });
        }

        // Update inflammation visualization
        function updateInflammationViz() {
            const data = state.data.inflammationcelltype;
            console.log('updateInflammationViz called, data length:', data ? data.length : 'null');
            if (!data || data.length === 0) {
                console.log('Inflammation data not loaded');
                // Show message in containers
                ['inflam-celltype-bar', 'inflam-heatmap'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.classList.remove('loading');
                        el.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Inflammation cell type data not available. Check console for details.</p>';
                    }
                });
                return;
            }

            // Initial population and rendering
            populateInflammationSignatures();
            updateInflammationBar();
            updateInflammationHeatmap();
        }

        // Store available inflammation signatures for search
        let inflammationSignatures = { all: [], cytosig: [], secact: [] };

        function populateInflammationSignatures() {
            const data = state.data.inflammationcelltype;
            if (!data) return;

            // Build signature lists
            const cytosigSigs = [...new Set(data.filter(d =>
                d.signature_type === 'CytoSig' || !d.signature_type
            ).map(d => d.signature))].sort();

            const secactSigs = [...new Set(data.filter(d =>
                d.signature_type === 'SecAct'
            ).map(d => d.signature))].sort();

            inflammationSignatures = {
                cytosig: cytosigSigs,
                secact: secactSigs,
                all: [...new Set([...cytosigSigs, ...secactSigs])].sort()
            };
        }

        function getInflammationSignatures() {
            const sigType = document.getElementById('inflam-sig-type')?.value || 'CytoSig';
            if (sigType === 'SecAct') return inflammationSignatures.secact;
            return inflammationSignatures.cytosig;
        }

        function showInflamSignatureSuggestions() {
            const input = document.getElementById('inflam-signature-search');
            const suggestionsDiv = document.getElementById('inflam-signature-suggestions');
            if (!input || !suggestionsDiv) return;

            const query = input.value.toLowerCase();
            const signatures = getInflammationSignatures();
            const filtered = signatures.filter(s => s.toLowerCase().includes(query)).slice(0, 15);

            if (filtered.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            suggestionsDiv.innerHTML = filtered.map(s =>
                `<div style="padding: 6px 10px; cursor: pointer; border-bottom: 1px solid #eee;"
                     onmouseover="this.style.background='#f0f0f0'"
                     onmouseout="this.style.background='white'"
                     onclick="selectInflamSignature('${s}')">${s}</div>`
            ).join('');
            suggestionsDiv.style.display = 'block';
        }

        function selectInflamSignature(sig) {
            const input = document.getElementById('inflam-signature-search');
            const suggestionsDiv = document.getElementById('inflam-signature-suggestions');
            if (input) input.value = sig;
            if (suggestionsDiv) suggestionsDiv.style.display = 'none';
            updateInflammationBar();
        }

        function updateInflammationBar() {
            const container = document.getElementById('inflam-celltype-bar');
            if (!container) return;

            const data = state.data.inflammationcelltype;
            if (!data) return;

            const sigType = document.getElementById('inflam-sig-type')?.value || 'CytoSig';
            const signature = document.getElementById('inflam-signature-search')?.value || 'IFNG';

            // Filter to selected signature type and signature
            const filtered = data.filter(d =>
                d.signature === signature &&
                (d.signature_type === sigType || (!d.signature_type && sigType === 'CytoSig'))
            );
            filtered.sort((a, b) => b.mean_activity - a.mean_activity);

            // Take top 30 cell types
            const top30 = filtered.slice(0, 30);

            container.classList.remove('loading');

            // Clear previous plot
            Plotly.purge(container);

            if (top30.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available</p>';
                return;
            }

            Plotly.newPlot(container, [{
                y: top30.map(d => d.cell_type),
                x: top30.map(d => d.mean_activity),
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: top30.map(d => d.mean_activity),
                    colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                    
                    cmid: 0
                },
                hovertemplate: '<b>%{y}</b><br>Activity: %{x:.2f}<br>Samples: %{customdata}<extra></extra>',
                customdata: top30.map(d => d.n_samples)
            }], {
                margin: {l: 180, r: 30, t: 30, b: 50},
                xaxis: {title: 'Mean Activity'},
                height: 450
            }, {responsive: true});
        }

        function updateInflammationHeatmap() {
            const container = document.getElementById('inflam-heatmap');
            if (!container) return;

            const data = state.data.inflammationcelltype;
            if (!data) return;

            const sigType = document.getElementById('inflam-sig-type')?.value || 'CytoSig';

            // Filter by signature type
            const filteredData = data.filter(d =>
                d.signature_type === sigType || (!d.signature_type && sigType === 'CytoSig')
            );

            // Build lookup index for fast access
            const dataIndex = {};
            filteredData.forEach(d => {
                const key = `${d.cell_type}|${d.signature}`;
                dataIndex[key] = d.mean_activity;
            });

            // Get cell types and signatures
            const cellTypes = [...new Set(filteredData.map(d => d.cell_type))];
            const allSignatures = [...new Set(filteredData.map(d => d.signature))];

            // Find most variable signatures (for SecAct with 1000+ proteins)
            const sigVariance = {};
            allSignatures.forEach(sig => {
                const vals = cellTypes.map(ct => dataIndex[`${ct}|${sig}`] || 0);
                if (vals.length === 0) return;
                const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                const variance = vals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / vals.length;
                sigVariance[sig] = variance;
            });

            // Limit to top 50 most variable signatures for readability
            const maxSigs = sigType === 'CytoSig' ? allSignatures.length : 50;
            const topSignatures = Object.entries(sigVariance)
                .sort((a, b) => b[1] - a[1])
                .slice(0, maxSigs)
                .map(d => d[0])
                .sort(); // alphabetical for display

            // Find most variable cell types
            const ctVariance = {};
            cellTypes.forEach(ct => {
                const vals = topSignatures.map(sig => dataIndex[`${ct}|${sig}`] || 0);
                if (vals.length === 0) return;
                const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                const variance = vals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / vals.length;
                ctVariance[ct] = variance;
            });

            // Top 25 most variable cell types
            const topCts = Object.entries(ctVariance)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 25)
                .map(d => d[0]);

            // Create matrix using index (fast)
            const zData = topCts.map(ct =>
                topSignatures.map(sig => dataIndex[`${ct}|${sig}`] || 0)
            );

            container.classList.remove('loading');
            Plotly.purge(container);

            if (topCts.length === 0 || topSignatures.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available for this signature type</p>';
                return;
            }

            const subtitle = sigType === 'SecAct' ? ` (top ${topSignatures.length} most variable)` : '';
            Plotly.newPlot(container, [{
                z: zData,
                x: topSignatures,
                y: topCts,
                type: 'heatmap',
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                zmid: 0,
                colorbar: {title: 'Activity'},
                hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.2f}<extra></extra>'
            }], {
                margin: {l: 180, r: 50, t: 40, b: 100},
                xaxis: {tickangle: 45},
                height: 450,
                title: {text: sigType === 'SecAct' ? 'Top 50 Variable Proteins' : '', font: {size: 12}}
            }, {responsive: true});
        }

        // CIMA Cell Type visualization functions
        function updateCimaCelltypeViz() {
            const data = state.data.cimacelltype;
            if (!data) {
                console.log('CIMA celltype data not loaded');
                return;
            }
            initCimaCelltypeSigs();
            updateCimaCelltypeBar();
            updateCimaCelltypeHeatmap();
        }

        // CIMA Cell Types autocomplete
        let cimaCelltypeSigs = { cytosig: [], secact: [] };

        function initCimaCelltypeSigs() {
            const data = state.data.cimacelltype;
            if (!data) return;
            cimaCelltypeSigs.cytosig = [...new Set(data.filter(d => d.signature_type === 'CytoSig').map(d => d.signature))].sort();
            cimaCelltypeSigs.secact = [...new Set(data.filter(d => d.signature_type === 'SecAct').map(d => d.signature))].sort();
        }

        function getCimaCelltypeSigs() {
            const sigType = document.getElementById('cima-ct-sig-type')?.value || 'CytoSig';
            return sigType === 'CytoSig' ? cimaCelltypeSigs.cytosig : cimaCelltypeSigs.secact;
        }

        function showCimaCelltypeSuggestions(query) {
            const suggestionsDiv = document.getElementById('cima-ct-protein-suggestions');
            if (!suggestionsDiv) return;

            const sigs = getCimaCelltypeSigs();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query.toLowerCase())).slice(0, 20);

            if (filtered.length === 0 || query.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            suggestionsDiv.innerHTML = filtered.map(s =>
                `<div class="suggestion-item" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                     onmouseover="this.style.background='#f0f0f0'"
                     onmouseout="this.style.background='white'"
                     onclick="selectCimaCelltypeSig('${s}')">${s}</div>`
            ).join('');
            suggestionsDiv.style.display = 'block';
        }

        function selectCimaCelltypeSig(sig) {
            const searchInput = document.getElementById('cima-ct-protein-search');
            const suggestionsDiv = document.getElementById('cima-ct-protein-suggestions');
            if (searchInput) searchInput.value = sig;
            if (suggestionsDiv) suggestionsDiv.style.display = 'none';
            updateCimaCelltypeBar();
        }

        function updateCimaCelltypeBar() {
            const container = document.getElementById('cima-celltype-bar');
            if (!container) return;

            const data = state.data.cimacelltype;
            if (!data) return;

            const sigType = document.getElementById('cima-ct-sig-type')?.value || 'CytoSig';
            const signature = document.getElementById('cima-ct-protein-search')?.value || 'IFNG';

            const filtered = data.filter(d =>
                d.signature === signature &&
                (d.signature_type === sigType || (!d.signature_type && sigType === 'CytoSig'))
            );
            filtered.sort((a, b) => b.mean_activity - a.mean_activity);

            container.classList.remove('loading');
            Plotly.purge(container);

            if (filtered.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available</p>';
                return;
            }

            Plotly.newPlot(container, [{
                y: filtered.map(d => d.cell_type),
                x: filtered.map(d => d.mean_activity),
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: filtered.map(d => d.mean_activity),
                    colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                    
                    cmid: 0
                },
                hovertemplate: '<b>%{y}</b><br>Activity: %{x:.4f}<br>Samples: %{customdata}<extra></extra>',
                customdata: filtered.map(d => d.n_samples)
            }], {
                margin: {l: 140, r: 30, t: 30, b: 50},
                xaxis: {title: 'Mean Activity'},
                height: 450
            }, {responsive: true});
        }

        function updateCimaCelltypeHeatmap() {
            const container = document.getElementById('cima-celltype-heatmap');
            if (!container) return;

            const data = state.data.cimacelltype;
            if (!data) return;

            const sigType = document.getElementById('cima-ct-sig-type')?.value || 'CytoSig';

            const filteredData = data.filter(d =>
                d.signature_type === sigType || (!d.signature_type && sigType === 'CytoSig')
            );

            const cellTypes = [...new Set(filteredData.map(d => d.cell_type))];
            const signatures = [...new Set(filteredData.map(d => d.signature))].sort();

            // Create matrix
            const zData = cellTypes.map(ct =>
                signatures.map(sig => {
                    const match = filteredData.find(d => d.cell_type === ct && d.signature === sig);
                    return match ? match.mean_activity : 0;
                })
            );

            container.classList.remove('loading');
            Plotly.purge(container);

            if (cellTypes.length === 0 || signatures.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available</p>';
                return;
            }

            Plotly.newPlot(container, [{
                z: zData,
                x: signatures,
                y: cellTypes,
                type: 'heatmap',
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                
                zmid: 0,
                colorbar: {title: 'Activity'},
                hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.4f}<extra></extra>'
            }], {
                margin: {l: 140, r: 50, t: 30, b: 100},
                xaxis: {tickangle: 45},
                height: 450
            }, {responsive: true});
        }

        // ========================================
        // NEW CIMA PANELS: Biochemistry Scatter, Multi-omics, Population, eQTL
        // ========================================

        // Store biochem scatter signatures for autocomplete
        let biochemScatterSigs = { cytosig: [], secact: [] };

        function initBiochemScatterSigs() {
            const scatterData = state.data.cimabiochemscatter;
            if (!scatterData) return;
            // CytoSig cytokine names
            biochemScatterSigs.cytosig = scatterData.cytokines || [];
            // SecAct protein names
            biochemScatterSigs.secact = scatterData.secact_proteins || [];
        }

        function getBiochemScatterSigs() {
            const sigType = document.getElementById('biochem-scatter-sig-type')?.value || 'CytoSig';
            return sigType === 'CytoSig' ? biochemScatterSigs.cytosig : biochemScatterSigs.secact;
        }

        function showBiochemScatterSuggestions(query) {
            const suggestionsDiv = document.getElementById('biochem-scatter-suggestions');
            if (!suggestionsDiv) return;

            const sigs = getBiochemScatterSigs();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query.toLowerCase())).slice(0, 20);

            if (filtered.length === 0 || query.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            suggestionsDiv.innerHTML = filtered.map(s =>
                `<div class="suggestion-item" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                     onmouseover="this.style.background='#f0f0f0'"
                     onmouseout="this.style.background='white'"
                     onclick="selectBiochemScatterSig('${s}')">${s}</div>`
            ).join('');
            suggestionsDiv.style.display = 'block';
        }

        function selectBiochemScatterSig(sig) {
            const searchInput = document.getElementById('biochem-scatter-protein-search');
            const suggestionsDiv = document.getElementById('biochem-scatter-suggestions');
            if (searchInput) searchInput.value = sig;
            if (suggestionsDiv) suggestionsDiv.style.display = 'none';
            updateBiochemScatter();
        }

        // CIMA: Biochemistry Scatter Plot
        function updateBiochemScatter() {
            const container = document.getElementById('biochem-scatter-plot');
            const statsContainer = document.getElementById('biochem-regression-stats');
            if (!container) return;

            container.classList.remove('loading');
            Plotly.purge(container);

            const xAxis = document.getElementById('biochem-x-axis')?.value || 'ALT';
            const sigType = document.getElementById('biochem-scatter-sig-type')?.value || 'CytoSig';
            const yProtein = document.getElementById('biochem-scatter-protein-search')?.value || 'IFNG';
            const colorBy = document.getElementById('biochem-color-by')?.value || 'sex';

            // Use real data from cimabiochemscatter
            const scatterData = state.data.cimabiochemscatter;
            if (!scatterData || !scatterData.samples) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Scatter data not available</p>';
                return;
            }

            const samples = scatterData.samples;
            // Use 'activity' for CytoSig, 'secact_activity' for SecAct
            const activityKey = sigType === 'CytoSig' ? 'activity' : 'secact_activity';

            // Color mapping
            const colorMap = {
                'Male': '#1f77b4', 'Female': '#ff7f0e', 'Unknown': '#999',
                '<30': '#1f77b4', '30-39': '#2ca02c', '40-49': '#ff7f0e', '50-59': '#d62728', '60+': '#9467bd',
                'Normal': '#2ca02c', 'Overweight': '#ff7f0e', 'Obese': '#d62728',
                'Underweight': '#17becf'
            };

            // Process data - get x (biochem), y (activity), and color group
            const plotData = [];
            samples.forEach(s => {
                const xVal = s.biochem?.[xAxis];
                const yVal = s[activityKey]?.[yProtein];
                if (xVal == null || yVal == null) return;

                let group;
                if (colorBy === 'sex') {
                    group = s.sex || 'Unknown';
                } else if (colorBy === 'age_bin') {
                    const age = s.age;
                    if (age == null) group = 'Unknown';
                    else if (age < 30) group = '<30';
                    else if (age < 40) group = '30-39';
                    else if (age < 50) group = '40-49';
                    else if (age < 60) group = '50-59';
                    else group = '60+';
                } else if (colorBy === 'bmi_bin') {
                    const bmi = s.bmi;
                    if (bmi == null) group = 'Unknown';
                    else if (bmi < 18.5) group = 'Underweight';
                    else if (bmi < 25) group = 'Normal';
                    else if (bmi < 30) group = 'Overweight';
                    else group = 'Obese';
                } else {
                    group = 'All';
                }

                plotData.push({ x: xVal, y: yVal, group, sample: s.sample, age: s.age, sex: s.sex, bmi: s.bmi });
            });

            if (plotData.length === 0) {
                container.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No data available for "${yProtein}" in ${sigType}. Try searching for a different protein.</p>`;
                return;
            }

            // Get unique groups and sort (Male before Female for sex)
            let groups = [...new Set(plotData.map(d => d.group))];
            if (colorBy === 'sex') {
                groups = groups.sort((a, b) => {
                    const order = ['Male', 'Female', 'Unknown'];
                    return order.indexOf(a) - order.indexOf(b);
                });
            } else {
                groups = groups.sort();
            }

            // Create traces for each group
            const traces = groups.map(group => {
                const groupData = plotData.filter(d => d.group === group);
                return {
                    type: 'scatter',
                    mode: 'markers',
                    name: `${group} (n=${groupData.length})`,
                    x: groupData.map(d => d.x),
                    y: groupData.map(d => d.y),
                    text: groupData.map(d => `${d.sample}<br>Sex: ${d.sex || 'NA'}<br>Age: ${d.age || 'NA'}<br>BMI: ${d.bmi?.toFixed(1) || 'NA'}`),
                    marker: {
                        size: 8,
                        color: colorMap[group] || '#999',
                        opacity: 0.7
                    },
                    hovertemplate: '<b>%{text}</b><br>' + xAxis + ': %{x:.2f}<br>' + yProtein + ': %{y:.3f}<extra></extra>'
                };
            });

            // Calculate trend line using all data
            const allX = plotData.map(d => d.x);
            const allY = plotData.map(d => d.y);
            const n = allX.length;
            const meanX = allX.reduce((a, b) => a + b, 0) / n;
            const meanY = allY.reduce((a, b) => a + b, 0) / n;

            const ssXY = allX.reduce((acc, x, i) => acc + (x - meanX) * (allY[i] - meanY), 0);
            const ssXX = allX.reduce((acc, x) => acc + (x - meanX) ** 2, 0);
            const slope = ssXX > 0 ? ssXY / ssXX : 0;
            const intercept = meanY - slope * meanX;

            // Calculate correlation coefficient
            const ssYY = allY.reduce((acc, y) => acc + (y - meanY) ** 2, 0);
            const r = (ssXX > 0 && ssYY > 0) ? ssXY / Math.sqrt(ssXX * ssYY) : 0;

            traces.push({
                type: 'scatter',
                mode: 'lines',
                name: 'Trend',
                x: [Math.min(...allX), Math.max(...allX)],
                y: [slope * Math.min(...allX) + intercept, slope * Math.max(...allX) + intercept],
                line: { dash: 'dash', color: '#333', width: 2 },
                showlegend: true
            });

            Plotly.newPlot(container, traces, {
                xaxis: { title: xAxis },
                yaxis: { title: `${yProtein} Activity (${sigType})` },
                margin: { l: 60, r: 30, t: 30, b: 50 },
                legend: { orientation: 'h', y: -0.15 },
                height: 500
            }, { responsive: true });

            // Update stats container with regression statistics
            if (statsContainer) {
                statsContainer.classList.remove('loading');
                const r2 = r * r;

                statsContainer.innerHTML = `
                    <div style="padding: 1rem;">
                        <table class="data-table">
                            <tr><th>Statistic</th><th>Value</th></tr>
                            <tr><td>Pearson r</td><td>${r.toFixed(4)}</td></tr>
                            <tr><td>R¬≤</td><td>${r2.toFixed(4)}</td></tr>
                            <tr><td>Slope</td><td>${slope.toExponential(3)}</td></tr>
                            <tr><td>Intercept</td><td>${intercept.toFixed(4)}</td></tr>
                            <tr><td>N samples</td><td>${n}</td></tr>
                        </table>
                        <p style="margin-top: 1rem; color: #666; font-size: 0.9rem;">
                            Linear regression of ${yProtein} (${sigType}) activity vs ${xAxis} blood marker.
                        </p>
                    </div>
                `;
            }
        }

        // Initialize biochem scatter (called during setup)
        function populateBiochemCytokines() {
            initBiochemScatterSigs();
        }

        // CIMA: Multi-omics Integration
        function updateMultiomicsViz() {
            const container = document.getElementById('multiomics-network');
            const summaryContainer = document.getElementById('multiomics-summary');
            if (!container) return;

            container.classList.remove('loading');
            container.innerHTML = '';

            // Check if container is visible
            const containerWidth = container.offsetWidth;
            if (containerWidth < 100) return;

            const analysisType = document.getElementById('multiomics-analysis')?.value || 'correlation';
            const threshold = parseFloat(document.getElementById('multiomics-threshold')?.value || '0.4');
            const cytokineSubset = document.getElementById('multiomics-cytokines')?.value || 'all';

            // Get real data
            const biochemData = state.data.cimacorrelations?.biochemistry || [];
            const metabData = state.data.cimametabolitestop || [];

            if (biochemData.length === 0 && metabData.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Multi-omics data not available</p>';
                return;
            }

            // Define cytokine subsets
            let cytokineFilter;
            if (cytokineSubset === 'inflammatory') {
                cytokineFilter = ['IL1B', 'IL6', 'TNFA', 'IL8', 'IL12'];
            } else if (cytokineSubset === 'regulatory') {
                cytokineFilter = ['IL10', 'TGFB1', 'IL4', 'IL13'];
            } else if (cytokineSubset === 'th17') {
                cytokineFilter = ['IL17A', 'IL22', 'IL21', 'IL23'];
            } else {
                cytokineFilter = null; // All cytokines
            }

            // Filter and process biochemistry correlations
            let biochemFiltered = biochemData.filter(d =>
                Math.abs(d.rho) >= threshold &&
                d.signature === 'CytoSig' &&
                (!cytokineFilter || cytokineFilter.includes(d.protein))
            );

            // Filter and process metabolite correlations
            let metabFiltered = metabData.filter(d =>
                Math.abs(d.rho) >= threshold &&
                d.signature === 'CytoSig' &&
                (!cytokineFilter || cytokineFilter.includes(d.protein))
            );

            // Limit to top correlations for visualization
            biochemFiltered = biochemFiltered.sort((a, b) => Math.abs(b.rho) - Math.abs(a.rho)).slice(0, 50);
            metabFiltered = metabFiltered.sort((a, b) => Math.abs(b.rho) - Math.abs(a.rho)).slice(0, 50);

            // Build nodes
            const nodesMap = new Map();

            biochemFiltered.forEach(d => {
                if (!nodesMap.has(d.protein)) nodesMap.set(d.protein, { id: d.protein, group: 'cytokine', color: '#1f77b4' });
                if (!nodesMap.has(d.feature)) nodesMap.set(d.feature, { id: d.feature, group: 'biochem', color: '#2ca02c' });
            });

            metabFiltered.forEach(d => {
                if (!nodesMap.has(d.protein)) nodesMap.set(d.protein, { id: d.protein, group: 'cytokine', color: '#1f77b4' });
                if (!nodesMap.has(d.feature)) nodesMap.set(d.feature, { id: d.feature, group: 'metabolite', color: '#ff7f0e' });
            });

            const nodes = Array.from(nodesMap.values());

            // Build edges
            const edges = [
                ...biochemFiltered.map(d => ({ source: d.protein, target: d.feature, correlation: d.rho, type: 'biochem' })),
                ...metabFiltered.map(d => ({ source: d.protein, target: d.feature, correlation: d.rho, type: 'metabolite' }))
            ];

            if (nodes.length === 0 || edges.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No correlations above threshold for selected filters</p>';
                if (summaryContainer) summaryContainer.innerHTML = '';
                return;
            }

            if (analysisType === 'correlation') {
                // D3 force-directed network
                const width = containerWidth - 40;
                const height = 500;

                const svg = d3.select(container)
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);

                const simulation = d3.forceSimulation(nodes)
                    .force('link', d3.forceLink(edges).id(d => d.id).distance(80))
                    .force('charge', d3.forceManyBody().strength(-200))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(25));

                const link = svg.append('g')
                    .selectAll('line')
                    .data(edges)
                    .enter().append('line')
                    .attr('stroke', d => d.correlation > 0 ? '#b2182b' : '#2166ac')
                    .attr('stroke-opacity', 0.6)
                    .attr('stroke-width', d => Math.abs(d.correlation) * 4);

                const node = svg.append('g')
                    .selectAll('g')
                    .data(nodes)
                    .enter().append('g')
                    .call(d3.drag()
                        .on('start', (event, d) => {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x; d.fy = d.y;
                        })
                        .on('drag', (event, d) => { d.fx = event.x; d.fy = event.y; })
                        .on('end', (event, d) => {
                            if (!event.active) simulation.alphaTarget(0);
                            d.fx = null; d.fy = null;
                        }));

                node.append('circle')
                    .attr('r', d => d.group === 'cytokine' ? 10 : 6)
                    .attr('fill', d => d.color)
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1.5);

                node.append('title').text(d => d.id);

                // Only label cytokines to reduce clutter
                node.filter(d => d.group === 'cytokine')
                    .append('text')
                    .text(d => d.id)
                    .attr('x', 12)
                    .attr('y', 4)
                    .style('font-size', '10px')
                    .style('fill', '#333');

                simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                    node.attr('transform', d => `translate(${d.x},${d.y})`);
                });

                // Add annotation
                const anno1 = svg.append('text').attr('x', 10).attr('y', height - 45).attr('font-size', '11px');
                anno1.append('tspan').attr('fill', '#666').text('Lines: ');
                anno1.append('tspan').attr('fill', '#b2182b').text('red');
                anno1.append('tspan').attr('fill', '#666').text(' = positive, ');
                anno1.append('tspan').attr('fill', '#2166ac').text('blue');
                anno1.append('tspan').attr('fill', '#666').text(' = negative');

                const anno2 = svg.append('text').attr('x', 10).attr('y', height - 28).attr('font-size', '11px');
                anno2.append('tspan').attr('fill', '#666').text('Nodes: ');
                anno2.append('tspan').attr('fill', '#1f77b4').text('blue');
                anno2.append('tspan').attr('fill', '#666').text(' = cytokine, ');
                anno2.append('tspan').attr('fill', '#2ca02c').text('green');
                anno2.append('tspan').attr('fill', '#666').text(' = biochemistry, ');
                anno2.append('tspan').attr('fill', '#ff7f0e').text('orange');
                anno2.append('tspan').attr('fill', '#666').text(' = metabolite');

                const anno3 = svg.append('text').attr('x', 10).attr('y', height - 11).attr('font-size', '11px').attr('fill', '#666');
                anno3.append('tspan').text('Line ');
                anno3.append('tspan').attr('font-weight', 'bold').text('thickness');
                anno3.append('tspan').text(' = correlation strength');

            } else if (analysisType === 'heatmap') {
                // Tri-omic heatmap - show top correlations as a table/heatmap
                const allCorr = [...biochemFiltered, ...metabFiltered].sort((a, b) => Math.abs(b.rho) - Math.abs(a.rho)).slice(0, 30);

                const trace = {
                    type: 'bar',
                    x: allCorr.map(d => d.rho),
                    y: allCorr.map(d => `${d.protein} - ${d.feature.substring(0, 15)}`),
                    orientation: 'h',
                    marker: {
                        color: allCorr.map(d => d.rho > 0 ? '#b2182b' : '#2166ac')
                    },
                    hovertemplate: '%{y}<br>œÅ = %{x:.3f}<extra></extra>'
                };

                Plotly.newPlot(container, [trace], {
                    xaxis: { title: 'Spearman œÅ', range: [-1, 1] },
                    yaxis: { automargin: true },
                    margin: { l: 180, r: 30, t: 30, b: 50 },
                    height: 500
                }, { responsive: true });
            } else {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">PCA integration requires additional preprocessing.</p>';
            }

            // Update summary
            if (summaryContainer) {
                summaryContainer.classList.remove('loading');
                const cytoBiochemCount = edges.filter(e => e.type === 'biochem').length;
                const cytoMetabCount = edges.filter(e => e.type === 'metabolite').length;
                const cytokineCount = nodes.filter(n => n.group === 'cytokine').length;
                const biochemCount = nodes.filter(n => n.group === 'biochem').length;
                const metabCount = nodes.filter(n => n.group === 'metabolite').length;

                // Get top correlations for display
                const topBiochem = biochemFiltered.slice(0, 5);
                const topMetab = metabFiltered.slice(0, 5);

                summaryContainer.innerHTML = `
                    <div style="padding: 1rem;">
                        <h4 style="margin-top: 0;">Cross-omic Summary</h4>
                        <table class="data-table">
                            <tr><th>Metric</th><th>Count</th></tr>
                            <tr><td>Cytokines</td><td>${cytokineCount}</td></tr>
                            <tr><td>Biochemistry markers</td><td>${biochemCount}</td></tr>
                            <tr><td>Metabolites</td><td>${metabCount}</td></tr>
                            <tr><td>Cytokine ‚Üî Biochemistry edges</td><td>${cytoBiochemCount}</td></tr>
                            <tr><td>Cytokine ‚Üî Metabolite edges</td><td>${cytoMetabCount}</td></tr>
                            <tr><td><strong>Total edges</strong></td><td><strong>${edges.length}</strong></td></tr>
                        </table>

                        <h4 style="margin-top: 1rem;">Top Biochemistry Correlations</h4>
                        <table class="data-table" style="font-size: 0.85rem;">
                            <tr><th>Cytokine</th><th>Marker</th><th>œÅ</th></tr>
                            ${topBiochem.map(d => `<tr><td>${d.protein}</td><td>${d.feature}</td><td style="color:${d.rho > 0 ? '#b2182b' : '#2166ac'}">${d.rho.toFixed(3)}</td></tr>`).join('')}
                        </table>

                        <h4 style="margin-top: 1rem;">Top Metabolite Correlations</h4>
                        <table class="data-table" style="font-size: 0.85rem;">
                            <tr><th>Cytokine</th><th>Metabolite</th><th>œÅ</th></tr>
                            ${topMetab.map(d => `<tr><td>${d.protein}</td><td>${d.feature.substring(0, 20)}</td><td style="color:${d.rho > 0 ? '#b2182b' : '#2166ac'}">${d.rho.toFixed(3)}</td></tr>`).join('')}
                        </table>

                        <p style="margin-top: 1rem; color: #666; font-size: 0.85rem;">
                            Showing top correlations with |œÅ| ‚â• ${threshold}
                        </p>
                    </div>
                `;
            }
        }

        // CIMA: Population Stratification
        let populationDataLoading = false;
        async function loadPopulationDataIfNeeded() {
            if (state.data.cimapopulationstratification || populationDataLoading) return;
            populationDataLoading = true;
            try {
                const response = await fetch('data/cima_population_stratification.json');
                if (response.ok) {
                    state.data.cimapopulationstratification = await response.json();
                    console.log('Population stratification data loaded from JSON');
                }
            } catch (e) {
                console.error('Failed to load population data:', e);
            }
            populationDataLoading = false;
        }

        async function updatePopulationStratification() {
            const distContainer = document.getElementById('pop-distribution');
            const effectContainer = document.getElementById('pop-effect-sizes');
            const heatmapContainer = document.getElementById('pop-heatmap');

            if (!distContainer) return;

            // Load data from JSON if not embedded
            await loadPopulationDataIfNeeded();

            const stratifyBy = document.getElementById('pop-stratify')?.value || 'sex';
            const sigType = document.getElementById('pop-sig-type')?.value || 'CytoSig';

            // Load population stratification data - structure: {CytoSig: {cytokines, groups, effect_sizes}, SecAct: {...}}
            const rawPopData = state.data.cimapopulationstratification;

            // Access data for selected signature type (CytoSig or SecAct)
            const popData = rawPopData?.[sigType] || rawPopData;

            if (!popData || !popData.effect_sizes || !popData.effect_sizes[stratifyBy]) {
                distContainer.classList.remove('loading');
                distContainer.innerHTML = '<p class="no-data-msg" style="text-align:center; padding:2rem; color:#666;">No data available for this stratification.</p>';
                if (effectContainer) { effectContainer.classList.remove('loading'); effectContainer.innerHTML = ''; }
                if (heatmapContainer) { heatmapContainer.classList.remove('loading'); heatmapContainer.innerHTML = ''; }
                return;
            }

            // Get effect sizes array for selected stratification
            const effects = popData.effect_sizes[stratifyBy];
            const groupMeans = popData.groups[stratifyBy];
            const groups = Object.keys(groupMeans || {});

            if (!effects || effects.length === 0 || groups.length === 0) {
                distContainer.classList.remove('loading');
                distContainer.innerHTML = '<p class="no-data-msg" style="text-align:center; padding:2rem; color:#666;">No effect data for this comparison.</p>';
                if (effectContainer) { effectContainer.classList.remove('loading'); effectContainer.innerHTML = ''; }
                if (heatmapContainer) { heatmapContainer.classList.remove('loading'); heatmapContainer.innerHTML = ''; }
                return;
            }

            // Get sample counts from first effect record
            const firstEffect = effects[0];
            const n1 = firstEffect.n_male || firstEffect.n_young || firstEffect.n_normal || 100;
            const n2 = firstEffect.n_female || firstEffect.n_older || firstEffect.n_obese || 100;

            // Define stratification labels and colors
            const stratLabels = {
                'sex': 'Sex', 'age': 'Age Group', 'bmi': 'BMI Category',
                'blood_type': 'Blood Type', 'smoking': 'Smoking Status'
            };
            const pieColors = {
                'sex': ['#e377c2', '#1f77b4'],
                'age': ['#2ca02c', '#ff7f0e', '#9467bd'],
                'bmi': ['#2ca02c', '#ff7f0e', '#d62728', '#9467bd'],
                'blood_type': ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'],
                'smoking': ['#2ca02c', '#ff7f0e', '#d62728']
            };
            const compLabels = {
                'sex': 'Male vs Female', 'age': 'Older vs Young', 'bmi': 'Obese vs Normal',
                'blood_type': 'Blood Type Comparison', 'smoking': 'Smoker vs Non-Smoker'
            };

            // Estimate group counts based on first effect
            const groupCounts = groups.map((g, i) => {
                if (i === 0) return n1;
                if (i === 1) return n2;
                return Math.round((n1 + n2) / 2);
            });

            // 1. Distribution pie chart
            distContainer.classList.remove('loading');
            Plotly.purge(distContainer);
            Plotly.newPlot(distContainer, [{
                type: 'pie',
                labels: groups,
                values: groupCounts,
                textinfo: 'label+percent',
                marker: { colors: pieColors[stratifyBy] || d3.schemeTableau10 },
                hovertemplate: '<b>%{label}</b><br>N ‚âà %{value}<br>%{percent}<extra></extra>'
            }], {
                margin: { l: 30, r: 30, t: 40, b: 30 },
                height: 350,
                title: { text: `Sample Distribution by ${stratLabels[stratifyBy] || stratifyBy}`, font: { size: 14 } }
            }, { responsive: true });

            // 2. Effect sizes - Top 10 + Bottom 10 + always IFNG/TNFA
            if (effectContainer) {
                effectContainer.classList.remove('loading');
                Plotly.purge(effectContainer);

                // Sort by effect size (positive to negative)
                const sortedByEffect = [...effects].sort((a, b) => b.effect - a.effect);

                // Get top 10 (most positive) and bottom 10 (most negative)
                const top10 = sortedByEffect.slice(0, 10);
                const bottom10 = sortedByEffect.slice(-10);

                // Always include IFNG and TNF/TNFA
                const alwaysInclude = ['IFNG', 'TNFA', 'TNF'];
                const mustHave = effects.filter(d => alwaysInclude.includes((d.cytokine || '').toUpperCase()));

                // Combine and deduplicate
                const combined = new Map();
                [...top10, ...bottom10, ...mustHave].forEach(d => combined.set(d.cytokine, d));

                // Sort final list by effect size
                const selectedEffects = Array.from(combined.values()).sort((a, b) => b.effect - a.effect);

                const effectSigs = selectedEffects.map(d => d.cytokine);
                const effectVals = selectedEffects.map(d => d.effect);
                const pvals = selectedEffects.map(d => d.pvalue);

                Plotly.newPlot(effectContainer, [{
                    type: 'bar',
                    orientation: 'h',
                    y: effectSigs,
                    x: effectVals,
                    marker: {
                        color: effectVals.map((e, i) => pvals[i] < 0.05 ? (e > 0 ? '#f4a6a6' : '#a8d4e6') : '#ccc')
                    },
                    text: pvals.map(p => p < 0.001 ? '***' : p < 0.01 ? '**' : p < 0.05 ? '*' : ''),
                    textposition: 'outside',
                    hovertemplate: '<b>%{y}</b><br>Effect: %{x:.3f}<br>p = %{customdata:.2e}<extra></extra>',
                    customdata: pvals
                }], {
                    xaxis: { title: `Effect Size (${compLabels[stratifyBy] || stratifyBy})`, zeroline: true },
                    yaxis: { automargin: true },
                    margin: { l: 120, r: 60, t: 40, b: 50 },
                    height: Math.max(400, selectedEffects.length * 18),
                    title: { text: `Cytokine Variance by ${stratLabels[stratifyBy] || stratifyBy}`, font: { size: 14 } },
                    annotations: [{
                        x: 0.95, y: 1.02, xref: 'paper', yref: 'paper',
                        text: '* p<0.05, ** p<0.01, *** p<0.001', showarrow: false, font: { size: 10 }
                    }]
                }, { responsive: true });
            }

            // 3. Population heatmap - use selected signatures
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                // Use same signatures from effect chart for heatmap
                const sortedByEffect = [...effects].sort((a, b) => b.effect - a.effect);
                const top10 = sortedByEffect.slice(0, 10);
                const bottom10 = sortedByEffect.slice(-10);
                const alwaysInclude = ['IFNG', 'TNFA', 'TNF'];
                const mustHave = effects.filter(d => alwaysInclude.includes((d.cytokine || '').toUpperCase()));
                const combined = new Map();
                [...top10, ...bottom10, ...mustHave].forEach(d => combined.set(d.cytokine, d));
                const heatmapSigs = Array.from(combined.values()).sort((a, b) => b.effect - a.effect).map(d => d.cytokine);

                // Build z-matrix from group means
                const zData = groups.map(group => {
                    return heatmapSigs.map(sig => groupMeans[group]?.[sig] ?? 0);
                });

                // Calculate z-score range for colorscale
                const allValues = zData.flat();
                const maxAbs = Math.max(...allValues.map(Math.abs), 1);

                Plotly.newPlot(heatmapContainer, [{
                    type: 'heatmap',
                    z: zData,
                    x: heatmapSigs,
                    y: groups,
                    colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                    zmid: 0,
                    zmin: -maxAbs,
                    zmax: maxAbs,
                    colorbar: { title: 'Mean Activity<br>(z-score)' },
                    hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.3f}<extra></extra>'
                }], {
                    margin: { l: 120, r: 50, t: 40, b: 120 },
                    xaxis: { tickangle: 45, title: 'Cytokine' },
                    yaxis: { title: stratLabels[stratifyBy] || stratifyBy },
                    height: 400,
                    title: { text: `Activity by ${stratLabels[stratifyBy] || stratifyBy}`, font: { size: 14 } }
                }, { responsive: true });
            }
        }

        // CIMA: eQTL Browser - uses embedded top 500 eQTLs by default for fast initial load
        let eqtlFullDataLoaded = false;

        async function loadFullEqtlData() {
            if (eqtlFullDataLoaded) return;

            const btn = document.getElementById('eqtl-load-full');
            const countDisplay = document.getElementById('eqtl-count-display');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Loading full data (~14 MB)...';
            }

            try {
                const response = await fetch('data/cima_eqtl.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                state.data.cimaeqtl = await response.json();
                eqtlFullDataLoaded = true;
                console.log('Full eQTL data loaded:', state.data.cimaeqtl.summary);
                if (btn) btn.textContent = 'Full data loaded (71,530 eQTLs)';
                if (countDisplay) countDisplay.textContent = 'Showing all 71,530 eQTLs';
                populateEqtlCellTypes();
                updateEqtlBrowser();
            } catch (error) {
                console.error('Error loading full eQTL data:', error);
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Load failed - use HTTP server';
                    btn.title = error.message + '. File:// protocol does not support fetch. Use: python -m http.server';
                }
            }
        }

        async function updateEqtlBrowser() {
            const manhattanContainer = document.getElementById('eqtl-manhattan');
            const tableContainer = document.getElementById('eqtl-table');
            const effectContainer = document.getElementById('eqtl-effect-plot');

            if (!manhattanContainer) return;

            // Auto-load eQTL data if not embedded
            if (!state.data.cimaeqtl && !eqtlFullDataLoaded) {
                manhattanContainer.innerHTML = '<p style="text-align:center; padding:2rem;">Loading eQTL data...</p>';
                await loadFullEqtlData();
            }

            // Check if eQTL data is available (embedded top 10K or full)
            if (!state.data.cimaeqtl) {
                manhattanContainer.innerHTML = '<p style="text-align:center; color:#d62728; padding:2rem;">eQTL data not available.<br><small>Make sure to serve via HTTP server (python -m http.server)</small></p>';
                return;
            }

            const searchTerm = document.getElementById('eqtl-search')?.value || '';
            const cellType = document.getElementById('eqtl-type')?.value || 'all';
            const threshold = parseFloat(document.getElementById('eqtl-threshold')?.value || '1e-5');

            const eqtlData = state.data.cimaeqtl;

            // Show summary stats
            const summary = eqtlData.summary;

            // Filter eQTLs
            let filtered = eqtlData.eqtls.filter(d => d.pvalue < threshold);
            if (cellType !== 'all') {
                filtered = filtered.filter(d => d.celltype === cellType);
            }
            if (searchTerm) {
                const term = searchTerm.toLowerCase();
                filtered = filtered.filter(d =>
                    d.gene.toLowerCase().includes(term) ||
                    d.variant.toLowerCase().includes(term)
                );
            }

            const chromosomes = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','X','Y'];

            // 1. Manhattan plot
            manhattanContainer.classList.remove('loading');
            Plotly.purge(manhattanContainer);

            if (filtered.length === 0) {
                manhattanContainer.innerHTML = `
                    <p style="text-align:center; color:#666; padding:2rem;">
                        No eQTLs found matching criteria.<br>
                        <small>Total: ${summary.total_eqtls.toLocaleString()} cis-eQTLs across ${summary.n_cell_types} cell types</small>
                    </p>`;
            } else {
                // Calculate cumulative positions for Manhattan plot
                const chrLengths = {};
                chromosomes.forEach(chr => { chrLengths[chr] = 250000000; });
                let cumPos = 0;
                const chrOffsets = {};
                chromosomes.forEach(chr => {
                    chrOffsets[chr] = cumPos;
                    cumPos += chrLengths[chr];
                });

                const xPositions = filtered.map(d => (chrOffsets[d.chr] || 0) + (d.pos || 0));
                const yValues = filtered.map(d => -Math.log10(d.pvalue));
                const colors = filtered.map(d => chromosomes.indexOf(d.chr) % 2 === 0 ? '#1f77b4' : '#ff7f0e');

                Plotly.newPlot(manhattanContainer, [{
                    type: 'scatter',
                    mode: 'markers',
                    x: xPositions,
                    y: yValues,
                    text: filtered.map(d => `<b>${d.gene}</b><br>${d.variant}<br>Cell: ${d.celltype}<br>p=${d.pvalue.toExponential(2)}<br>Œ≤=${d.beta.toFixed(3)}`),
                    marker: { color: colors, size: 6, opacity: 0.7 },
                    hoverinfo: 'text'
                }], {
                    xaxis: {
                        title: 'Chromosome',
                        tickvals: chromosomes.slice(0, 22).map(c => chrOffsets[c] + chrLengths[c] / 2),
                        ticktext: chromosomes.slice(0, 22),
                        showgrid: false
                    },
                    yaxis: { title: '-log10(p-value)' },
                    shapes: [{
                        type: 'line',
                        x0: 0, x1: cumPos, y0: -Math.log10(5e-8), y1: -Math.log10(5e-8),
                        line: { dash: 'dash', color: '#d62728', width: 1 }
                    }],
                    margin: { l: 60, r: 30, t: 40, b: 50 },
                    height: 400,
                    title: { text: `cis-eQTLs (${filtered.length.toLocaleString()} shown, ${summary.total_eqtls.toLocaleString()} total)`, font: { size: 14 } }
                }, { responsive: true });
            }

            // 2. Top eQTL table
            if (tableContainer) {
                tableContainer.classList.remove('loading');
                const topHits = [...filtered].sort((a, b) => a.pvalue - b.pvalue).slice(0, 15);

                if (topHits.length === 0) {
                    tableContainer.innerHTML = '<p style="text-align:center; color:#666; padding:1rem;">No results</p>';
                } else {
                    tableContainer.innerHTML = `
                        <div style="max-height: 450px; overflow-y: auto;">
                            <table class="data-table" style="font-size: 0.85rem;">
                                <thead>
                                    <tr><th>Gene</th><th>Variant</th><th>Cell Type</th><th>P-value</th><th>Beta</th><th>AF</th></tr>
                                </thead>
                                <tbody>
                                    ${topHits.map(d => `
                                        <tr>
                                            <td><strong>${d.gene}</strong></td>
                                            <td style="font-size:0.8rem;">${d.variant}</td>
                                            <td style="font-size:0.8rem;">${d.celltype.replace(/_/g, ' ')}</td>
                                            <td>${d.pvalue.toExponential(2)}</td>
                                            <td style="color: ${d.beta > 0 ? '#d62728' : '#1f77b4'}">${d.beta.toFixed(3)}</td>
                                            <td>${d.af !== undefined ? d.af.toFixed(3) : 'N/A'}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        <p style="margin-top: 0.5rem; color: #666; font-size: 0.85rem;">
                            Showing top ${topHits.length} of ${filtered.length.toLocaleString()} filtered eQTLs
                        </p>
                    `;
                }
            }

            // 3. Cell type distribution
            if (effectContainer) {
                effectContainer.classList.remove('loading');
                Plotly.purge(effectContainer);

                // Count eQTLs per cell type
                const ctCounts = {};
                filtered.forEach(d => {
                    ctCounts[d.celltype] = (ctCounts[d.celltype] || 0) + 1;
                });

                const sortedCts = Object.entries(ctCounts)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 15);

                if (sortedCts.length > 0) {
                    Plotly.newPlot(effectContainer, [{
                        type: 'bar',
                        orientation: 'h',
                        y: sortedCts.map(d => d[0].replace(/_/g, ' ')),
                        x: sortedCts.map(d => d[1]),
                        marker: { color: '#1f77b4' },
                        hovertemplate: '<b>%{y}</b><br>%{x} eQTLs<extra></extra>'
                    }], {
                        xaxis: { title: 'Number of eQTLs' },
                        yaxis: { automargin: true },
                        margin: { l: 150, r: 30, t: 40, b: 50 },
                        height: 350,
                        title: { text: 'eQTLs by Cell Type', font: { size: 14 } }
                    }, { responsive: true });
                } else {
                    effectContainer.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data for cell type distribution</p>';
                }
            }
        }

        // Populate eQTL cell type dropdown
        function populateEqtlCellTypes() {
            const select = document.getElementById('eqtl-type');
            const eqtlData = state.data.cimaeqtl;
            if (!select || !eqtlData || !eqtlData.cell_types) return;

            select.innerHTML = '<option value="all">All Cell Types</option>' +
                eqtlData.cell_types.map(ct =>
                    `<option value="${ct}">${ct.replace(/_/g, ' ')}</option>`
                ).join('');
        }

        // Inflammation Atlas Age/BMI correlation functions
        function updateInflamCorrelations() {
            const data = state.data.inflammationcorrelations;
            if (!data) {
                const ageContainer = document.getElementById('inflam-age-lollipop');
                const bmiContainer = document.getElementById('inflam-bmi-lollipop');
                if (ageContainer) {
                    ageContainer.classList.remove('loading');
                    ageContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Age/BMI correlation data not yet available.</p>';
                }
                if (bmiContainer) {
                    bmiContainer.classList.remove('loading');
                    bmiContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Age/BMI correlation data not yet available.</p>';
                }
                return;
            }

            const sigType = document.getElementById('inflam-corr-sig-type')?.value || 'CytoSig';

            // Helper: get top 10 + bottom 10 correlations
            function getTopBottom(dataArr, sigFilter) {
                const filtered = dataArr.filter(d => d.signature === sigFilter);
                filtered.sort((a, b) => b.rho - a.rho);
                const top10 = filtered.slice(0, 10);
                const bottom10 = filtered.slice(-10);
                return [...top10, ...bottom10];
            }

            if (sigType === 'both') {
                // Show CytoSig and SecAct side by side
                const ageCytoSig = getTopBottom(data.age, 'CytoSig');
                const ageSecAct = getTopBottom(data.age, 'SecAct');
                createInflamDualChart('inflam-age-lollipop', ageCytoSig, ageSecAct, 'Age');

                const bmiCytoSig = getTopBottom(data.bmi, 'CytoSig');
                const bmiSecAct = getTopBottom(data.bmi, 'SecAct');
                createInflamDualChart('inflam-bmi-lollipop', bmiCytoSig, bmiSecAct, 'BMI');
            } else {
                const ageData = getTopBottom(data.age, sigType);
                createInflamDualChart('inflam-age-lollipop', ageData, [], 'Age');

                const bmiData = getTopBottom(data.bmi, sigType);
                createInflamDualChart('inflam-bmi-lollipop', bmiData, [], 'BMI');
            }
        }

        function createInflamDualChart(containerId, primaryData, secondaryData, title) {
            const container = document.getElementById(containerId);
            if (!container) return;

            container.classList.remove('loading');
            Plotly.purge(container);

            if (!primaryData || primaryData.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No correlation data available</p>';
                return;
            }

            const hasBoth = secondaryData && secondaryData.length > 0;
            let combinedY = [], combinedX = [], combinedColors = [], combinedText = [];

            if (hasBoth) {
                // SecAct section (bottom)
                const secActReversed = [...secondaryData].reverse();
                for (const d of secActReversed) {
                    combinedY.push(d.protein + ' (SecAct)');
                    combinedX.push(d.rho);
                    combinedColors.push(d.rho > 0 ? '#f4a6a6' : '#a8d4e6');
                    combinedText.push(d.rho?.toFixed(3) || 'N/A');
                }

                // Separator
                combinedY.push('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
                combinedX.push(0);
                combinedColors.push('#ffffff');
                combinedText.push('');

                // CytoSig section (top)
                const cytoSigReversed = [...primaryData].reverse();
                for (const d of cytoSigReversed) {
                    combinedY.push(d.protein + ' (CytoSig)');
                    combinedX.push(d.rho);
                    combinedColors.push(d.rho > 0 ? '#f4a6a6' : '#a8d4e6');
                    combinedText.push(d.rho?.toFixed(3));
                }
            } else {
                // Single signature type
                const reversed = [...primaryData].reverse();
                for (const d of reversed) {
                    combinedY.push(d.protein);
                    combinedX.push(d.rho);
                    combinedColors.push(d.rho > 0 ? '#f4a6a6' : '#a8d4e6');
                    combinedText.push(d.rho?.toFixed(3));
                }
            }

            const maxAbs = Math.max(...combinedX.filter(x => x !== 0).map(x => Math.abs(x)), 0.3);

            Plotly.newPlot(container, [{
                y: combinedY,
                x: combinedX,
                type: 'bar',
                orientation: 'h',
                marker: { color: combinedColors },
                text: combinedText,
                textposition: combinedX.map(x => Math.abs(x) < 0.1 ? 'outside' : 'inside'),
                textfont: { size: 9, color: '#333' },
                hovertemplate: '<b>%{y}</b><br>œÅ = %{x:.3f}<extra></extra>'
            }], {
                margin: {l: 150, r: 50, t: 30, b: 50},
                xaxis: {title: 'Spearman œÅ', zeroline: true, zerolinecolor: '#ccc', range: [-maxAbs - 0.1, maxAbs + 0.1]},
                yaxis: {automargin: true},
                height: hasBoth ? 600 : 550
            }, {responsive: true});
        }

        // Inflammation Atlas Cell Type-Specific Correlation Heatmap
        function updateInflamCelltypeCorrelationHeatmap() {
            const container = document.getElementById('inflam-celltype-corr-heatmap');
            if (!container) return;
            container.classList.remove('loading');

            const sigType = document.getElementById('inflam-ct-corr-sigtype')?.value || 'CytoSig';
            const feature = document.getElementById('inflam-ct-corr-feature')?.value || 'age';
            const metric = document.getElementById('inflam-ct-corr-metric')?.value || 'rho';

            // Get data - structure is {age: [...], bmi: [...]} with signature field in records
            const corrData = state.data.inflammationcelltypecorrelations;
            if (!corrData || !corrData[feature]) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Cell type correlation data not available. Run preprocessing to generate.</p>';
                return;
            }

            // Filter by signature type
            const allData = corrData[feature];
            const dataArray = allData.filter(d => d.signature === sigType);

            if (!dataArray || dataArray.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available for this signature type.</p>';
                return;
            }

            // Extract unique cell types and proteins from filtered data
            const cellTypes = [...new Set(dataArray.map(d => d.cell_type))].sort();
            const proteins = [...new Set(dataArray.map(d => d.protein))].sort();
            const nSig = dataArray.filter(d => d.qvalue < 0.05).length;

            // Update title
            const titleEl = document.getElementById('inflam-ct-corr-title');
            const subtitle = sigType === 'SecAct' ? ` (${proteins.length} proteins)` : ` (${proteins.length} cytokines)`;
            if (titleEl) titleEl.textContent = `${feature === 'age' ? 'Age' : 'BMI'} Correlation by Cell Type - ${sigType}${subtitle} - ${nSig} significant`;

            // Filter significant only if selected
            let filteredData = dataArray;
            if (metric === 'sig') {
                filteredData = dataArray.filter(d => d.qvalue < 0.05);
            }

            // Create lookup map for fast access
            const dataMap = {};
            dataArray.forEach(d => {
                const key = `${d.cell_type}|${d.protein}`;
                dataMap[key] = d;
            });

            // Create matrix for heatmap
            const zValues = [];
            const hoverText = [];

            for (const ct of cellTypes) {
                const row = [];
                const hoverRow = [];
                for (const protein of proteins) {
                    const key = `${ct}|${protein}`;
                    const record = dataMap[key];
                    if (record) {
                        if (metric === 'sig' && record.qvalue >= 0.05) {
                            row.push(null);
                            hoverRow.push(`${ct}<br>${protein}<br>Not significant (q=${record.qvalue.toFixed(4)})`);
                        } else {
                            row.push(record.rho);
                            const sig = record.qvalue < 0.05 ? ' *' : '';
                            hoverRow.push(`<b>${ct}</b><br>${protein}<br>œÅ = ${record.rho.toFixed(3)}${sig}<br>q = ${record.qvalue?.toFixed(4) || 'N/A'}<br>n = ${record.n}`);
                        }
                    } else {
                        row.push(null);
                        hoverRow.push(`${ct}<br>${protein}<br>No data`);
                    }
                }
                zValues.push(row);
                hoverText.push(hoverRow);
            }

            // Adjust font size based on number of proteins
            const xTickSize = proteins.length > 50 ? 7 : 10;
            const height = sigType === 'SecAct' ? 800 : 700;

            const trace = {
                z: zValues,
                x: proteins,
                y: cellTypes,
                type: 'heatmap',
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                zmid: 0,
                zmin: -0.6,
                zmax: 0.6,
                hoverinfo: 'text',
                text: hoverText,
                colorbar: {
                    title: 'Spearman œÅ',
                    titleside: 'right'
                }
            };

            Plotly.newPlot(container, [trace], {
                xaxis: { title: sigType === 'CytoSig' ? 'Cytokine' : 'Secreted Protein', tickangle: 45, tickfont: { size: xTickSize } },
                yaxis: { title: 'Cell Type', tickfont: { size: 9 } },
                margin: { t: 30, b: 150, l: 180, r: 80 },
                height: height
            }, { responsive: true });
        }

        // Inflammation Atlas Age/BMI Stratified functions
        let inflamBoxplotSignatures = { cytosig: [], secact: [] };

        async function initInflamBoxplotSignatures() {
            await loadBoxplotDataIfNeeded();
            const data = state.data.agebmiboxplots?.inflammation;
            if (!data) return;
            inflamBoxplotSignatures.cytosig = data.cytosig_signatures || [];
            inflamBoxplotSignatures.secact = data.secact_signatures || [];

            // Populate cell type dropdown from actual data (not metadata which may be incomplete)
            const ageData = data.age || [];
            const cellTypesFromData = [...new Set(ageData.map(d => d.cell_type).filter(ct => ct))].sort();
            // Ensure 'All' is first
            const cellTypes = ['All', ...cellTypesFromData.filter(ct => ct !== 'All')];

            const select = document.getElementById('inflam-boxplot-celltype');
            if (select) {
                select.innerHTML = cellTypes.map(ct =>
                    `<option value="${ct}"${ct === 'All' ? ' selected' : ''}>${ct}${ct === 'All' ? ' (sample-level)' : ''}</option>`
                ).join('');
            }
        }

        function getInflamBoxplotSignatures() {
            const sigType = document.getElementById('inflam-boxplot-sig-type')?.value || 'CytoSig';
            if (sigType === 'SecAct') return inflamBoxplotSignatures.secact;
            if (sigType === 'both') {
                // Return signatures present in both CytoSig and SecAct
                const cytosigSet = new Set(inflamBoxplotSignatures.cytosig);
                return inflamBoxplotSignatures.secact.filter(s => cytosigSet.has(s));
            }
            return inflamBoxplotSignatures.cytosig;
        }

        function showInflamBoxplotSuggestions() {
            const input = document.getElementById('inflam-boxplot-search');
            const div = document.getElementById('inflam-boxplot-suggestions');
            if (!input || !div) return;

            const query = input.value.toLowerCase();
            const sigs = getInflamBoxplotSignatures();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query)).slice(0, 15);

            if (filtered.length === 0) { div.style.display = 'none'; return; }

            div.innerHTML = filtered.map(s =>
                `<div style="padding:6px 10px;cursor:pointer;border-bottom:1px solid #eee"
                     onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'"
                     onclick="selectInflamBoxplotSig('${s}')">${s}</div>`
            ).join('');
            div.style.display = 'block';
        }

        function selectInflamBoxplotSig(sig) {
            document.getElementById('inflam-boxplot-search').value = sig;
            document.getElementById('inflam-boxplot-suggestions').style.display = 'none';
            updateInflamStratifiedBoxplot();
            updateInflamCelltypeStratifiedHeatmap();
        }

        async function updateInflamStratifiedBoxplot() {
            const container = document.getElementById('inflam-stratified-boxplot');
            if (!container) return;

            const stratifyBy = document.getElementById('inflam-stratify-by')?.value || 'age';
            const sigType = document.getElementById('inflam-boxplot-sig-type')?.value || 'CytoSig';
            const signature = document.getElementById('inflam-boxplot-search')?.value || 'IFNG';
            const cellType = document.getElementById('inflam-boxplot-celltype')?.value || 'All';

            // Update titles
            const titleEl = document.getElementById('inflam-boxplot-title');
            const subtitleEl = document.getElementById('inflam-boxplot-subtitle');
            const cellTypeLabel = cellType === 'All' ? '' : ` in ${cellType}`;
            if (titleEl) titleEl.textContent = `${stratifyBy === 'age' ? 'Age' : 'BMI'}-Stratified ${signature} Activity${cellTypeLabel}`;
            if (subtitleEl) subtitleEl.textContent = sigType === 'both'
                ? `CytoSig vs SecAct activity across ${stratifyBy === 'age' ? 'age decades' : 'BMI categories'}${cellTypeLabel}`
                : `${sigType} activity distribution across ${stratifyBy === 'age' ? 'age decades' : 'BMI categories'}${cellTypeLabel}`;

            // Show loading for SecAct (lazy loaded)
            if (sigType === 'SecAct' && !state.boxplotLoaded.secact) {
                container.innerHTML = '<div class="loading">Loading SecAct data...</div>';
            }

            // Get boxplot data (async for SecAct)
            const boxplotData = await getBoxplotData('inflammation', sigType);
            container.classList.remove('loading');

            if (!boxplotData || !boxplotData[stratifyBy]) {
                container.innerHTML = '<p style="text-align:center;color:#666;padding:2rem;">No data available for this signature</p>';
                return;
            }

            const bins = stratifyBy === 'age'
                ? ['<30', '30-39', '40-49', '50-59', '60-69', '70+']
                : ['Underweight', 'Normal', 'Overweight', 'Obese'];

            // Handle "both" mode - show CytoSig and SecAct side by side
            if (sigType === 'both') {
                const cytosigData = boxplotData[stratifyBy].filter(d =>
                    d.signature === signature && d.sig_type === 'CytoSig' && d.cell_type === cellType
                );
                const secactData = boxplotData[stratifyBy].filter(d =>
                    d.signature === signature && d.sig_type === 'SecAct' && d.cell_type === cellType
                );

                if (cytosigData.length === 0 && secactData.length === 0) {
                    container.innerHTML = '<p style="text-align:center;color:#666;padding:2rem;">No data available for this selection</p>';
                    return;
                }

                const traces = [];
                bins.forEach((bin, i) => {
                    const cytoD = cytosigData.find(d => d.bin === bin);
                    const secD = secactData.find(d => d.bin === bin);

                    if (cytoD) {
                        traces.push({
                            y: cytoD.values || generateBoxplotValues(cytoD),
                            type: 'box',
                            name: `${bin}`,
                            legendgroup: 'CytoSig',
                            boxpoints: cytoD.values ? 'outliers' : false,
                            marker: { color: '#1f77b4' },
                            offsetgroup: 'CytoSig',
                            hovertemplate: `CytoSig ${bin}<br>median: ${cytoD.median?.toFixed(2) || 'N/A'}<br>n: ${cytoD.n || 'N/A'}<extra></extra>`
                        });
                    }
                    if (secD) {
                        traces.push({
                            y: secD.values || generateBoxplotValues(secD),
                            type: 'box',
                            name: `${bin}`,
                            legendgroup: 'SecAct',
                            boxpoints: secD.values ? 'outliers' : false,
                            marker: { color: '#ff7f0e' },
                            offsetgroup: 'SecAct',
                            hovertemplate: `SecAct ${bin}<br>median: ${secD.median?.toFixed(2) || 'N/A'}<br>n: ${secD.n || 'N/A'}<extra></extra>`
                        });
                    }
                });

                Plotly.newPlot(container, traces, {
                    yaxis: { title: `${signature} Activity Score${cellTypeLabel}`, zeroline: true },
                    xaxis: { title: stratifyBy === 'age' ? 'Age Group' : 'BMI Category' },
                    boxmode: 'group',
                    showlegend: true,
                    legend: { title: { text: 'Signature Type' } },
                    margin: { t: 30, b: 60, l: 60, r: 30 },
                    height: 450,
                    annotations: [{
                        x: 0.25, y: 1.08, xref: 'paper', yref: 'paper',
                        text: '<b style="color:#1f77b4">‚ñ†</b> CytoSig',
                        showarrow: false, font: { size: 12 }
                    }, {
                        x: 0.45, y: 1.08, xref: 'paper', yref: 'paper',
                        text: '<b style="color:#ff7f0e">‚ñ†</b> SecAct',
                        showarrow: false, font: { size: 12 }
                    }]
                }, { responsive: true });
                return;
            }

            // Single signature type mode
            let sigData = boxplotData[stratifyBy].filter(d =>
                d.signature === signature &&
                d.sig_type === sigType &&
                d.cell_type === cellType
            );

            if (sigData.length === 0) {
                container.innerHTML = '<p style="text-align:center;color:#666;padding:2rem;">No data available for this selection</p>';
                return;
            }

            // Sort by bin order
            sigData.sort((a, b) => bins.indexOf(a.bin) - bins.indexOf(b.bin));

            const traces = sigData.map((d, i) => ({
                y: d.values || generateBoxplotValues(d),
                type: 'box',
                name: d.bin,
                boxpoints: d.values ? 'outliers' : false,
                marker: { color: d3.schemeTableau10[i % 10] },
                hovertemplate: `${d.bin}<br>median: ${d.median?.toFixed(2) || 'N/A'}<br>n: ${d.n || 'N/A'}<extra></extra>`
            }));

            if (traces.length === 0) {
                container.innerHTML = '<p style="text-align:center;color:#666;padding:2rem;">No data available for selected bins</p>';
                return;
            }

            Plotly.newPlot(container, traces, {
                yaxis: { title: `${signature} Activity Score`, zeroline: true },
                xaxis: { title: stratifyBy === 'age' ? 'Age Group' : 'BMI Category' },
                showlegend: false,
                margin: { t: 30, b: 60, l: 60, r: 30 },
                height: 450
            }, { responsive: true });
        }

        async function updateInflamCelltypeStratifiedHeatmap() {
            const container = document.getElementById('inflam-celltype-stratified-heatmap');
            if (!container) return;

            const stratifyBy = document.getElementById('inflam-stratify-by')?.value || 'age';
            const sigType = document.getElementById('inflam-boxplot-sig-type')?.value || 'CytoSig';
            const signature = document.getElementById('inflam-boxplot-search')?.value || 'IFNG';

            // Update titles
            const titleEl = document.getElementById('inflam-celltype-stratified-title');
            const subtitleEl = document.getElementById('inflam-celltype-stratified-subtitle');
            if (titleEl) titleEl.textContent = `Cell Type-Specific ${signature} Activity`;
            if (subtitleEl) subtitleEl.textContent = `Median activity across cell types and ${stratifyBy === 'age' ? 'age groups' : 'BMI categories'}`;

            // Get boxplot data (async for SecAct)
            const boxplotData = await getBoxplotData('inflammation', sigType);
            container.classList.remove('loading');

            if (!boxplotData || !boxplotData[stratifyBy]) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Data not available</p>';
                return;
            }

            // Get bins
            const bins = stratifyBy === 'age'
                ? (boxplotData.age_bins || ['<30', '30-39', '40-49', '50-59', '60-69', '70+'])
                : (boxplotData.bmi_bins || ['Underweight', 'Normal', 'Overweight', 'Obese']);

            // Filter data for this signature
            let sigData = boxplotData[stratifyBy].filter(d =>
                d.signature === signature &&
                d.sig_type === (sigType === 'both' ? 'CytoSig' : sigType)
            );

            // Get unique cell types (excluding 'All' and undefined/null for sample-level records)
            const cellTypes = [...new Set(sigData.map(d => d.cell_type))].filter(ct => ct && ct !== 'All').sort();

            if (cellTypes.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No cell type data available for this signature</p>';
                return;
            }

            // Build matrix: cell types √ó bins
            const z = [];
            const hoverText = [];
            for (const ct of cellTypes) {
                const row = [];
                const hoverRow = [];
                for (const bin of bins) {
                    const record = sigData.find(d => d.cell_type === ct && d.bin === bin);
                    const median = record ? record.median : null;
                    row.push(median);
                    hoverRow.push(record
                        ? `${ct}<br>${bin}<br>Median: ${median?.toFixed(2)}<br>n=${record.n}`
                        : `${ct}<br>${bin}<br>No data`
                    );
                }
                z.push(row);
                hoverText.push(hoverRow);
            }

            // Find min/max for symmetric colorscale
            const allValues = z.flat().filter(v => v !== null);
            if (allValues.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data available for selected options</p>';
                return;
            }
            const maxAbs = Math.max(Math.abs(Math.min(...allValues)), Math.abs(Math.max(...allValues)));

            Plotly.newPlot(container, [{
                type: 'heatmap',
                z: z,
                x: bins,
                y: cellTypes,
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                zmin: -maxAbs,
                zmax: maxAbs,
                hoverinfo: 'text',
                text: hoverText,
                colorbar: {
                    title: 'Median Activity',
                    titleside: 'right'
                }
            }], {
                xaxis: {
                    title: stratifyBy === 'age' ? 'Age Group' : 'BMI Category',
                    side: 'bottom'
                },
                yaxis: {
                    title: 'Cell Type',
                    automargin: true
                },
                margin: { t: 30, b: 80, l: 180, r: 80 },
                height: Math.max(400, cellTypes.length * 18 + 120)
            }, { responsive: true });
        }

        // Inflammation Atlas Disease functions
        let inflamDiseaseSignatures = { cytosig: [], secact: [] };

        function updateInflamDisease() {
            const data = state.data.inflammationdisease;
            if (!data) {
                // Show placeholder
                const barContainer = document.getElementById('inflam-disease-bar');
                const heatmapContainer = document.getElementById('inflam-disease-heatmap');
                if (barContainer) {
                    barContainer.classList.remove('loading');
                    barContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Disease activity data not yet available. Running preprocessing...</p>';
                }
                if (heatmapContainer) {
                    heatmapContainer.classList.remove('loading');
                    heatmapContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Disease activity data not yet available. Running preprocessing...</p>';
                }
                return;
            }
            initInflamDiseaseSignatures();
            populateInflamDiseaseGroups();
            updateInflamDiseaseBar();
            updateInflamDiseaseHeatmap();
        }

        function initInflamDiseaseSignatures() {
            const data = state.data.inflammationdisease;
            if (!data) return;

            // Group signatures by type
            inflamDiseaseSignatures.cytosig = [...new Set(
                data.filter(d => d.signature_type === 'CytoSig').map(d => d.signature)
            )].sort();
            inflamDiseaseSignatures.secact = [...new Set(
                data.filter(d => d.signature_type === 'SecAct').map(d => d.signature)
            )].sort();

            // Fallback: if no signature_type field, assume all are CytoSig
            if (inflamDiseaseSignatures.cytosig.length === 0 && inflamDiseaseSignatures.secact.length === 0) {
                inflamDiseaseSignatures.cytosig = [...new Set(data.map(d => d.signature))].sort();
            }
        }

        function getInflamDiseaseSignatures() {
            const sigType = document.getElementById('inflam-disease-sig-type')?.value || 'CytoSig';
            return sigType === 'SecAct' ? inflamDiseaseSignatures.secact : inflamDiseaseSignatures.cytosig;
        }

        function showInflamDiseaseSuggestions() {
            const input = document.getElementById('inflam-disease-search');
            const div = document.getElementById('inflam-disease-suggestions');
            if (!input || !div) return;

            const query = input.value.toLowerCase();
            const sigs = getInflamDiseaseSignatures();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query)).slice(0, 15);

            if (filtered.length === 0) { div.style.display = 'none'; return; }

            div.innerHTML = filtered.map(s =>
                `<div style="padding:6px 10px;cursor:pointer;border-bottom:1px solid #eee"
                     onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'"
                     onclick="selectInflamDiseaseSig('${s}')">${s}</div>`
            ).join('');
            div.style.display = 'block';
        }

        function selectInflamDiseaseSig(sig) {
            const input = document.getElementById('inflam-disease-search');
            const div = document.getElementById('inflam-disease-suggestions');
            if (input) input.value = sig;
            if (div) div.style.display = 'none';
            updateInflamDiseaseBar();
        }

        function populateInflamDiseaseGroups() {
            const data = state.data.inflammationdisease;
            if (!data) return;

            const diseaseGroups = [...new Set(data.map(d => d.disease_group))].sort();
            const select = document.getElementById('inflam-disease-group');
            if (select) {
                select.innerHTML = '<option value="all">All Diseases</option>' +
                    diseaseGroups.map(g => `<option value="${g}">${g}</option>`).join('');
            }
        }

        function updateInflamDiseaseBar() {
            const container = document.getElementById('inflam-disease-bar');
            if (!container) return;

            const data = state.data.inflammationdisease;
            if (!data) return;

            const diseaseGroup = document.getElementById('inflam-disease-group')?.value || 'all';
            const sigType = document.getElementById('inflam-disease-sig-type')?.value || 'CytoSig';
            const signature = document.getElementById('inflam-disease-search')?.value || 'IFNG';

            // Filter by signature and signature type
            let filtered = data.filter(d => d.signature === signature);
            // Only filter by signature_type if the field exists in data
            if (data[0]?.signature_type) {
                filtered = filtered.filter(d => d.signature_type === sigType);
            }
            if (diseaseGroup !== 'all') {
                filtered = filtered.filter(d => d.disease_group === diseaseGroup);
            }

            // Aggregate by cell type
            const cellTypeActivity = {};
            filtered.forEach(d => {
                if (!cellTypeActivity[d.cell_type]) {
                    cellTypeActivity[d.cell_type] = [];
                }
                cellTypeActivity[d.cell_type].push(d.mean_activity);
            });

            const aggData = Object.entries(cellTypeActivity).map(([ct, vals]) => ({
                cell_type: ct,
                mean_activity: vals.reduce((a, b) => a + b, 0) / vals.length
            })).sort((a, b) => b.mean_activity - a.mean_activity).slice(0, 30);

            container.classList.remove('loading');
            Plotly.purge(container);

            if (aggData.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available</p>';
                return;
            }

            Plotly.newPlot(container, [{
                y: aggData.map(d => d.cell_type),
                x: aggData.map(d => d.mean_activity),
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: aggData.map(d => d.mean_activity),
                    colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                    
                    cmid: 0
                },
                hovertemplate: '<b>%{y}</b><br>Activity: %{x:.4f}<extra></extra>'
            }], {
                margin: {l: 180, r: 30, t: 30, b: 50},
                xaxis: {title: 'Mean Activity'},
                height: 450
            }, {responsive: true});
        }

        function updateInflamDiseaseHeatmap() {
            const container = document.getElementById('inflam-disease-heatmap');
            if (!container) return;

            const data = state.data.inflammationdisease;
            if (!data) return;

            const diseaseGroup = document.getElementById('inflam-disease-group')?.value || 'all';
            const sigType = document.getElementById('inflam-disease-sig-type')?.value || 'CytoSig';

            let filtered = data;
            // Filter by signature type if field exists
            if (data[0]?.signature_type) {
                filtered = filtered.filter(d => d.signature_type === sigType);
            }
            if (diseaseGroup !== 'all') {
                filtered = filtered.filter(d => d.disease_group === diseaseGroup);
            }

            // Get unique diseases and signatures
            const diseases = [...new Set(filtered.map(d => d.disease))];
            const signatures = [...new Set(filtered.map(d => d.signature))].sort();

            // Aggregate by disease (mean across cell types)
            const diseaseActivity = {};
            filtered.forEach(d => {
                const key = `${d.disease}|${d.signature}`;
                if (!diseaseActivity[key]) {
                    diseaseActivity[key] = [];
                }
                diseaseActivity[key].push(d.mean_activity);
            });

            // Create matrix
            const zData = diseases.map(disease =>
                signatures.map(sig => {
                    const key = `${disease}|${sig}`;
                    const vals = diseaseActivity[key] || [0];
                    return vals.reduce((a, b) => a + b, 0) / vals.length;
                })
            );

            container.classList.remove('loading');
            Plotly.purge(container);

            if (diseases.length === 0 || signatures.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No data available</p>';
                return;
            }

            Plotly.newPlot(container, [{
                z: zData,
                x: signatures,
                y: diseases,
                type: 'heatmap',
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                
                zmid: 0,
                colorbar: {title: 'Activity'},
                hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.4f}<extra></extra>'
            }], {
                margin: {l: 120, r: 50, t: 30, b: 100},
                xaxis: {tickangle: 45},
                height: 450
            }, {responsive: true});
        }

        // Inflammation: Initialize Differential Disease Dropdown
        function initInflamDifferentialDiseases() {
            // Use inflammationdifferential data if available, fallback to inflammationdisease
            const diffData = state.data.inflammationdifferential;
            const diseaseData = state.data.inflammationdisease;

            let diseases = [];
            if (diffData && diffData.length > 0) {
                // Filter out 'healthy' and 'All Diseases' (handled by the hardcoded "all" option)
                diseases = [...new Set(diffData.map(d => d.disease))].filter(d => d !== 'healthy' && d !== 'All Diseases').sort();
            } else if (diseaseData && diseaseData.length > 0) {
                diseases = [...new Set(diseaseData.map(d => d.disease))].filter(d => d !== 'healthy' && d !== 'All Diseases').sort();
            }

            const select = document.getElementById('inflam-diff-disease');
            if (select) {
                select.innerHTML = '<option value="all">All Diseases vs Healthy</option>' +
                    diseases.map(d => `<option value="${d}">${d} vs Healthy</option>`).join('');
            }
        }

        // Inflammation: Differential (Disease vs Healthy) - matches CIMA differential style
        function updateInflamDifferential() {
            const container1 = document.getElementById('inflam-diff-volcano');
            const container2 = document.getElementById('inflam-diff-bar');

            const sigType = document.getElementById('inflam-diff-sig-type')?.value || 'CytoSig';
            const diseaseFilter = document.getElementById('inflam-diff-disease')?.value || 'all';

            // Get differential data
            const diffData = state.data.inflammationdifferential;

            if (!diffData || diffData.length === 0) {
                if (container1) {
                    container1.classList.remove('loading');
                    container1.innerHTML = '<p style="text-align:center;color:#666;padding:2rem;">No differential data available</p>';
                }
                if (container2) {
                    container2.classList.remove('loading');
                    container2.innerHTML = '<p style="text-align:center;color:#666;padding:2rem;">No differential data available</p>';
                }
                return;
            }

            // Filter by signature type and disease
            // When 'all' is selected, use the pooled "All Diseases" data (one entry per signature)
            // When a specific disease is selected, use that disease's data
            let filteredData = diffData.filter(d => d.signature === sigType);

            if (diseaseFilter === 'all') {
                // Use the pooled "All Diseases" differential (clean, one entry per signature)
                filteredData = filteredData.filter(d => d.disease === 'All Diseases');
            } else {
                // Use the specific disease differential
                filteredData = filteredData.filter(d => d.disease === diseaseFilter);
            }

            // For SecAct (many proteins), limit to top 200 by significance score
            if (sigType === 'SecAct' && filteredData.length > 200) {
                filteredData = [...filteredData].sort((a, b) => {
                    const scoreA = a.neg_log10_pval * Math.abs(a.activity_diff);
                    const scoreB = b.neg_log10_pval * Math.abs(b.activity_diff);
                    return scoreB - scoreA;
                }).slice(0, 200);
            }

            // Update titles with comparison type info
            const diseaseLabel = diseaseFilter === 'all' ? 'All Diseases' : diseaseFilter;
            const volcanoTitle = document.getElementById('inflam-diff-volcano-title');
            const volcanoSubtitle = document.getElementById('inflam-diff-volcano-subtitle');
            const barTitle = document.getElementById('inflam-diff-bar-title');
            const barSubtitle = document.getElementById('inflam-diff-bar-subtitle');

            // Get comparison type info
            let comparisonNote = '';
            if (filteredData.length > 0) {
                const compType = filteredData[0].comparison;
                const healthyNote = filteredData[0].healthy_note;
                const nHealthy = filteredData[0].n_g2;
                const nDisease = filteredData[0].n_g1;

                if (diseaseFilter === 'all') {
                    // Pooled all diseases vs healthy
                    comparisonNote = `All diseases pooled (n=${nDisease}) vs healthy (n=${nHealthy})`;
                } else if (compType === 'study_matched') {
                    comparisonNote = `Study-matched healthy (n=${nHealthy})`;
                } else {
                    comparisonNote = `‚ö†Ô∏è Pooled healthy - no matched controls (n=${nHealthy})`;
                }
            }

            if (volcanoTitle) volcanoTitle.textContent = `Volcano Plot: ${diseaseLabel} vs Healthy`;
            if (volcanoSubtitle) volcanoSubtitle.innerHTML = `Positive = higher in ${diseaseLabel}, Negative = higher in Healthy<br><span style="font-size: 0.85em; color: ${comparisonNote.includes('‚ö†Ô∏è') ? '#d62728' : '#666'};">${comparisonNote}</span>`;
            if (barTitle) barTitle.textContent = `Top Differential Signatures`;
            if (barSubtitle) barSubtitle.textContent = `Sorted by significance (|effect| √ó -log10 p)`;

            // Handle empty data
            if (filteredData.length === 0) {
                if (container1) {
                    container1.classList.remove('loading');
                    container1.innerHTML = `<p style="text-align:center;color:#666;padding:2rem;">No data available for ${diseaseLabel} (${sigType})</p>`;
                }
                if (container2) {
                    container2.classList.remove('loading');
                    container2.innerHTML = '<p style="text-align:center;color:#666;padding:2rem;">No data available</p>';
                }
                return;
            }

            // 1. Volcano plot (consistent style with scAtlas)
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                // Split data into three groups for consistent volcano style
                const significantUp = filteredData.filter(d => d.activity_diff > 0.3 && (d.qvalue || d.pvalue || 1) < 0.05);
                const significantDown = filteredData.filter(d => d.activity_diff < -0.3 && (d.qvalue || d.pvalue || 1) < 0.05);
                const notSig = filteredData.filter(d => Math.abs(d.activity_diff) <= 0.3 || (d.qvalue || d.pvalue || 1) >= 0.05);

                // Dynamic axis ranges
                const maxAbsFC = Math.max(3, Math.ceil(Math.max(...filteredData.map(d => Math.abs(d.activity_diff)))));
                const maxY = Math.max(4, Math.ceil(Math.max(...filteredData.map(d => d.neg_log10_pval))));

                // Update subtitle with counts
                if (volcanoSubtitle) {
                    const nSigUp = significantUp.length;
                    const nSigDown = significantDown.length;
                    volcanoSubtitle.innerHTML = `${nSigUp + nSigDown} significant (|Œî|>0.3, q<0.05): ${nSigUp} up, ${nSigDown} down<br><span style="font-size: 0.85em; color: ${comparisonNote.includes('‚ö†Ô∏è') ? '#d62728' : '#666'};">${comparisonNote}</span>`;
                }

                Plotly.newPlot(container1, [
                    {
                        type: 'scatter', mode: 'markers+text', name: `Higher in ${diseaseLabel}`,
                        x: significantUp.map(d => d.activity_diff), y: significantUp.map(d => d.neg_log10_pval),
                        text: significantUp.map(d => d.protein), textposition: 'top center', textfont: { size: 9 },
                        marker: { color: '#d62728', size: 10 },
                        hovertemplate: '<b>%{text}</b><br>Œî Activity: %{x:.3f}<br>-log10(p): %{y:.2f}<extra></extra>'
                    },
                    {
                        type: 'scatter', mode: 'markers+text', name: 'Higher in Healthy',
                        x: significantDown.map(d => d.activity_diff), y: significantDown.map(d => d.neg_log10_pval),
                        text: significantDown.map(d => d.protein), textposition: 'top center', textfont: { size: 9 },
                        marker: { color: '#2ca02c', size: 10 },
                        hovertemplate: '<b>%{text}</b><br>Œî Activity: %{x:.3f}<br>-log10(p): %{y:.2f}<extra></extra>'
                    },
                    {
                        type: 'scatter', mode: 'markers', name: 'Not significant',
                        x: notSig.map(d => d.activity_diff), y: notSig.map(d => d.neg_log10_pval),
                        text: notSig.map(d => d.protein), marker: { color: '#ccc', size: 6 },
                        hovertemplate: '<b>%{text}</b><br>Œî Activity: %{x:.3f}<br>-log10(p): %{y:.2f}<extra></extra>'
                    }
                ], {
                    xaxis: {
                        title: `Œî Activity (${diseaseLabel} - Healthy)`,
                        zeroline: true,
                        range: [-maxAbsFC, maxAbsFC]
                    },
                    yaxis: {
                        title: '-log10(p-value)',
                        range: [0, maxY * 1.1]
                    },
                    shapes: [
                        { type: 'line', x0: 0.3, y0: 0, x1: 0.3, y1: maxY * 1.1, line: { dash: 'dot', color: '#999' } },
                        { type: 'line', x0: -0.3, y0: 0, x1: -0.3, y1: maxY * 1.1, line: { dash: 'dot', color: '#999' } },
                        { type: 'line', x0: -maxAbsFC, y0: -Math.log10(0.05), x1: maxAbsFC, y1: -Math.log10(0.05), line: { dash: 'dot', color: '#999' } }
                    ],
                    margin: { l: 60, r: 30, t: 30, b: 50 },
                    legend: { orientation: 'h', y: -0.15 },
                    height: 400
                }, { responsive: true });
            }

            // 2. Top differential bar chart - sorted by significance score (matching CIMA style)
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                // Calculate significance score and sort
                const scoredData = filteredData.map(d => ({
                    ...d,
                    score: Math.abs(d.activity_diff) * d.neg_log10_pval
                }));

                // Sort by score descending and take top 20
                const sorted = [...scoredData].sort((a, b) => b.score - a.score);
                const top20 = sorted.slice(0, 20).reverse();  // Reverse for horizontal bar (top at top)

                // Color to match volcano: red for higher in disease, green for higher in healthy
                Plotly.newPlot(container2, [{
                    type: 'bar',
                    orientation: 'h',
                    y: top20.map(d => d.protein),
                    x: top20.map(d => d.activity_diff),
                    marker: {
                        color: top20.map(d => d.activity_diff > 0 ? '#d62728' : '#2ca02c')
                    },
                    text: top20.map(d => d.activity_diff.toFixed(2)),
                    textposition: 'outside',
                    textfont: { size: 9 },
                    hovertemplate: '<b>%{y}</b><br>Œî Activity: %{x:.3f}<br>q = %{customdata}<extra></extra>',
                    customdata: top20.map(d => d.qvalue?.toExponential(2) || 'N/A')
                }], {
                    xaxis: { title: 'Œî Activity (Disease - Healthy)', zeroline: true, zerolinecolor: '#ccc' },
                    yaxis: { automargin: true, tickfont: { size: 10 } },
                    margin: { l: 120, r: 50, t: 30, b: 50 },
                    height: 400
                }, { responsive: true });
            }
        }

        // Tooltip functions
        function showTooltip(event, content) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = content;
            tooltip.style.display = 'block';
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        // Track which sections have been initialized
        const sectionsInitialized = {};

        // Event listeners
        function setupEventListeners() {
            // Tab switching with redraw on visibility
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const tabGroup = this.closest('section');
                    const sectionId = tabGroup.id;
                    tabGroup.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tabGroup.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

                    this.classList.add('active');
                    const tabId = this.dataset.tab;
                    document.getElementById('tab-' + tabId).classList.add('active');

                    // Trigger redraw for D3 charts when their tab becomes visible
                    setTimeout(() => {
                        if (sectionId === 'cima') {
                            if (tabId === 'metabolites') updateMetaboliteNetwork();
                            if (tabId === 'cima-multiomics') updateMultiomicsViz();
                        }
                        // Cross-Atlas: redraw charts that need visible container
                        if (sectionId === 'cross-atlas') {
                            if (tabId === 'celltype-mapping') updateCelltypeMapping();
                            if (tabId === 'signature-correlation') updateSignatureCorrelation();
                        }
                        // Resize any Plotly charts in the newly visible tab
                        const activeTab = document.getElementById('tab-' + tabId);
                        if (activeTab) {
                            activeTab.querySelectorAll('div[id]').forEach(div => {
                                if (div._fullLayout) {
                                    try { Plotly.Plots.resize(div); } catch(e) {}
                                }
                            });
                        }
                    }, 50);
                });
            });

            // Navigation with lazy loading
            const navLinks = document.querySelectorAll('nav a');

            navLinks.forEach(link => {
                link.addEventListener('click', async function(e) {
                    e.preventDefault();
                    const sectionId = this.getAttribute('href').replace('#', '');
                    const target = document.getElementById(sectionId);

                    // Lazy load section data
                    if (!sectionsInitialized[sectionId] && ['cima', 'inflammation', 'scatlas', 'cross-atlas'].includes(sectionId)) {
                        sectionsInitialized[sectionId] = true;
                        await initSection(sectionId);
                    }

                    target.scrollIntoView({behavior: 'smooth'});

                    // Update active nav
                    navLinks.forEach(l => l.classList.remove('active'));
                    this.classList.add('active');
                });
            });

            // Intersection Observer for lazy loading on scroll
            const observer = new IntersectionObserver(async (entries) => {
                for (const entry of entries) {
                    if (entry.isIntersecting) {
                        const sectionId = entry.target.id;
                        if (!sectionsInitialized[sectionId] && ['cima', 'inflammation', 'scatlas', 'cross-atlas'].includes(sectionId)) {
                            sectionsInitialized[sectionId] = true;
                            await initSection(sectionId);
                        }
                    }
                }
            }, { threshold: 0.1 });

            ['cima', 'inflammation', 'scatlas', 'cross-atlas'].forEach(id => {
                const el = document.getElementById(id);
                if (el) observer.observe(el);
            });

            // Control changes - CIMA
            document.getElementById('corr-signature-type')?.addEventListener('change', updateCorrelationPlots);
            document.getElementById('biochem-signature-type')?.addEventListener('change', () => {
                initBiochemProteins();
                populateProteinDropdown('biochem-protein-dropdown', 'biochem-signature-type');
                document.getElementById('biochem-protein-search').value = '';
                updateBiochemHeatmap();
            });
            document.getElementById('biochem-top-n')?.addEventListener('change', updateBiochemHeatmap);

            // Biochemistry protein search autocomplete
            const biochemSearchInput = document.getElementById('biochem-protein-search');
            if (biochemSearchInput) {
                biochemSearchInput.addEventListener('input', (e) => {
                    showBiochemSuggestions(e.target.value);
                });
                biochemSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('biochem-protein-suggestions').style.display = 'none';
                        updateBiochemHeatmap();
                    }
                });
                biochemSearchInput.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('biochem-protein-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Dropdown for biochem protein selection
            document.getElementById('biochem-protein-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('biochem-protein-search').value = e.target.value;
                updateBiochemHeatmap();
            });

            document.getElementById('diff-comparison')?.addEventListener('change', updateVolcanoPlot);
            document.getElementById('diff-signature-type')?.addEventListener('change', updateVolcanoPlot);

            // Cell type-specific correlation controls
            document.getElementById('cima-ct-corr-sigtype')?.addEventListener('change', updateCelltypeCorrelationHeatmap);
            document.getElementById('cima-ct-corr-feature')?.addEventListener('change', updateCelltypeCorrelationHeatmap);
            document.getElementById('cima-ct-corr-metric')?.addEventListener('change', updateCelltypeCorrelationHeatmap);

            // Control changes - CIMA Cell Types
            document.getElementById('cima-ct-sig-type')?.addEventListener('change', () => {
                // Reset search to default when switching sig type
                const searchInput = document.getElementById('cima-ct-protein-search');
                if (searchInput) searchInput.value = 'IFNG';
                populateProteinDropdown('cima-ct-protein-dropdown', 'cima-ct-sig-type');
                updateCimaCelltypeBar();
                updateCimaCelltypeHeatmap();
            });

            // CIMA Cell Types protein search autocomplete
            const cimaCelltypeSearchInput = document.getElementById('cima-ct-protein-search');
            if (cimaCelltypeSearchInput) {
                cimaCelltypeSearchInput.addEventListener('input', (e) => {
                    showCimaCelltypeSuggestions(e.target.value);
                });
                cimaCelltypeSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('cima-ct-protein-suggestions').style.display = 'none';
                        updateCimaCelltypeBar();
                    }
                });
                cimaCelltypeSearchInput.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('cima-ct-protein-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Dropdown for CIMA Cell Types protein selection
            document.getElementById('cima-ct-protein-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('cima-ct-protein-search').value = e.target.value;
                updateCimaCelltypeBar();
            });

            // Control changes - Inflammation Cell Types
            document.getElementById('inflam-sig-type')?.addEventListener('change', () => {
                // Reset search to default when switching sig type
                const searchInput = document.getElementById('inflam-signature-search');
                if (searchInput) searchInput.value = 'IFNG';
                populateProteinDropdown('inflam-signature-dropdown', 'inflam-sig-type');
                updateInflammationBar();
                updateInflammationHeatmap();
            });

            // Inflammation signature search with autocomplete
            const inflamSearchInput = document.getElementById('inflam-signature-search');
            if (inflamSearchInput) {
                inflamSearchInput.addEventListener('focus', showInflamSignatureSuggestions);
                inflamSearchInput.addEventListener('input', showInflamSignatureSuggestions);
                inflamSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('inflam-signature-suggestions').style.display = 'none';
                        updateInflammationBar();
                    }
                });
                inflamSearchInput.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('inflam-signature-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Dropdown for Inflammation Cell Types protein selection
            document.getElementById('inflam-signature-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('inflam-signature-search').value = e.target.value;
                updateInflammationBar();
                updateInflammationHeatmap();
            });

            // Control changes - Inflammation Age/BMI
            document.getElementById('inflam-corr-sig-type')?.addEventListener('change', updateInflamCorrelations);

            // Control changes - Inflammation Cell Type Correlations
            document.getElementById('inflam-ct-corr-sigtype')?.addEventListener('change', updateInflamCelltypeCorrelationHeatmap);
            document.getElementById('inflam-ct-corr-feature')?.addEventListener('change', updateInflamCelltypeCorrelationHeatmap);
            document.getElementById('inflam-ct-corr-metric')?.addEventListener('change', updateInflamCelltypeCorrelationHeatmap);

            // Control changes - Inflammation Age/BMI Stratified
            document.getElementById('inflam-stratify-by')?.addEventListener('change', () => {
                updateInflamStratifiedBoxplot();
                updateInflamCelltypeStratifiedHeatmap();
            });
            document.getElementById('inflam-boxplot-celltype')?.addEventListener('change', () => {
                updateInflamStratifiedBoxplot();
                updateInflamCelltypeStratifiedHeatmap();
            });
            document.getElementById('inflam-boxplot-sig-type')?.addEventListener('change', () => {
                const sigType = document.getElementById('inflam-boxplot-sig-type')?.value || 'CytoSig';
                const input = document.getElementById('inflam-boxplot-search');
                if (input) {
                    const sigs = getInflamBoxplotSignatures();
                    if (sigType === 'SecAct' && sigs.length > 0) {
                        // Use a common SecAct signature as default
                        const defaultSig = ['IFNG', 'CCL3', 'S100A8', 'GRN', 'CTSB'].find(s => sigs.includes(s)) || sigs[0];
                        input.value = defaultSig;
                    } else {
                        input.value = 'IFNG';
                    }
                }
                populateProteinDropdown('inflam-boxplot-dropdown', 'inflam-boxplot-sig-type');
                updateInflamStratifiedBoxplot();
                updateInflamCelltypeStratifiedHeatmap();
            });
            const inflamBoxplotSearch = document.getElementById('inflam-boxplot-search');
            if (inflamBoxplotSearch) {
                inflamBoxplotSearch.addEventListener('focus', showInflamBoxplotSuggestions);
                inflamBoxplotSearch.addEventListener('input', showInflamBoxplotSuggestions);
                inflamBoxplotSearch.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('inflam-boxplot-suggestions').style.display = 'none';
                        updateInflamStratifiedBoxplot();
                        updateInflamCelltypeStratifiedHeatmap();
                    }
                });
                inflamBoxplotSearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('inflam-boxplot-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Dropdown for Inflammation Age/BMI Stratified protein selection
            document.getElementById('inflam-boxplot-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('inflam-boxplot-search').value = e.target.value;
                updateInflamStratifiedBoxplot();
                updateInflamCelltypeStratifiedHeatmap();
            });

            // Control changes - Inflammation Disease
            document.getElementById('inflam-disease-group')?.addEventListener('change', () => {
                updateInflamDiseaseBar();
                updateInflamDiseaseHeatmap();
            });
            document.getElementById('inflam-disease-sig-type')?.addEventListener('change', () => {
                // Reset search to default when switching sig type
                const searchInput = document.getElementById('inflam-disease-search');
                const sigType = document.getElementById('inflam-disease-sig-type')?.value || 'CytoSig';
                if (searchInput) {
                    // Use appropriate default for each signature type
                    const sigs = getInflamDiseaseSignatures();
                    if (sigType === 'SecAct' && sigs.length > 0) {
                        // Find a common SecAct signature as default, or use first available
                        const defaultSecAct = ['IFNG', 'CCL3', 'S100A8', 'GRN', 'CTSB'].find(s => sigs.includes(s)) || sigs[0];
                        searchInput.value = defaultSecAct;
                    } else {
                        searchInput.value = 'IFNG';
                    }
                }
                populateProteinDropdown('inflam-disease-dropdown', 'inflam-disease-sig-type');
                updateInflamDiseaseBar();
                updateInflamDiseaseHeatmap();
            });

            // Inflammation Disease signature search with autocomplete
            const inflamDiseaseSearch = document.getElementById('inflam-disease-search');
            if (inflamDiseaseSearch) {
                inflamDiseaseSearch.addEventListener('focus', showInflamDiseaseSuggestions);
                inflamDiseaseSearch.addEventListener('input', showInflamDiseaseSuggestions);
                inflamDiseaseSearch.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('inflam-disease-suggestions').style.display = 'none';
                        updateInflamDiseaseBar();
                    }
                });
                inflamDiseaseSearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('inflam-disease-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Dropdown for Inflammation Disease protein selection
            document.getElementById('inflam-disease-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('inflam-disease-search').value = e.target.value;
                updateInflamDiseaseBar();
                updateInflamDiseaseHeatmap();
            });

            // Control changes - Inflammation Differential
            document.getElementById('inflam-diff-sig-type')?.addEventListener('change', updateInflamDifferential);
            document.getElementById('inflam-diff-disease')?.addEventListener('change', updateInflamDifferential);

            // Control changes - scAtlas
            // Organ heatmap controls
            document.getElementById('organ-signature')?.addEventListener('input', debounce(() => {
                updateOrganBarChart();
            }, 300));
            document.getElementById('organ-signature')?.addEventListener('change', () => {
                updateOrganBarChart();
            });
            document.getElementById('organ-sig-type')?.addEventListener('change', () => {
                populateOrganSignatures();  // Update signature datalist for new type
                updateOrganBarChart();
                updateOrganHeatmap();
            });
            // scAtlas Cell Types controls
            document.getElementById('ct-sig-type')?.addEventListener('change', () => {
                populateScatlasCelltypeDropdown();
                updateScatlasCelltypeBar();
                updateCelltypeHeatmap();
            });
            document.getElementById('ct-organ-filter')?.addEventListener('change', () => {
                updateScatlasCelltypeBar();
                updateCelltypeHeatmap();
            });

            // scAtlas Cell Types protein dropdown
            document.getElementById('scatlas-ct-protein-dropdown')?.addEventListener('change', (e) => {
                const searchInput = document.getElementById('scatlas-ct-protein-search');
                if (searchInput) searchInput.value = e.target.value;
                updateScatlasCelltypeBar();
            });

            // scAtlas Cell Types protein search autocomplete
            const scatlasCelltypeSearch = document.getElementById('scatlas-ct-protein-search');
            if (scatlasCelltypeSearch) {
                scatlasCelltypeSearch.addEventListener('focus', showScatlasCelltypeSuggestions);
                scatlasCelltypeSearch.addEventListener('input', showScatlasCelltypeSuggestions);
                scatlasCelltypeSearch.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('scatlas-ct-suggestions').style.display = 'none';
                        const dropdown = document.getElementById('scatlas-ct-protein-dropdown');
                        if (dropdown) dropdown.value = e.target.value;
                        updateScatlasCelltypeBar();
                    }
                });
                scatlasCelltypeSearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('scatlas-ct-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Control changes - Cancer comparison
            document.getElementById('cancer-sig-type')?.addEventListener('change', () => {
                updateCancerBarChart();
                updateCancerHeatmap();
            });
            document.getElementById('cancer-celltype')?.addEventListener('change', updateCancerBarChart);
        }

        // ========================================
        // NEW PANEL FUNCTIONS
        // ========================================

        // Helper function to generate boxplot values from summary statistics
        function generateBoxplotValues(stats) {
            if (!stats || !stats.n) return [];
            // Generate synthetic values representing the distribution
            // This creates a reasonable approximation for visualization
            const { min, q1, median, q3, max, n } = stats;
            const values = [];
            // Add key percentile points weighted by expected distribution
            const nPoints = Math.min(n, 50);  // Limit to 50 points for performance
            for (let i = 0; i < nPoints; i++) {
                const p = i / (nPoints - 1);
                let value;
                if (p <= 0.25) {
                    value = min + (q1 - min) * (p / 0.25);
                } else if (p <= 0.5) {
                    value = q1 + (median - q1) * ((p - 0.25) / 0.25);
                } else if (p <= 0.75) {
                    value = median + (q3 - median) * ((p - 0.5) / 0.25);
                } else {
                    value = q3 + (max - q3) * ((p - 0.75) / 0.25);
                }
                values.push(value);
            }
            return values;
        }

        // CIMA: Age/BMI Stratified Boxplots
        async function updateStratifiedBoxplot() {
            const container = document.getElementById('stratified-boxplot');
            if (!container) return;

            const stratifyBy = document.getElementById('stratify-by')?.value || 'age';
            const sigType = document.getElementById('boxplot-sig-type')?.value || 'CytoSig';
            const signature = document.getElementById('boxplot-signature-search')?.value || 'IFNG';
            const cellType = document.getElementById('boxplot-celltype')?.value || 'All';

            // Update cell type availability based on signature type
            updateBoxplotCellTypeAvailability();

            // Use selected cell type for CytoSig, SecAct, and "both" modes
            const effectiveCellType = cellType;

            // Update title
            const titleEl = document.getElementById('boxplot-title');
            const subtitleEl = document.getElementById('boxplot-subtitle');
            const cellTypeLabel = effectiveCellType === 'All' ? '' : ` in ${effectiveCellType}`;
            if (titleEl) titleEl.textContent = `${stratifyBy === 'age' ? 'Age' : 'BMI'}-Stratified ${signature} Activity${cellTypeLabel}`;
            if (subtitleEl) subtitleEl.textContent = sigType === 'both'
                ? `Activity distribution across ${stratifyBy === 'age' ? 'age decades' : 'BMI categories'} (CytoSig and/or SecAct)${cellTypeLabel}`
                : `${sigType} activity distribution across ${stratifyBy === 'age' ? 'age decades' : 'BMI categories'}${cellTypeLabel}`;

            // Show loading for SecAct (lazy loaded)
            if (sigType === 'SecAct' && !state.boxplotLoaded.secact) {
                container.innerHTML = '<div class="loading">Loading SecAct data...</div>';
            }

            // Get boxplot data (async for SecAct)
            const boxplotData = await getBoxplotData('cima', sigType);
            container.classList.remove('loading');

            if (boxplotData && boxplotData[stratifyBy]) {
                // Handle "both" - show CytoSig and SecAct side by side
                if (sigType === 'both') {
                    // Filter by cell type: 'All' = sample-level (no cell_type), otherwise match specific cell type
                    const cellTypeFilter = effectiveCellType === 'All'
                        ? (d => !d.cell_type)
                        : (d => d.cell_type === effectiveCellType);
                    const cytosigData = boxplotData[stratifyBy].filter(d => d.signature === signature && d.sig_type === 'CytoSig' && cellTypeFilter(d));
                    const secactData = boxplotData[stratifyBy].filter(d => d.signature === signature && d.sig_type === 'SecAct' && cellTypeFilter(d));

                    if (cytosigData.length > 0 || secactData.length > 0) {
                        const bins = stratifyBy === 'age'
                            ? ['<30', '30-39', '40-49', '50-59', '60-69', '70+']
                            : ['Underweight', 'Normal', 'Overweight', 'Obese'];

                        const traces = [];
                        bins.forEach((bin, i) => {
                            const cytoD = cytosigData.find(d => d.bin === bin);
                            const secD = secactData.find(d => d.bin === bin);

                            if (cytoD) {
                                traces.push({
                                    y: cytoD.values || generateBoxplotValues(cytoD),
                                    type: 'box',
                                    name: `${bin}`,
                                    legendgroup: 'CytoSig',
                                    boxpoints: cytoD.values ? 'outliers' : false,
                                    marker: { color: '#1f77b4' },
                                    offsetgroup: 'CytoSig',
                                    hovertemplate: `CytoSig ${bin}<br>median: ${cytoD.median?.toFixed(2) || 'N/A'}<br>n: ${cytoD.n || 'N/A'}<extra></extra>`
                                });
                            }
                            if (secD) {
                                traces.push({
                                    y: secD.values || generateBoxplotValues(secD),
                                    type: 'box',
                                    name: `${bin}`,
                                    legendgroup: 'SecAct',
                                    boxpoints: secD.values ? 'outliers' : false,
                                    marker: { color: '#ff7f0e' },
                                    offsetgroup: 'SecAct',
                                    hovertemplate: `SecAct ${bin}<br>median: ${secD.median?.toFixed(2) || 'N/A'}<br>n: ${secD.n || 'N/A'}<extra></extra>`
                                });
                            }
                        });

                        Plotly.newPlot(container, traces, {
                            yaxis: { title: `${signature} Activity Score${cellTypeLabel}`, zeroline: true },
                            xaxis: { title: stratifyBy === 'age' ? 'Age Group' : 'BMI Category' },
                            boxmode: 'group',
                            showlegend: true,
                            legend: { title: { text: 'Signature Type' } },
                            margin: { t: 30, b: 60, l: 60, r: 30 },
                            height: 450,
                            annotations: [{
                                x: 0.25, y: 1.08, xref: 'paper', yref: 'paper',
                                text: '<b style="color:#1f77b4">‚ñ†</b> CytoSig',
                                showarrow: false, font: { size: 12 }
                            }, {
                                x: 0.45, y: 1.08, xref: 'paper', yref: 'paper',
                                text: '<b style="color:#ff7f0e">‚ñ†</b> SecAct',
                                showarrow: false, font: { size: 12 }
                            }]
                        }, { responsive: true });
                        return;
                    }
                }

                // Single signature type - filter by sig_type and optionally cell_type
                let sigData = boxplotData[stratifyBy].filter(d => d.signature === signature);

                // Filter by cell_type: 'All' means sample-level (no cell_type field), otherwise match specific cell type
                if (effectiveCellType === 'All') {
                    // Sample-level data: records without cell_type field
                    sigData = sigData.filter(d => !d.cell_type);
                } else {
                    // Cell type-specific data
                    sigData = sigData.filter(d => d.cell_type === effectiveCellType);
                }

                // Filter by sig_type
                if (sigType !== 'both' && sigData.length > 0 && sigData[0].sig_type) {
                    sigData = sigData.filter(d => d.sig_type === sigType);
                }

                if (sigData.length > 0) {
                    // Sort by bin order
                    const binOrder = stratifyBy === 'age'
                        ? ['<30', '30-39', '40-49', '50-59', '60-69', '70+']
                        : ['Underweight', 'Normal', 'Overweight', 'Obese'];
                    sigData.sort((a, b) => binOrder.indexOf(a.bin) - binOrder.indexOf(b.bin));

                    const traces = sigData.map((d, i) => ({
                        y: d.values || generateBoxplotValues(d),  // Use raw values or generate from stats
                        type: 'box',
                        name: d.bin,
                        boxpoints: d.values ? 'outliers' : false,
                        marker: { color: d3.schemeTableau10[i % 10] },
                        hovertemplate: `${d.bin}<br>median: ${d.median?.toFixed(2) || 'N/A'}<br>n: ${d.n || 'N/A'}<extra></extra>`
                    }));

                    Plotly.newPlot(container, traces, {
                        yaxis: { title: `${signature} Activity Score`, zeroline: true },
                        xaxis: { title: stratifyBy === 'age' ? 'Age Group' : 'BMI Category' },
                        showlegend: false,
                        margin: { t: 30, b: 60, l: 60, r: 30 },
                        height: 450
                    }, { responsive: true });
                    return;
                }
            }

            // Fallback to mock data if real data not available
            const bins = stratifyBy === 'age'
                ? ['<30', '30-40', '40-50', '50-60', '>60']
                : ['Underweight', 'Normal', 'Overweight', 'Obese'];

            const traces = bins.map((bin, i) => ({
                y: Array(30).fill(0).map(() => (Math.random() - 0.5) * 2 + (i * 0.1)),
                type: 'box',
                name: bin,
                boxpoints: 'outliers',
                marker: { color: d3.schemeTableau10[i % 10] }
            }));

            Plotly.newPlot(container, traces, {
                yaxis: { title: `${signature} Activity Score`, zeroline: true },
                xaxis: { title: stratifyBy === 'age' ? 'Age Group' : 'BMI Category' },
                showlegend: false,
                margin: { t: 30, b: 60, l: 60, r: 30 },
                height: 450
            }, { responsive: true });
        }

        // Cell Type-Specific Heatmap for Age/BMI Stratified Panel
        async function updateCelltypeStratifiedHeatmap() {
            const container = document.getElementById('celltype-stratified-heatmap');
            if (!container) return;

            const stratifyBy = document.getElementById('stratify-by')?.value || 'age';
            const sigType = document.getElementById('boxplot-sig-type')?.value || 'CytoSig';
            const signature = document.getElementById('boxplot-signature-search')?.value || 'IFNG';

            // Update titles
            const titleEl = document.getElementById('celltype-stratified-title');
            const subtitleEl = document.getElementById('celltype-stratified-subtitle');
            if (titleEl) titleEl.textContent = `Cell Type-Specific ${signature} Activity`;
            if (subtitleEl) subtitleEl.textContent = `Median activity across cell types and ${stratifyBy === 'age' ? 'age groups' : 'BMI categories'}`;

            // Get boxplot data (async for SecAct)
            const boxplotData = await getBoxplotData('cima', sigType);
            container.classList.remove('loading');

            if (!boxplotData || !boxplotData[stratifyBy]) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Data not available</p>';
                return;
            }

            // Get bins (must match actual data labels)
            const bins = stratifyBy === 'age'
                ? ['<30', '30-39', '40-49', '50-59', '60-69', '70+']
                : ['Underweight', 'Normal', 'Overweight', 'Obese'];

            // Filter data for this signature (both CytoSig and SecAct have cell type data in CIMA)
            let sigData = boxplotData[stratifyBy].filter(d =>
                d.signature === signature &&
                d.sig_type === (sigType === 'both' ? 'CytoSig' : sigType)
            );

            // Get unique cell types (excluding 'All' and undefined/null for sample-level records)
            const cellTypes = [...new Set(sigData.map(d => d.cell_type))].filter(ct => ct && ct !== 'All').sort();

            if (cellTypes.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No cell type data available for this signature</p>';
                return;
            }

            // Build matrix: cell types √ó bins
            const z = [];
            const hoverText = [];
            for (const ct of cellTypes) {
                const row = [];
                const hoverRow = [];
                for (const bin of bins) {
                    const record = sigData.find(d => d.cell_type === ct && d.bin === bin);
                    const median = record ? record.median : null;
                    row.push(median);
                    hoverRow.push(record
                        ? `${ct}<br>${bin}<br>Median: ${median?.toFixed(2)}<br>n=${record.n}`
                        : `${ct}<br>${bin}<br>No data`
                    );
                }
                z.push(row);
                hoverText.push(hoverRow);
            }

            // Find min/max for symmetric colorscale
            const allValues = z.flat().filter(v => v !== null);
            const maxAbs = Math.max(Math.abs(Math.min(...allValues)), Math.abs(Math.max(...allValues)));

            Plotly.newPlot(container, [{
                type: 'heatmap',
                z: z,
                x: bins,
                y: cellTypes,
                colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                zmin: -maxAbs,
                zmax: maxAbs,
                hoverinfo: 'text',
                text: hoverText,
                colorbar: {
                    title: 'Median Activity',
                    titleside: 'right'
                }
            }], {
                xaxis: {
                    title: stratifyBy === 'age' ? 'Age Group' : 'BMI Category',
                    side: 'bottom'
                },
                yaxis: {
                    title: 'Cell Type',
                    automargin: true
                },
                margin: { t: 30, b: 80, l: 120, r: 80 },
                height: Math.max(400, cellTypes.length * 18 + 120)
            }, { responsive: true });
        }

        // Store all available signatures and cell types for autocomplete
        let boxplotAllSignatures = { cytosig: [], secact: [], shared: [], all: [], cellTypes: [] };

        function initBoxplotSignatures() {
            const boxplotData = state.data.agebmiboxplots?.cima;
            if (boxplotData) {
                // Handle both old format (cytosig_signatures) and new split format (signatures)
                boxplotAllSignatures.cytosig = boxplotData.cytosig_signatures || boxplotData.signatures || [];
                // SecAct signatures will be loaded lazily when user switches
                boxplotAllSignatures.secact = boxplotData.secact_signatures || [];
                boxplotAllSignatures.shared = boxplotData.shared_signatures || [];
                boxplotAllSignatures.all = boxplotData.all_signatures || [...boxplotAllSignatures.cytosig, ...boxplotAllSignatures.secact];
                // Always include 'All' (sample-level) as first option
                const cellTypesFromData = boxplotData.cell_types || [];
                boxplotAllSignatures.cellTypes = ['All', ...cellTypesFromData.filter(ct => ct !== 'All')];
            } else {
                // Fallback
                boxplotAllSignatures.cytosig = ['IFNG', 'TNFA', 'IL6', 'IL17A', 'IL10', 'IL1B', 'IL4', 'IL13'];
                boxplotAllSignatures.secact = [];
                boxplotAllSignatures.shared = [];
                boxplotAllSignatures.all = boxplotAllSignatures.cytosig;
                boxplotAllSignatures.cellTypes = ['All'];
            }
            // Set default value
            const searchInput = document.getElementById('boxplot-signature-search');
            if (searchInput && !searchInput.value) {
                searchInput.value = 'IFNG';
            }
            // Populate cell type dropdown
            populateBoxplotCellTypes();
        }

        // Update SecAct signatures when lazy-loaded data is available
        function updateSecActSignatures() {
            if (state.secactBoxplotData?.cima?.signatures) {
                boxplotAllSignatures.secact = state.secactBoxplotData.cima.signatures;
                boxplotAllSignatures.all = [...new Set([...boxplotAllSignatures.cytosig, ...boxplotAllSignatures.secact])];
            }
        }

        function populateBoxplotCellTypes() {
            const select = document.getElementById('boxplot-celltype');
            if (!select) return;

            const cellTypes = boxplotAllSignatures.cellTypes;
            select.innerHTML = cellTypes.map(ct =>
                `<option value="${ct}"${ct === 'All' ? ' selected' : ''}>${ct}${ct === 'All' ? ' (sample-level)' : ''}</option>`
            ).join('');
        }

        function updateBoxplotCellTypeAvailability() {
            const cellTypeSelect = document.getElementById('boxplot-celltype');
            if (!cellTypeSelect) return;

            // Cell type-specific data available for CytoSig, SecAct, and "both" modes
            cellTypeSelect.disabled = false;
            cellTypeSelect.title = '';
        }

        function getBoxplotSignatures() {
            const sigType = document.getElementById('boxplot-sig-type')?.value || 'CytoSig';
            if (sigType === 'CytoSig') return boxplotAllSignatures.cytosig;
            if (sigType === 'SecAct') return boxplotAllSignatures.secact;
            // For "both", return shared signatures (present in both CytoSig and SecAct)
            return boxplotAllSignatures.shared;
        }

        // Generic helper to populate protein dropdown from signature type
        function populateProteinDropdown(dropdownId, sigTypeId) {
            const dropdown = document.getElementById(dropdownId);
            const sigTypeSelect = document.getElementById(sigTypeId);
            if (!dropdown) return;

            const sigType = sigTypeSelect?.value || 'CytoSig';
            let signatures = [];

            // Determine which signatures to use based on the panel
            if (dropdownId.includes('boxplot')) {
                signatures = getBoxplotSignatures();
            } else if (dropdownId.includes('biochem-scatter')) {
                signatures = sigType === 'CytoSig' ? biochemScatterSigs.cytosig : biochemScatterSigs.secact;
            } else if (dropdownId.includes('biochem')) {
                signatures = sigType === 'CytoSig' ? biochemAllProteins.cytosig : biochemAllProteins.secact;
            } else if (dropdownId.includes('cima-ct')) {
                signatures = sigType === 'CytoSig' ? cimaCelltypeSigs.cytosig : cimaCelltypeSigs.secact;
            } else if (dropdownId.includes('inflam-boxplot')) {
                const inflamBoxplot = state.data.agebmiboxplots?.inflammation;
                if (sigType === 'both') {
                    signatures = inflamBoxplot?.shared_signatures || boxplotAllSignatures.shared;
                } else if (sigType === 'SecAct') {
                    signatures = inflamBoxplot?.secact_signatures || [];
                } else {
                    signatures = inflamBoxplot?.cytosig_signatures || [];
                }
            } else if (dropdownId.includes('inflam-disease')) {
                signatures = sigType === 'SecAct' ? inflamDiseaseSignatures.secact : inflamDiseaseSignatures.cytosig;
            } else if (dropdownId.includes('inflam-signature') || dropdownId.includes('severity')) {
                signatures = sigType === 'SecAct' ? (inflammationSignatures.secact || []) : (inflammationSignatures.cytosig || []);
            }

            // Fallback
            if (!signatures || signatures.length === 0) {
                signatures = ['IFNG', 'TNF', 'IL6', 'IL17A', 'IL10', 'IL1B'];
            }

            // Get current value to preserve selection if still valid
            const currentValue = dropdown.value;

            // Populate dropdown
            dropdown.innerHTML = signatures.slice(0, 200).map(sig =>
                `<option value="${sig}">${sig}</option>`
            ).join('');

            // Restore selection if still valid, otherwise default to IFNG or first
            if (signatures.includes(currentValue)) {
                dropdown.value = currentValue;
            } else if (signatures.includes('IFNG')) {
                dropdown.value = 'IFNG';
            } else {
                dropdown.value = signatures[0] || '';
            }
        }

        function showBoxplotSuggestions(query) {
            const suggestionsDiv = document.getElementById('boxplot-signature-suggestions');
            if (!suggestionsDiv) return;

            const signatures = getBoxplotSignatures();
            const filtered = signatures.filter(s => s.toLowerCase().includes(query.toLowerCase())).slice(0, 20);

            if (filtered.length === 0 || query.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            suggestionsDiv.innerHTML = filtered.map(s =>
                `<div class="suggestion-item" style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                     onmouseover="this.style.background='#f0f0f0'"
                     onmouseout="this.style.background='white'"
                     onclick="selectBoxplotSignature('${s}')">${s}</div>`
            ).join('');
            suggestionsDiv.style.display = 'block';
        }

        function selectBoxplotSignature(signature) {
            const searchInput = document.getElementById('boxplot-signature-search');
            const suggestionsDiv = document.getElementById('boxplot-signature-suggestions');
            if (searchInput) searchInput.value = signature;
            if (suggestionsDiv) suggestionsDiv.style.display = 'none';
            updateStratifiedBoxplot(); updateCelltypeStratifiedHeatmap();
        }

        function populateBoxplotSignatures() {
            // Initialize signature lists from data
            initBoxplotSignatures();
            // Set default value if empty
            const searchInput = document.getElementById('boxplot-signature-search');
            if (searchInput && !searchInput.value) {
                searchInput.value = 'IFNG';
            }
        }

        // CIMA: Metabolite Correlations
        function updateMetabolitesViz() {
            updateMetaboliteNetwork();
            updateMetaboliteLollipop();
        }

        function updateMetaboliteNetwork() {
            const container = document.getElementById('metabolite-network');
            if (!container) return;
            container.classList.remove('loading');

            // Always clear container first to reset any previous state
            container.innerHTML = '';

            const data = state.data.cimametabolitestop;
            if (!data || data.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Metabolite data not available</p>';
                return;
            }

            // Check if container is visible (has valid dimensions)
            let width = container.clientWidth;
            if (width < 100) {
                // Container is likely hidden; defer rendering
                return;
            }

            // Get filter values
            const sigType = document.getElementById('metab-sig-type')?.value || 'CytoSig';
            const category = document.getElementById('metab-category')?.value || 'all';
            const threshold = parseFloat(document.getElementById('metab-threshold')?.value || 0.3);

            // Filter by signature type
            let filtered = data.filter(d => d.signature === sigType);

            // Filter by category (infer from metabolite name prefix)
            if (category !== 'all') {
                const categoryPrefixes = {
                    'lipid': ['PS ', 'PC ', 'PE ', 'PG ', 'PI ', 'SM ', 'LPC', 'Cer', 'TG ', 'DG ', 'LPE', 'FA '],
                    'amino_acid': ['L-Histidine', 'L-Tryptophan', '3-Nitrotyrosine'],
                    'carbohydrate': ['Gluconic', 'Glucosamine', 'D-Gluconolactone', 'Glycolic', 'Citric', 'Erythronic'],
                    'nucleotide': ['ATP', 'ADP', 'AMP', 'GTP', 'GDP', 'UTP', 'CTP', 'NAD', 'NADP'],
                    'cofactor': ['CoA', 'FAD', 'FMN', 'B12', 'Biotin', 'Folate', 'Thiamine']
                };
                const prefixes = categoryPrefixes[category] || [];
                filtered = filtered.filter(d => prefixes.some(p => d.feature.startsWith(p)));
            }

            // Filter by correlation threshold
            filtered = filtered.filter(d => Math.abs(d.rho) >= threshold).slice(0, 100);

            if (filtered.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No correlations above threshold</p>';
                return;
            }

            // Build nodes and links
            const nodesSet = new Set();
            filtered.forEach(d => {
                nodesSet.add(d.protein);
                nodesSet.add(d.feature);
            });

            const nodes = Array.from(nodesSet).map(id => ({
                id,
                type: filtered.some(d => d.protein === id) ? 'cytokine' : 'metabolite'
            }));

            const links = filtered.map(d => ({
                source: d.protein,
                target: d.feature,
                value: Math.abs(d.rho),
                sign: d.rho > 0 ? 'positive' : 'negative'
            }));

            // Clear and draw
            container.innerHTML = '';
            width = container.clientWidth;  // Re-measure after clearing
            const height = 550;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2));

            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', d => d.sign === 'positive' ? '#b2182b' : '#2166ac')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', d => d.value * 3);

            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => d.type === 'cytokine' ? 8 : 5)
                .attr('fill', d => d.type === 'cytokine' ? '#1f77b4' : '#ff7f0e')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            node.append('title').text(d => d.id);

            const labels = svg.append('g')
                .selectAll('text')
                .data(nodes.filter(d => d.type === 'cytokine'))
                .join('text')
                .text(d => d.id)
                .attr('font-size', '10px')
                .attr('dx', 10)
                .attr('dy', 3);

            // Add plain text annotation with colored words
            const anno1 = svg.append('text').attr('x', 10).attr('y', height - 45).attr('font-size', '11px');
            anno1.append('tspan').attr('fill', '#666').text('Lines: ');
            anno1.append('tspan').attr('fill', '#b2182b').text('red');
            anno1.append('tspan').attr('fill', '#666').text(' = positive, ');
            anno1.append('tspan').attr('fill', '#2166ac').text('blue');
            anno1.append('tspan').attr('fill', '#666').text(' = negative');

            const anno2 = svg.append('text').attr('x', 10).attr('y', height - 28).attr('font-size', '11px');
            anno2.append('tspan').attr('fill', '#666').text('Nodes: ');
            anno2.append('tspan').attr('fill', '#1f77b4').text('blue');
            anno2.append('tspan').attr('fill', '#666').text(' = cytokine, ');
            anno2.append('tspan').attr('fill', '#ff7f0e').text('orange');
            anno2.append('tspan').attr('fill', '#666').text(' = metabolite');

            const anno3 = svg.append('text').attr('x', 10).attr('y', height - 11).attr('font-size', '11px').attr('fill', '#666');
            anno3.append('tspan').text('Line ');
            anno3.append('tspan').attr('font-weight', 'bold').text('thickness');
            anno3.append('tspan').text(' = correlation strength');

            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                labels
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
        }

        function updateMetaboliteLollipop() {
            const container = document.getElementById('metabolite-lollipop');
            if (!container) return;
            container.classList.remove('loading');

            // Always purge Plotly first to clean up any previous state
            try { Plotly.purge(container); } catch(e) {}

            const data = state.data.cimametabolitestop;
            if (!data || data.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Metabolite data not available</p>';
                return;
            }

            // Get filter values
            const sigType = document.getElementById('metab-sig-type')?.value || 'CytoSig';
            const category = document.getElementById('metab-category')?.value || 'all';

            // Filter by signature type
            let filtered = data.filter(d => d.signature === sigType);

            // Filter by category (infer from metabolite name prefix)
            if (category !== 'all') {
                const categoryPrefixes = {
                    'lipid': ['PS ', 'PC ', 'PE ', 'PG ', 'PI ', 'SM ', 'LPC', 'Cer', 'TG ', 'DG ', 'LPE', 'FA '],
                    'amino_acid': ['L-Histidine', 'L-Tryptophan', '3-Nitrotyrosine'],
                    'carbohydrate': ['Gluconic', 'Glucosamine', 'D-Gluconolactone', 'Glycolic', 'Citric', 'Erythronic'],
                    'nucleotide': ['ATP', 'ADP', 'AMP', 'GTP', 'GDP', 'UTP', 'CTP', 'NAD', 'NADP'],
                    'cofactor': ['CoA', 'FAD', 'FMN', 'B12', 'Biotin', 'Folate', 'Thiamine']
                };
                const prefixes = categoryPrefixes[category] || [];
                filtered = filtered.filter(d => prefixes.some(p => d.feature.startsWith(p)));
            }

            if (filtered.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data for selected filters</p>';
                return;
            }

            // Clear container before rendering
            container.innerHTML = '';

            // Sort by absolute correlation and take top 30
            const sorted = [...filtered].sort((a, b) => Math.abs(b.rho) - Math.abs(a.rho));
            const top30 = sorted.slice(0, 30);

            const labels = top30.map(d => `${d.protein} - ${d.feature.substring(0, 25)}`);
            const values = top30.map(d => d.rho);

            // Create lollipop shapes (sticks from 0 to value)
            const shapes = top30.map((d, i) => ({
                type: 'line',
                x0: 0,
                x1: d.rho,
                y0: i,
                y1: i,
                line: { color: d.rho > 0 ? '#b2182b' : '#2166ac', width: 2 }
            }));

            // Add center line
            shapes.push({
                type: 'line', x0: 0, x1: 0, y0: -0.5, y1: top30.length - 0.5,
                line: { color: '#888', width: 1, dash: 'dot' }
            });

            const trace = {
                type: 'scatter',
                mode: 'markers',
                x: values,
                y: labels,
                marker: {
                    size: 12,
                    color: values.map(v => v > 0 ? '#b2182b' : '#2166ac'),
                    line: { color: 'white', width: 1 }
                },
                hovertemplate: '%{y}<br>œÅ = %{x:.3f}<extra></extra>'
            };

            Plotly.newPlot(container, [trace], {
                xaxis: { title: 'Spearman œÅ', range: [-0.8, 0.8], zeroline: true },
                yaxis: { automargin: true, autorange: 'reversed' },
                margin: { t: 30, b: 60, l: 220, r: 30 },
                shapes: shapes,
                height: Math.max(400, top30.length * 22 + 80)
            }, { responsive: true });
        }

        // Inflammation: Treatment Response
        function updateTreatmentResponse() {
            const container1 = document.getElementById('treatment-roc');
            const container2 = document.getElementById('treatment-importance');
            const container3 = document.getElementById('treatment-violin');

            const data = state.data.treatmentresponse;

            // Get filter values
            const selectedDisease = document.getElementById('treatment-disease')?.value || 'all';
            const selectedSigType = document.getElementById('treatment-sig-type')?.value || 'CytoSig';
            const selectedModel = document.getElementById('prediction-model')?.value || 'all';

            if (!data || (!data.roc_curves?.length && !data.feature_importance?.length)) {
                [container1, container2, container3].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Treatment response data will be available after running the analysis pipeline.</p>';
                    }
                });
                return;
            }

            // 1. ROC Curves visualization (actual ROC curves)
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                let rocData = data.roc_curves || [];
                // Filter by signature type
                rocData = rocData.filter(d => d.signature_type === selectedSigType);
                // Handle "All Diseases" - maps to "All Diseases" in data
                if (selectedDisease !== 'all') {
                    rocData = rocData.filter(d => d.disease === selectedDisease);
                } else {
                    // Show "All Diseases" entry when all is selected
                    rocData = rocData.filter(d => d.disease === 'All Diseases');
                }
                if (selectedModel !== 'all') {
                    rocData = rocData.filter(d => d.model === selectedModel);
                }

                if (rocData.length === 0) {
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No ROC data for selected filters</p>';
                } else {
                    // Color palette for different curves
                    const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f'];

                    // Create traces for each ROC curve
                    const traces = rocData.map((d, i) => ({
                        type: 'scatter',
                        mode: 'lines',
                        name: `${d.disease} - ${d.model} (AUC=${d.auc.toFixed(2)})`,
                        x: d.fpr || [0, 1],
                        y: d.tpr || [0, 1],
                        line: { color: colors[i % colors.length], width: 2 },
                        hovertemplate: `<b>${d.disease}</b><br>${d.model}<br>FPR: %{x:.2f}<br>TPR: %{y:.2f}<extra></extra>`
                    }));

                    // Add diagonal reference line
                    traces.push({
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Random (AUC=0.50)',
                        x: [0, 1],
                        y: [0, 1],
                        line: { color: '#ccc', width: 1, dash: 'dash' },
                        hoverinfo: 'skip'
                    });

                    Plotly.newPlot(container1, traces, {
                        xaxis: { title: 'False Positive Rate', range: [0, 1] },
                        yaxis: { title: 'True Positive Rate', range: [0, 1] },
                        margin: { l: 60, r: 30, t: 30, b: 50 },
                        legend: { orientation: 'h', y: -0.25, font: { size: 10 } },
                        height: 400
                    }, { responsive: true });
                }
            }

            // 2. Feature Importance visualization
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                let impData = data.feature_importance || [];
                // Filter by signature type
                impData = impData.filter(d => d.signature_type === selectedSigType);
                // Filter by model
                if (selectedModel !== 'all') {
                    impData = impData.filter(d => d.model === selectedModel);
                }
                // Handle disease filter
                if (selectedDisease !== 'all') {
                    impData = impData.filter(d => d.disease === selectedDisease);
                } else {
                    impData = impData.filter(d => d.disease === 'All Diseases');
                }

                if (impData.length === 0) {
                    container2.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No feature importance data for selected filters</p>';
                } else {
                    const isLR = selectedModel === 'Logistic Regression';

                    // Aggregate importance across records
                    const featureMap = {};
                    impData.forEach(d => {
                        if (!featureMap[d.feature]) {
                            featureMap[d.feature] = { importance: [], coefficient: [] };
                        }
                        featureMap[d.feature].importance.push(d.importance);
                        if (d.coefficient !== undefined) {
                            featureMap[d.feature].coefficient.push(d.coefficient);
                        }
                    });

                    const aggregated = Object.entries(featureMap)
                        .map(([feature, vals]) => ({
                            feature,
                            importance: vals.importance.reduce((a, b) => a + b, 0) / vals.importance.length,
                            coefficient: vals.coefficient.length > 0
                                ? vals.coefficient.reduce((a, b) => a + b, 0) / vals.coefficient.length
                                : null
                        }))
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 15);

                    // For LR, color by coefficient direction (green = positive, red = negative)
                    const colors = isLR
                        ? aggregated.map(d => d.coefficient !== null
                            ? (d.coefficient >= 0 ? '#2ca02c' : '#d62728')
                            : '#1f77b4')
                        : aggregated.map(() => '#2ca02c');

                    const hoverText = isLR
                        ? aggregated.map(d => d.coefficient !== null
                            ? `${d.feature}<br>Importance: ${d.importance.toFixed(3)}<br>Coef: ${d.coefficient.toFixed(3)} (${d.coefficient >= 0 ? '+' : '-'})`
                            : `${d.feature}<br>Importance: ${d.importance.toFixed(3)}`)
                        : aggregated.map(d => `${d.feature}<br>Importance: ${d.importance.toFixed(3)}`);

                    Plotly.newPlot(container2, [{
                        type: 'bar',
                        orientation: 'h',
                        y: aggregated.map(d => d.feature),
                        x: aggregated.map(d => d.importance),
                        marker: { color: colors },
                        text: aggregated.map(d => d.importance.toFixed(3)),
                        textposition: 'auto',
                        hovertext: hoverText,
                        hoverinfo: 'text'
                    }], {
                        xaxis: { title: isLR ? 'Normalized |Coefficient|' : 'Importance Score' },
                        yaxis: { automargin: true },
                        margin: { l: 80, r: 30, t: 30, b: 50 },
                        height: 400,
                        annotations: isLR ? [{
                            x: 0.95, y: 1.05, xref: 'paper', yref: 'paper',
                            text: '<span style="color:#2ca02c">‚ñ†</span> Positive  <span style="color:#d62728">‚ñ†</span> Negative',
                            showarrow: false, font: { size: 11 }
                        }] : []
                    }, { responsive: true });
                }
            }

            // 3. Prediction Violin/Box plots
            if (container3) {
                container3.classList.remove('loading');
                Plotly.purge(container3);

                let predData = data.predictions || [];
                // Filter by signature type
                predData = predData.filter(d => d.signature_type === selectedSigType);
                // Handle disease filter
                if (selectedDisease !== 'all') {
                    predData = predData.filter(d => d.disease === selectedDisease);
                } else {
                    predData = predData.filter(d => d.disease === 'All Diseases');
                }

                if (predData.length === 0) {
                    container3.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No prediction data for selected filters</p>';
                } else {
                    const responders = predData.filter(d => d.response === 'Responder').map(d => d.probability);
                    const nonResponders = predData.filter(d => d.response === 'Non-responder').map(d => d.probability);

                    Plotly.newPlot(container3, [
                        {
                            type: 'violin',
                            y: responders,
                            name: 'Responder',
                            box: { visible: true },
                            meanline: { visible: true },
                            fillcolor: '#2ca02c',
                            line: { color: '#2ca02c' }
                        },
                        {
                            type: 'violin',
                            y: nonResponders,
                            name: 'Non-responder',
                            box: { visible: true },
                            meanline: { visible: true },
                            fillcolor: '#d62728',
                            line: { color: '#d62728' }
                        }
                    ], {
                        yaxis: { title: 'Predicted Probability', range: [0, 1] },
                        margin: { l: 50, r: 30, t: 30, b: 50 },
                        showlegend: true,
                        height: 350
                    }, { responsive: true });
                }
            }
        }

        // Inflammation: Disease Sankey - Study ‚Üí Disease ‚Üí Disease Group
        function updateDiseaseSankey() {
            const container = document.getElementById('disease-sankey');
            if (!container) return;
            container.classList.remove('loading');

            const sankeyData = state.data.diseasesankey;

            if (!sankeyData || !sankeyData.nodes || !sankeyData.links) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No sankey data available</p>';
                return;
            }

            // Use all nodes and links to show: Study ‚Üí Disease ‚Üí Disease Group
            const nodeLabels = sankeyData.nodes.map(n => n.name);

            // Assign colors based on node type
            const nodeColors = sankeyData.nodes.map(n => {
                if (n.type === 'cohort') return '#1f77b4';      // Blue for studies
                if (n.type === 'disease') return '#ff7f0e';     // Orange for diseases
                if (n.type === 'disease_group') return '#2ca02c'; // Green for disease groups
                return '#7f7f7f';
            });

            Plotly.purge(container);
            Plotly.newPlot(container, [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 15,
                    thickness: 20,
                    line: { color: 'black', width: 0.5 },
                    label: nodeLabels,
                    color: nodeColors,
                    hovertemplate: '<b>%{label}</b><br>Samples: %{value}<extra></extra>'
                },
                link: {
                    source: sankeyData.links.map(l => l.source),
                    target: sankeyData.links.map(l => l.target),
                    value: sankeyData.links.map(l => l.value),
                    hovertemplate: '%{source.label} ‚Üí %{target.label}<br>Samples: %{value}<extra></extra>'
                }
            }], {
                margin: { t: 30, b: 30, l: 50, r: 50 },
                height: 600
            }, { responsive: true });
        }

        // Inflammation: Cohort Validation
        function updateCohortValidation() {
            const container1 = document.getElementById('cohort-scatter');
            const container2 = document.getElementById('cohort-consistency');

            const data = state.data.cohortvalidation;

            if (!data || (!data.correlations?.length && !data.consistency?.length)) {
                [container1, container2].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Cross-cohort validation data will be available after running the full pipeline.</p>';
                    }
                });
                return;
            }

            // Get filter selections
            const sigType = document.getElementById('validation-sig-type')?.value || 'CytoSig';
            const cohortComparison = document.getElementById('validation-cohorts')?.value || 'main-validation';

            // Filter correlations by signature type
            let correlations = data.correlations || [];
            if (sigType !== 'both') {
                correlations = correlations.filter(d => d.signature_type === sigType);
            }

            // Determine which correlation values to use based on cohort comparison
            let xKey, yKey, xLabel, yLabel;
            if (cohortComparison === 'main-validation') {
                // Show histogram of Main vs Validation correlations
                xKey = 'main_validation_r';
                xLabel = 'Main vs Validation (r)';
            } else if (cohortComparison === 'main-external') {
                xKey = 'main_external_r';
                xLabel = 'Main vs External (r)';
            } else {
                // validation-external
                xKey = 'validation_external_r';
                xLabel = 'Validation vs External (r)';
            }

            // 1. Histogram of correlation values for selected comparison
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                if (correlations.length === 0) {
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No correlation data available for selected signature type</p>';
                } else {
                    // Get correlation values for the selected comparison
                    const rValues = correlations
                        .map(d => d[xKey])
                        .filter(v => v !== null && v !== undefined && !isNaN(v));

                    if (rValues.length === 0) {
                        container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data available for selected cohort comparison</p>';
                    } else {
                        // Calculate statistics
                        const meanR = rValues.reduce((a, b) => a + b, 0) / rValues.length;
                        const sortedR = [...rValues].sort((a, b) => a - b);
                        const medianR = sortedR[Math.floor(sortedR.length / 2)];

                        // Create histogram with individual points overlay
                        const histTrace = {
                            type: 'histogram',
                            x: rValues,
                            name: 'Distribution',
                            marker: {
                                color: '#1f77b4',
                                opacity: 0.7
                            },
                            xbins: { start: 0, end: 1, size: 0.05 },
                            hovertemplate: 'r: %{x:.2f}<br>Count: %{y}<extra></extra>'
                        };

                        // Add vertical lines for mean and median
                        const shapes = [
                            {
                                type: 'line',
                                x0: meanR, x1: meanR, y0: 0, y1: 1, yref: 'paper',
                                line: { color: '#d62728', width: 2, dash: 'dash' }
                            },
                            {
                                type: 'line',
                                x0: medianR, x1: medianR, y0: 0, y1: 1, yref: 'paper',
                                line: { color: '#2ca02c', width: 2, dash: 'dot' }
                            }
                        ];

                        // Add annotations
                        const annotations = [
                            {
                                x: meanR, y: 1, yref: 'paper', xanchor: 'left',
                                text: ` Mean: ${meanR.toFixed(3)}`, showarrow: false,
                                font: { color: '#d62728', size: 11 }
                            },
                            {
                                x: medianR, y: 0.9, yref: 'paper', xanchor: 'left',
                                text: ` Median: ${medianR.toFixed(3)}`, showarrow: false,
                                font: { color: '#2ca02c', size: 11 }
                            }
                        ];

                        Plotly.newPlot(container1, [histTrace], {
                            xaxis: { title: xLabel, range: [0, 1] },
                            yaxis: { title: 'Number of Signatures' },
                            margin: { l: 60, r: 30, t: 40, b: 60 },
                            height: 450,
                            shapes: shapes,
                            annotations: annotations,
                            title: {
                                text: `${sigType} Signature Reproducibility (n=${rValues.length})`,
                                font: { size: 14 }
                            }
                        }, { responsive: true });
                    }
                }
            }

            // 2. Consistency comparison bar chart - show all three comparisons for selected sig type
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                let consistency = data.consistency || [];
                // Filter by signature type
                if (sigType !== 'both') {
                    consistency = consistency.filter(d => d.signature_type === sigType);
                }

                if (consistency.length === 0) {
                    container2.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No consistency data available</p>';
                } else {
                    // Sort by cohort_pair for consistent ordering
                    const order = ['Main vs Validation', 'Main vs External', 'Validation vs External'];
                    consistency = consistency.sort((a, b) => order.indexOf(a.cohort_pair) - order.indexOf(b.cohort_pair));

                    // Highlight the selected comparison
                    const selectedLabel = cohortComparison === 'main-validation' ? 'Main vs Validation' :
                                         cohortComparison === 'main-external' ? 'Main vs External' :
                                         'Validation vs External';

                    const colors = consistency.map(d =>
                        d.cohort_pair === selectedLabel ? '#1f77b4' : '#aec7e8'
                    );

                    Plotly.newPlot(container2, [{
                        type: 'bar',
                        x: consistency.map(d => d.cohort_pair),
                        y: consistency.map(d => d.mean_r),
                        text: consistency.map(d => `r=${d.mean_r.toFixed(3)}`),
                        textposition: 'auto',
                        marker: { color: colors },
                        hovertemplate: '<b>%{x}</b><br>Mean r: %{y:.3f}<br>n = %{customdata} signatures<extra></extra>',
                        customdata: consistency.map(d => d.n_signatures)
                    }], {
                        xaxis: { title: 'Cohort Comparison' },
                        yaxis: { title: 'Mean Correlation', range: [0, 1] },
                        margin: { l: 50, r: 30, t: 40, b: 100 },
                        height: 450,
                        title: {
                            text: `${sigType} Cross-Cohort Consistency`,
                            font: { size: 14 }
                        }
                    }, { responsive: true });
                }
            }
        }

        // ========================================
        // INFLAMMATION PANELS: Severity, Cell Drivers
        // ========================================

        // Inflammation: Severity Analysis
        let severitySignatures = { cytosig: [], secact: [] };

        function initSeverityPanel() {
            const data = state.data.inflammationseverity;
            if (!data || data.length === 0) return;

            // Populate disease dropdown
            const diseases = [...new Set(data.map(d => d.disease))].sort();
            const select = document.getElementById('severity-disease');
            if (select) {
                // Disease display names with severity info
                const diseaseLabels = {
                    'COVID': 'COVID-19 (7 severity stages)',
                    'COPD': 'COPD (GOLD 3-4)',
                    'SLE': 'SLE (Managed/Flare)',
                    'asthma': 'Asthma (GINA 1-4)',
                    'sepsis': 'Sepsis (4 types)',
                    'MS': 'Multiple Sclerosis (FLAIR)',
                    'HBV': 'Hepatitis B (4 stages)',
                    'cirrhosis': 'Cirrhosis (NASH/Alcoholic)',
                    'CRC': 'Colorectal Cancer (MSS/MSI-H)',
                    'HNSCC': 'Head & Neck Cancer (T1-T4)',
                    'NPC': 'Nasopharyngeal Cancer (Stage II-IVa)'
                };
                select.innerHTML = diseases.map(d =>
                    `<option value="${d}">${diseaseLabels[d] || d}</option>`
                ).join('');
            }

            // Build signature lists
            severitySignatures.cytosig = [...new Set(
                data.filter(d => d.signature_type === 'CytoSig').map(d => d.signature)
            )].sort();
            severitySignatures.secact = [...new Set(
                data.filter(d => d.signature_type === 'SecAct').map(d => d.signature)
            )].sort();
        }

        function getSeveritySignatures() {
            const sigType = document.getElementById('severity-sig-type')?.value || 'CytoSig';
            return sigType === 'SecAct' ? severitySignatures.secact : severitySignatures.cytosig;
        }

        function showSeveritySuggestions() {
            const input = document.getElementById('severity-search');
            const div = document.getElementById('severity-suggestions');
            if (!input || !div) return;

            const query = input.value.toLowerCase();
            const sigs = getSeveritySignatures();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query)).slice(0, 15);

            if (filtered.length === 0) { div.style.display = 'none'; return; }

            div.innerHTML = filtered.map(s =>
                `<div style="padding:6px 10px;cursor:pointer;border-bottom:1px solid #eee"
                     onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'"
                     onclick="selectSeveritySig('${s}')">${s}</div>`
            ).join('');
            div.style.display = 'block';
        }

        function selectSeveritySig(sig) {
            const input = document.getElementById('severity-search');
            const div = document.getElementById('severity-suggestions');
            if (input) input.value = sig;
            if (div) div.style.display = 'none';
            updateSeverityCorrelation();
        }

        function updateSeverityCorrelation() {
            const heatmapContainer = document.getElementById('severity-heatmap');
            const lineContainer = document.getElementById('severity-line');
            const boxplotContainer = document.getElementById('severity-boxplot');

            const data = state.data.inflammationseverity;
            if (!data || data.length === 0) {
                [heatmapContainer, lineContainer, boxplotContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Severity data not available. Run preprocessing to generate.</p>';
                    }
                });
                return;
            }

            const disease = document.getElementById('severity-disease')?.value || 'COVID';
            const sigType = document.getElementById('severity-sig-type')?.value || 'CytoSig';
            const selectedSig = document.getElementById('severity-search')?.value || 'IFNG';

            // Filter data for this disease and signature type
            let filtered = data.filter(d => d.disease === disease && d.signature_type === sigType);

            if (filtered.length === 0) {
                [heatmapContainer, lineContainer, boxplotContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No ${sigType} data for ${disease}</p>`;
                    }
                });
                return;
            }

            // Get severity stages in order
            const severityOrder = [...new Set(filtered.map(d => JSON.stringify({s: d.severity, o: d.severity_order})))]
                .map(s => JSON.parse(s))
                .sort((a, b) => a.o - b.o)
                .map(x => x.s);

            // Get top signatures by variance across severity stages
            const sigVariance = {};
            const signatures = [...new Set(filtered.map(d => d.signature))];
            signatures.forEach(sig => {
                const vals = severityOrder.map(sev => {
                    const rec = filtered.find(d => d.signature === sig && d.severity === sev);
                    return rec ? rec.mean_activity : 0;
                });
                const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                sigVariance[sig] = vals.reduce((acc, v) => acc + Math.pow(v - mean, 2), 0) / vals.length;
            });
            const topSigs = Object.entries(sigVariance)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .map(x => x[0]);

            // 1. Heatmap: Signatures √ó Severity stages
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                const zData = topSigs.map(sig =>
                    severityOrder.map(sev => {
                        const rec = filtered.find(d => d.signature === sig && d.severity === sev);
                        return rec ? rec.mean_activity : null;
                    })
                );

                Plotly.newPlot(heatmapContainer, [{
                    z: zData,
                    x: severityOrder,
                    y: topSigs,
                    type: 'heatmap',
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    zmid: 0,
                    colorbar: { title: 'Activity', len: 0.8 },
                    hovertemplate: '<b>%{y}</b><br>%{x}<br>Activity: %{z:.3f}<extra></extra>'
                }], {
                    margin: { l: 100, r: 60, t: 30, b: 100 },
                    xaxis: { title: 'Severity Stage', tickangle: 45 },
                    yaxis: { automargin: true },
                    height: 420
                }, { responsive: true });

                document.getElementById('severity-heatmap-subtitle').textContent =
                    `Top 20 ${sigType} signatures by variance across ${disease} severity stages`;
            }

            // 2. Line chart: Selected signature across severity
            if (lineContainer) {
                lineContainer.classList.remove('loading');
                Plotly.purge(lineContainer);

                // Get data for selected signature
                const sigData = severityOrder.map(sev => {
                    const rec = filtered.find(d => d.signature === selectedSig && d.severity === sev);
                    return {
                        severity: sev,
                        mean: rec ? rec.mean_activity : null,
                        std: rec ? rec.std_activity : 0,
                        n: rec ? rec.n_samples : 0
                    };
                }).filter(d => d.mean !== null);

                if (sigData.length === 0) {
                    lineContainer.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No data for ${selectedSig} in ${disease}</p>`;
                } else {
                    Plotly.newPlot(lineContainer, [{
                        x: sigData.map(d => d.severity),
                        y: sigData.map(d => d.mean),
                        error_y: {
                            type: 'data',
                            array: sigData.map(d => d.std / Math.sqrt(d.n)),
                            visible: true,
                            color: 'rgba(31, 119, 180, 0.5)'
                        },
                        type: 'scatter',
                        mode: 'lines+markers',
                        marker: { size: 10, color: '#1f77b4' },
                        line: { width: 2, color: '#1f77b4' },
                        hovertemplate: '<b>%{x}</b><br>Activity: %{y:.3f}<br>n=%{customdata}<extra></extra>',
                        customdata: sigData.map(d => d.n)
                    }], {
                        margin: { l: 60, r: 30, t: 30, b: 100 },
                        xaxis: { title: 'Severity Stage', tickangle: 45 },
                        yaxis: { title: `${selectedSig} Activity`, zeroline: true },
                        height: 420
                    }, { responsive: true });
                }

                document.getElementById('severity-line-subtitle').textContent =
                    `${selectedSig} activity across ${disease} severity stages (mean ¬± SE)`;
            }

            // 3. Box plot: Distribution comparison
            if (boxplotContainer) {
                boxplotContainer.classList.remove('loading');
                Plotly.purge(boxplotContainer);

                // Show top 5 most variable signatures as grouped boxes
                const top5 = topSigs.slice(0, 5);
                const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd'];

                const traces = top5.map((sig, i) => ({
                    type: 'bar',
                    name: sig,
                    x: severityOrder,
                    y: severityOrder.map(sev => {
                        const rec = filtered.find(d => d.signature === sig && d.severity === sev);
                        return rec ? rec.mean_activity : 0;
                    }),
                    error_y: {
                        type: 'data',
                        array: severityOrder.map(sev => {
                            const rec = filtered.find(d => d.signature === sig && d.severity === sev);
                            return rec ? rec.std_activity : 0;
                        }),
                        visible: true
                    },
                    marker: { color: colors[i] },
                    hovertemplate: '<b>%{x}</b><br>' + sig + ': %{y:.3f}<extra></extra>'
                }));

                Plotly.newPlot(boxplotContainer, traces, {
                    barmode: 'group',
                    margin: { l: 60, r: 30, t: 30, b: 100 },
                    xaxis: { title: 'Severity Stage', tickangle: 45 },
                    yaxis: { title: 'Activity (mean ¬± SD)', zeroline: true },
                    legend: { orientation: 'h', y: -0.25 },
                    height: 380
                }, { responsive: true });

                document.getElementById('severity-boxplot-subtitle').textContent =
                    `Top 5 most variable ${sigType} signatures in ${disease}`;
            }
        }

        // Inflammation: Cell Type Drivers - Search functions
        function getCellDriversSignatures() {
            const data = state.data.inflammationcelldrivers;
            if (!data || !data.effects) return [];
            const sigType = document.getElementById('drivers-sig-type')?.value || 'CytoSig';
            const filtered = data.effects.filter(d => d.signature_type === sigType);
            return [...new Set(filtered.map(d => d.signature))].sort();
        }

        function showDriversSuggestions() {
            const input = document.getElementById('drivers-search');
            const div = document.getElementById('drivers-suggestions');
            if (!input || !div) return;

            const query = input.value.toLowerCase();
            const sigs = getCellDriversSignatures();
            const filtered = sigs.filter(s => s.toLowerCase().includes(query)).slice(0, 15);

            if (filtered.length === 0) { div.style.display = 'none'; return; }

            div.innerHTML = filtered.map(s =>
                `<div style="padding:6px 10px;cursor:pointer;border-bottom:1px solid #eee"
                     onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='white'"
                     onclick="selectDriversSig('${s}')">${s}</div>`
            ).join('');
            div.style.display = 'block';
        }

        function selectDriversSig(sig) {
            const input = document.getElementById('drivers-search');
            const dropdown = document.getElementById('drivers-cytokine');
            const div = document.getElementById('drivers-suggestions');
            if (input) input.value = sig;
            if (dropdown) dropdown.value = sig;
            if (div) div.style.display = 'none';
            updateCellDrivers();
        }

        // Inflammation: Cell Type Drivers
        function updateCellDrivers() {
            const barContainer = document.getElementById('drivers-bar');
            const heatmapContainer = document.getElementById('drivers-heatmap');
            const importanceContainer = document.getElementById('drivers-importance');

            if (!barContainer) return;

            const data = state.data.inflammationcelldrivers;

            // Check if data is available
            if (!data || !data.effects || data.effects.length === 0) {
                [barContainer, heatmapContainer, importanceContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Cell type driver data will be available after running the inflammation analysis.</p>';
                    }
                });
                return;
            }

            const disease = document.getElementById('drivers-disease')?.value || 'RA';
            // Use search input if available, otherwise fall back to dropdown
            const searchInput = document.getElementById('drivers-search')?.value?.trim();
            const signature = searchInput || document.getElementById('drivers-cytokine')?.value || 'IFNG';
            const sigType = document.getElementById('drivers-sig-type')?.value || 'CytoSig';

            // Filter effects by disease, signature, and signature type
            let filtered = data.effects.filter(d =>
                d.disease === disease &&
                d.signature === signature &&
                d.signature_type === sigType
            );

            if (filtered.length === 0) {
                // Try without signature type filter
                filtered = data.effects.filter(d => d.disease === disease && d.signature === signature);
            }

            if (filtered.length === 0) {
                barContainer.classList.remove('loading');
                barContainer.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No data for ${signature} in ${disease}</p>`;
                return;
            }

            // Sort by effect size
            const effects = filtered.sort((a, b) => b.effect - a.effect).slice(0, 20);

            // 1. Bar chart of effect sizes
            barContainer.classList.remove('loading');
            Plotly.purge(barContainer);

            Plotly.newPlot(barContainer, [{
                type: 'bar',
                orientation: 'h',
                y: effects.map(d => d.cell_type),
                x: effects.map(d => d.effect),
                marker: {
                    color: effects.map(d => d.pvalue < 0.05 ? (d.effect > 0 ? '#d62728' : '#2ca02c') : '#ccc')
                },
                text: effects.map(d => d.pvalue < 0.05 ? '*' : ''),
                textposition: 'outside',
                hovertemplate: '<b>%{y}</b><br>Effect: %{x:.3f}<br>p = %{customdata[0]:.4f}<br>n_healthy = %{customdata[1]}, n_disease = %{customdata[2]}<extra></extra>',
                customdata: effects.map(d => [d.pvalue, d.n_healthy, d.n_disease])
            }], {
                xaxis: { title: `${signature} Effect Size (Disease vs Matched Healthy)`, zeroline: true },
                yaxis: { automargin: true },
                margin: { l: 150, r: 50, t: 30, b: 50 },
                height: Math.max(300, effects.length * 25),
                annotations: [{
                    x: 0.95, y: 1.02, xref: 'paper', yref: 'paper',
                    text: '<span style="color:#d62728">‚ÜëDisease</span> | <span style="color:#2ca02c">‚ÜëHealthy</span>', showarrow: false, font: { size: 10 }
                }]
            }, { responsive: true });

            // 2. Heatmap of signatures √ó cell types for this disease
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                // Get all effects for this disease
                const diseaseEffects = data.effects.filter(d => d.disease === disease && d.signature_type === sigType);

                // Get unique signatures and cell types
                const signatures = [...new Set(diseaseEffects.map(d => d.signature))].slice(0, 15);
                const cellTypes = [...new Set(diseaseEffects.map(d => d.cell_type))].slice(0, 15);

                // Build matrix
                const zData = cellTypes.map(ct => {
                    return signatures.map(sig => {
                        const effect = diseaseEffects.find(d => d.cell_type === ct && d.signature === sig);
                        return effect ? effect.effect : 0;
                    });
                });

                Plotly.newPlot(heatmapContainer, [{
                    type: 'heatmap',
                    z: zData,
                    x: signatures,
                    y: cellTypes,
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    zmid: 0,
                    colorbar: { title: 'Effect' },
                    hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.3f}<extra></extra>'
                }], {
                    margin: { l: 150, r: 50, t: 30, b: 100 },
                    xaxis: { tickangle: 45 },
                    height: Math.max(350, cellTypes.length * 25)
                }, { responsive: true });
            }

            // 3. Importance plot - sum of absolute effects per cell type
            if (importanceContainer) {
                importanceContainer.classList.remove('loading');
                Plotly.purge(importanceContainer);

                // Aggregate absolute effects by cell type
                const diseaseEffects = data.effects.filter(d => d.disease === disease && d.signature_type === sigType);
                const ctEffects = {};
                diseaseEffects.forEach(d => {
                    if (!ctEffects[d.cell_type]) ctEffects[d.cell_type] = 0;
                    ctEffects[d.cell_type] += Math.abs(d.effect);
                });

                const importance = Object.entries(ctEffects)
                    .map(([ct, total]) => ({ cellType: ct, variance: total }))
                    .sort((a, b) => b.variance - a.variance)
                    .slice(0, 15);

                const totalVar = importance.reduce((sum, d) => sum + d.variance, 0);
                const cumulative = importance.reduce((acc, d) => {
                    const prev = acc.length > 0 ? acc[acc.length - 1] : 0;
                    acc.push(prev + d.variance / totalVar * 100);
                    return acc;
                }, []);

                Plotly.newPlot(importanceContainer, [
                    {
                        type: 'bar',
                        x: importance.map(d => d.cellType),
                        y: importance.map(d => d.variance / totalVar * 100),
                        name: 'Individual',
                        marker: { color: '#1f77b4' }
                    },
                    {
                        type: 'scatter',
                        mode: 'lines+markers',
                        x: importance.map(d => d.cellType),
                        y: cumulative,
                        name: 'Cumulative',
                        yaxis: 'y2',
                        line: { color: '#ff7f0e' },
                        marker: { size: 8 }
                    }
                ], {
                    xaxis: { tickangle: 45 },
                    yaxis: { title: 'Total Effect Contribution (%)', side: 'left' },
                    yaxis2: { title: 'Cumulative %', side: 'right', overlaying: 'y', range: [0, 100] },
                    margin: { l: 60, r: 60, t: 30, b: 150 },
                    legend: { orientation: 'h', y: 1.1 },
                    height: 400
                }, { responsive: true });
            }
        }

        // scAtlas: Immune Infiltration
        function updateImmuneInfiltration() {
            const container1 = document.getElementById('infiltration-stacked');
            const container2 = document.getElementById('infiltration-scatter');
            const title1 = document.getElementById('infiltration-stacked-title');
            const subtitle1 = document.getElementById('infiltration-stacked-subtitle');
            const title2 = document.getElementById('infiltration-scatter-title');
            const subtitle2 = document.getElementById('infiltration-scatter-subtitle');

            // Use real infiltration data if available
            const data = state.data.immuneinfiltration;

            if (!data || (!data.data?.length && !data.composition?.length)) {
                [container1, container2].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Immune infiltration data will be available after running scAtlas cancer analysis.</p>';
                    }
                });
                return;
            }

            // Common colors for immune cell categories
            const categoryColors = {
                'T_cell': '#1f77b4', 'CD8_T': '#2ca02c', 'CD4_T': '#98df8a',
                'Treg': '#d62728', 'NK': '#ff7f0e', 'B_cell': '#9467bd',
                'Macrophage': '#8c564b', 'Monocyte': '#e377c2', 'DC': '#bcbd22',
                'Neutrophil': '#17becf', 'Mast': '#7f7f7f', 'ILC': '#aec7e8'
            };
            const categories = data.immune_categories || ['T_cell', 'NK', 'ILC', 'B_cell', 'Macrophage', 'Monocyte', 'DC', 'Mast'];

            // Set titles
            if (title1) title1.textContent = 'Immune Cell Composition within TME';
            if (subtitle1) subtitle1.textContent = 'Breakdown of immune cell types in the tumor microenvironment';
            if (title2) title2.textContent = 'Tumor-Infiltrating Lymphocytes (TIL)';
            if (subtitle2) subtitle2.textContent = 'Lymphocyte proportion (T, B, NK, ILC cells) of TME';

                const composition = data.composition || [];
                const tmeSummary = data.tme_summary || [];
                const cancerTypes = tmeSummary.length
                    ? tmeSummary.map(d => d.cancer_type).sort((a, b) => {
                        const aData = tmeSummary.find(t => t.cancer_type === a);
                        const bData = tmeSummary.find(t => t.cancer_type === b);
                        return (bData?.immune_proportion || 0) - (aData?.immune_proportion || 0);
                    })
                    : [...new Set(composition.map(d => d.cancer_type))];

                // Stacked bar showing immune composition WITHIN immune cells
                if (container1 && (composition.length || tmeSummary.length)) {
                    container1.classList.remove('loading');
                    Plotly.purge(container1);

                    // Use proportion_of_immune from composition, or immune_* from tme_summary
                    const traces = categories.map(cat => ({
                        type: 'bar',
                        name: cat.replace(/_/g, ' '),
                        x: cancerTypes,
                        y: cancerTypes.map(ct => {
                            // Try composition first (more detailed)
                            const entry = composition.find(d => d.cancer_type === ct && d.cell_category === cat);
                            if (entry && entry.proportion_of_immune !== undefined) {
                                return entry.proportion_of_immune;
                            }
                            // Fall back to tme_summary
                            const tmeEntry = tmeSummary.find(d => d.cancer_type === ct);
                            if (tmeEntry && tmeEntry[`immune_${cat}`] !== undefined) {
                                return tmeEntry[`immune_${cat}`];
                            }
                            return entry ? entry.proportion : 0;
                        }),
                        marker: { color: categoryColors[cat] || '#666' },
                        hovertemplate: `<b>${cat.replace(/_/g, ' ')}</b><br>%{x}: %{y:.1%} of immune cells<extra></extra>`
                    }));

                    Plotly.newPlot(container1, traces, {
                        barmode: 'stack',
                        xaxis: { title: 'Cancer Type', tickangle: 45 },
                        yaxis: { title: 'Immune Cell Composition', tickformat: '.0%', range: [0, 1.05] },
                        margin: { l: 60, r: 30, t: 60, b: 100 },
                        legend: { orientation: 'h', y: 1.18, x: 0.5, xanchor: 'center', font: { size: 9 } },
                        height: 480
                    }, { responsive: true });
                }

                // Bar chart with clinical ratios using TME summary
                if (container2) {
                    container2.classList.remove('loading');
                    Plotly.purge(container2);

                    // Use TME summary if available, fall back to data
                    const tmeSummary = data.tme_summary || [];

                    if (tmeSummary.length) {
                        if (title2) title2.textContent = 'Tumor-Infiltrating Lymphocytes (TIL)';
                        if (subtitle2) subtitle2.textContent = 'Lymphocyte proportion (T, B, NK, ILC) of TME';

                        // Compute lymphocyte proportion (T + B + NK + ILC) from immune_* fields
                        const withTIL = tmeSummary.map(d => {
                            const lymphocyteCategories = ['T_cell', 'B_cell', 'NK', 'ILC'];
                            const lymphPropWithinImmune = lymphocyteCategories.reduce((sum, cat) =>
                                sum + (d[`immune_${cat}`] || 0), 0);
                            // TIL proportion of TME = lymphocyte proportion within immune * immune proportion
                            const tilProportion = lymphPropWithinImmune * d.immune_proportion;
                            return { ...d, til_proportion: tilProportion, lymph_within_immune: lymphPropWithinImmune };
                        });

                        const sorted = [...withTIL].sort((a, b) => b.til_proportion - a.til_proportion);

                        Plotly.newPlot(container2, [{
                            type: 'bar',
                            x: sorted.map(d => d.cancer_type),
                            y: sorted.map(d => d.til_proportion),
                            marker: { color: '#1f77b4' },
                            hovertemplate: sorted.map(d => {
                                const cd8treg = d.cd8_treg_ratio ? d.cd8_treg_ratio.toFixed(1) : 'N/A';
                                const lymphPct = (d.lymph_within_immune * 100).toFixed(1);
                                return `<b>${d.cancer_type}</b><br>` +
                                    `TIL: ${(d.til_proportion * 100).toFixed(1)}% of TME<br>` +
                                    `Lymphocytes: ${lymphPct}% of immune<br>` +
                                    `Total immune: ${(d.immune_proportion * 100).toFixed(1)}%<br>` +
                                    `CD8:Treg ratio: ${cd8treg}<br>` +
                                    `Samples: ${d.n_samples} | Donors: ${d.n_donors}<extra></extra>`;
                            })
                        }], {
                            xaxis: { title: 'Cancer Type', tickangle: 45 },
                            yaxis: { title: 'TIL Proportion of TME', tickformat: '.0%' },
                            margin: { l: 60, r: 30, t: 30, b: 100 },
                            height: 450
                        }, { responsive: true });
                    } else if (data.data?.length) {
                        // Fallback to original logic
                        const byType = {};
                        data.data.forEach(d => {
                            if (!byType[d.cancer_type]) {
                                byType[d.cancer_type] = {
                                    immune_proportion: d.immune_proportion,
                                    total_cells: d.total_cells,
                                    immune_cells: d.immune_cells
                                };
                            }
                        });

                        const sorted = Object.entries(byType)
                            .sort((a, b) => b[1].immune_proportion - a[1].immune_proportion);

                        Plotly.newPlot(container2, [{
                            type: 'bar',
                            x: sorted.map(d => d[0]),
                            y: sorted.map(d => d[1].immune_proportion),
                            text: sorted.map(d => `${(d[1].immune_proportion * 100).toFixed(1)}%`),
                            textposition: 'auto',
                            marker: { color: sorted.map(d => d[1].immune_proportion), colorscale: 'Blues' },
                            hovertemplate: '<b>%{x}</b><br>Immune: %{y:.1%}<br>Immune cells: %{customdata[0]:,}<br>Total cells: %{customdata[1]:,}<extra></extra>',
                            customdata: sorted.map(d => [d[1].immune_cells, d[1].total_cells])
                        }], {
                            xaxis: { title: 'Cancer Type', tickangle: 45 },
                            yaxis: { title: 'Immune Cell Proportion', tickformat: '.0%' },
                            margin: { l: 60, r: 30, t: 30, b: 100 }
                        }, { responsive: true });
                    }
                }

                // TME Composition stacked bar (Malignant, Immune, Stromal, Other)
                const tmeContainer = document.getElementById('tme-composition');
                const tmeTitle = document.getElementById('tme-composition-title');
                const tmeSubtitle = document.getElementById('tme-composition-subtitle');

                if (tmeContainer && tmeSummary.length) {
                    tmeContainer.classList.remove('loading');
                    Plotly.purge(tmeContainer);

                    if (tmeTitle) tmeTitle.textContent = 'Tumor Microenvironment Composition';
                    if (tmeSubtitle) tmeSubtitle.textContent = 'Full TME breakdown: Malignant, Immune, Stromal, and Other cells';

                    // Sort by immune proportion for consistent ordering
                    const sortedTME = [...tmeSummary].sort((a, b) => b.immune_proportion - a.immune_proportion);

                    const tmeColors = {
                        'Malignant': '#d62728',   // Red for tumor cells
                        'Immune': '#1f77b4',       // Blue for immune cells
                        'Stromal': '#ff7f0e'       // Orange for stromal
                    };

                    const tmeCategories = ['Malignant', 'Immune', 'Stromal'];

                    const tmeTraces = tmeCategories.map(cat => ({
                        type: 'bar',
                        name: cat,
                        x: sortedTME.map(d => d.cancer_type),
                        y: sortedTME.map(d => d[`${cat.toLowerCase()}_proportion`] || 0),
                        marker: { color: tmeColors[cat] },
                        hovertemplate: sortedTME.map(d => {
                            const prop = d[`${cat.toLowerCase()}_proportion`] || 0;
                            const count = d[`${cat.toLowerCase()}_cells`] || 0;
                            return `<b>${cat}</b><br>` +
                                `${d.cancer_type}: ${(prop * 100).toFixed(1)}%<br>` +
                                `Cells: ${count.toLocaleString()}<extra></extra>`;
                        })
                    }));

                    // Check for sample_notes (cancer types without malignant cells)
                    const notedCancers = sortedTME.filter(d => d.sample_note);
                    const noteLines = notedCancers.map(d => `* ${d.cancer_type}: ${d.sample_note}`);
                    const hasNotes = noteLines.length > 0;

                    Plotly.newPlot(tmeContainer, tmeTraces, {
                        barmode: 'stack',
                        xaxis: { title: 'Cancer Type', tickangle: 45 },
                        yaxis: { title: 'Proportion of TME', tickformat: '.0%', range: [0, 1.05] },
                        margin: { l: 60, r: 30, t: 50, b: hasNotes ? 160 : 100 },
                        legend: {
                            orientation: 'h',
                            y: 1.15,
                            x: 0.5,
                            xanchor: 'center',
                            font: { size: 11 }
                        },
                        annotations: hasNotes ? [{
                            x: 0.5, y: -0.48, xref: 'paper', yref: 'paper',
                            text: noteLines.join('  |  '),
                            showarrow: false,
                            font: { size: 8, color: '#888' },
                            xanchor: 'center'
                        }] : [],
                        height: hasNotes ? 480 : 400
                    }, { responsive: true });
                } else if (tmeContainer) {
                    tmeContainer.classList.remove('loading');
                    tmeContainer.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">TME composition data not available. Run scAtlas immune analysis to generate.</p>';
                }
        }

        // scAtlas: T Cell State - cached data for boxplot updates
        let tcellFunctionCache = {
            stateActivity: {},
            signatures: [],
            topSigs: [],
            states: ['exhausted', 'cytotoxic', 'memory', 'naive'],
            stateColors: {
                'exhausted': '#d62728',
                'cytotoxic': '#2ca02c',
                'memory': '#1f77b4',
                'naive': '#ff7f0e',
                'other_tcell': '#7f7f7f'
            },
            stateLabels: {
                'exhausted': 'Exhausted',
                'cytotoxic': 'Cytotoxic',
                'memory': 'Memory',
                'naive': 'Naive',
                'other_tcell': 'Other'
            }
        };

        // Update signature dropdown list based on signature type
        function updateTcellSignatureList() {
            const data = state.data.exhaustion;
            if (!data) return;

            const sigType = document.getElementById('tcell-sigtype')?.value || 'cytosig';
            const dropdown = document.getElementById('tcell-signature');
            if (!dropdown) return;

            // Get signatures for this type
            const signatures = sigType === 'cytosig'
                ? (data.cytosig_signatures || data.signatures || [])
                : (data.secact_signatures || []);

            // Clear and repopulate
            dropdown.innerHTML = '<option value="top">Top 6 differential</option>';
            signatures.sort().forEach(sig => {
                const opt = document.createElement('option');
                opt.value = sig;
                opt.textContent = sig;
                dropdown.appendChild(opt);
            });

            // Clear search
            const searchInput = document.getElementById('tcell-sig-search');
            if (searchInput) searchInput.value = '';
        }

        // Filter signature dropdown based on search input
        function filterTcellSignatures() {
            const searchInput = document.getElementById('tcell-sig-search');
            const dropdown = document.getElementById('tcell-signature');
            if (!searchInput || !dropdown) return;

            const searchTerm = searchInput.value.toLowerCase();
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const opt = options[i];
                if (opt.value === 'top') {
                    opt.style.display = '';  // Always show "Top 6" option
                } else {
                    opt.style.display = opt.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
                }
            }
        }

        // Update just the boxplot based on selected signature
        function updateTcellBoxplot() {
            const comparisonContainer = document.getElementById('tcell-state-comparison');
            if (!comparisonContainer) return;

            const selectedSig = document.getElementById('tcell-signature')?.value || 'top';
            const { stateActivity, topSigs, states, stateColors, stateLabels } = tcellFunctionCache;

            if (Object.keys(stateActivity).length === 0) return;

            comparisonContainer.classList.remove('loading');
            Plotly.purge(comparisonContainer);

            // Determine which signatures to show
            const sigsToShow = selectedSig === 'top' ? topSigs.slice(0, 6) : [selectedSig];
            const traces = [];

            // Create box plot traces for each state
            states.forEach(s => {
                sigsToShow.forEach(sig => {
                    const vals = stateActivity[s]?.[sig] || [];
                    if (vals.length > 0) {
                        traces.push({
                            type: 'box',
                            name: stateLabels[s],
                            x: vals.map(() => sig),
                            y: vals,
                            marker: { color: stateColors[s] },
                            boxpoints: sigsToShow.length === 1 ? 'outliers' : false,
                            legendgroup: s,
                            showlegend: sigsToShow.indexOf(sig) === 0,
                            hovertemplate: `<b>${stateLabels[s]}</b><br>${sig}<br>Median: %{y:.2f}<extra></extra>`
                        });
                    }
                });
            });

            const layout = {
                boxmode: 'group',
                xaxis: { title: sigsToShow.length > 1 ? 'Signature' : '', tickangle: sigsToShow.length > 3 ? 45 : 0 },
                yaxis: { title: 'Activity (z-score)' },
                margin: { l: 60, r: 30, t: 30, b: sigsToShow.length > 3 ? 100 : 50 },
                legend: { orientation: 'h', y: 1.1 },
                height: 380
            };

            // Add title annotation for single signature
            if (sigsToShow.length === 1) {
                layout.annotations = [{
                    x: 0.5, y: 1.05, xref: 'paper', yref: 'paper',
                    text: `<b>${sigsToShow[0]}</b> Activity by T Cell State`,
                    showarrow: false, font: { size: 14 }
                }];
            }

            Plotly.newPlot(comparisonContainer, traces, layout, { responsive: true });
        }

        // scAtlas: T Cell State
        function updateTcellFunction() {
            const heatmapContainer = document.getElementById('tcell-state-heatmap');
            const barContainer = document.getElementById('tcell-state-bar');
            const comparisonContainer = document.getElementById('tcell-state-comparison');

            const data = state.data.exhaustion;

            if (!data || !data.data?.length) {
                [heatmapContainer, barContainer, comparisonContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">T cell function data not available. Run scAtlas immune analysis to generate.</p>';
                    }
                });
                return;
            }

            // Get filter values
            const sigType = document.getElementById('tcell-sigtype')?.value || 'cytosig';
            const selectedCancer = document.getElementById('tcell-cancer')?.value || 'all';

            // Populate cancer dropdown
            const cancerDropdown = document.getElementById('tcell-cancer');
            if (cancerDropdown && cancerDropdown.options.length <= 1) {
                const cancerTypes = [...new Set(data.data.map(d => d.cancer_type))].sort();
                cancerTypes.forEach(ct => {
                    const opt = document.createElement('option');
                    opt.value = ct;
                    opt.textContent = ct;
                    cancerDropdown.appendChild(opt);
                });
            }

            // Filter data by signature type and cancer type
            let stateData = data.data;
            if (stateData.length > 0 && stateData[0].signature_type) {
                stateData = stateData.filter(d => d.signature_type === sigType);
            }
            if (selectedCancer !== 'all') {
                stateData = stateData.filter(d => d.cancer_type === selectedCancer);
            }

            // Get signatures for this type (fallback to extracting from data if explicit lists not available)
            const uniqueSigsFromData = [...new Set(stateData.map(d => d.signature))];
            const signatures = sigType === 'cytosig'
                ? (data.cytosig_signatures || data.signatures || uniqueSigsFromData)
                : (data.secact_signatures || uniqueSigsFromData);

            // Aggregate by state and signature
            const stateColors = {
                'exhausted': '#d62728',
                'cytotoxic': '#2ca02c',
                'memory': '#1f77b4',
                'naive': '#ff7f0e',
                'other_tcell': '#7f7f7f'
            };
            const stateLabels = {
                'exhausted': 'Exhausted',
                'cytotoxic': 'Cytotoxic',
                'memory': 'Memory',
                'naive': 'Naive',
                'other_tcell': 'Other'
            };
            const states = ['exhausted', 'cytotoxic', 'memory', 'naive'];

            // Aggregate activity by state
            const stateActivity = {};
            const stateCells = {};
            states.forEach(s => { stateActivity[s] = {}; stateCells[s] = 0; });

            stateData.forEach(d => {
                if (!states.includes(d.exhaustion_state)) return;
                if (!stateActivity[d.exhaustion_state][d.signature]) {
                    stateActivity[d.exhaustion_state][d.signature] = [];
                }
                stateActivity[d.exhaustion_state][d.signature].push(d.mean_activity);
                stateCells[d.exhaustion_state] += d.n_cells;
            });

            // Calculate mean per state per signature (use filtered signatures from above)
            const heatmapData = {};
            states.forEach(s => {
                heatmapData[s] = {};
                signatures.forEach(sig => {
                    const vals = stateActivity[s][sig] || [];
                    heatmapData[s][sig] = vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
                });
            });

            // Find top variable signatures
            const sigVariance = signatures.map(sig => {
                const vals = states.map(s => heatmapData[s][sig]);
                const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
                const variance = vals.reduce((a, b) => a + (b - mean) ** 2, 0) / vals.length;
                return { signature: sig, variance };
            }).sort((a, b) => b.variance - a.variance);

            const topSigs = sigVariance.slice(0, 15).map(d => d.signature);

            // Cache data for boxplot updates
            tcellFunctionCache.stateActivity = stateActivity;
            tcellFunctionCache.signatures = signatures;
            tcellFunctionCache.topSigs = topSigs;

            // Initialize signature dropdown if needed
            const sigDropdown = document.getElementById('tcell-signature');
            if (sigDropdown && sigDropdown.options.length <= 1) {
                updateTcellSignatureList();
            }

            // 1. Heatmap of cytokine activity by state
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                const zData = states.map(s => topSigs.map(sig => heatmapData[s][sig]));

                Plotly.newPlot(heatmapContainer, [{
                    type: 'heatmap',
                    z: zData,
                    x: topSigs,
                    y: states.map(s => stateLabels[s]),
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    zmid: 0,
                    colorbar: { title: 'Activity (z-score)', titleside: 'right' },
                    hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.2f}<extra></extra>'
                }], {
                    xaxis: { tickangle: 45 },
                    yaxis: { automargin: true },
                    margin: { l: 80, r: 50, t: 30, b: 120 },
                    height: 400
                }, { responsive: true });
            }

            // 2. Bar chart of cell counts by state
            if (barContainer) {
                barContainer.classList.remove('loading');
                Plotly.purge(barContainer);

                const stateOrder = states.filter(s => stateCells[s] > 0);
                Plotly.newPlot(barContainer, [{
                    type: 'bar',
                    x: stateOrder.map(s => stateLabels[s]),
                    y: stateOrder.map(s => stateCells[s]),
                    marker: { color: stateOrder.map(s => stateColors[s]) },
                    text: stateOrder.map(s => (stateCells[s] / 1e6).toFixed(1) + 'M'),
                    textposition: 'outside',
                    hovertemplate: '<b>%{x}</b><br>Cells: %{y:,.0f}<extra></extra>'
                }], {
                    xaxis: { title: 'T Cell State' },
                    yaxis: { title: 'Cell Count' },
                    margin: { l: 70, r: 30, t: 30, b: 50 },
                    height: 400
                }, { responsive: true });
            }

            // 3. Box plots - use helper function
            updateTcellBoxplot();
        }

        // scAtlas: Exhaustion Differential (Exhausted vs Non-exhausted)
        function updateExhaustion() {
            const container1 = document.getElementById('exhaustion-heatmap');
            const container2 = document.getElementById('exhaustion-scatter');

            // Use real exhaustion data if available
            const data = state.data.exhaustion;

            if (!data || (!data.comparison?.length && !data.data?.length)) {
                [container1, container2].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">T cell exhaustion data will be available after running scAtlas cancer analysis.</p>';
                    }
                });
                return;
            }

            // Get filter values
            const sigType = document.getElementById('exhaustion-sigtype')?.value || 'cytosig';
            const selectedCancer = document.getElementById('exhaustion-cancer')?.value || 'all';

            // Populate cancer dropdown dynamically
            const cancerDropdown = document.getElementById('exhaustion-cancer');
            if (cancerDropdown && cancerDropdown.options.length <= 1) {
                const cancerTypes = [...new Set(data.comparison.map(d => d.cancer_type))].sort();
                cancerTypes.forEach(ct => {
                    const opt = document.createElement('option');
                    opt.value = ct;
                    opt.textContent = ct;
                    cancerDropdown.appendChild(opt);
                });
            }

            // Filter comparison data by signature type and cancer type
            let comparisonData = data.comparison || [];
            if (comparisonData.length > 0 && comparisonData[0].signature_type) {
                comparisonData = comparisonData.filter(d => d.signature_type === sigType);
            }
            if (selectedCancer !== 'all') {
                comparisonData = comparisonData.filter(d => d.cancer_type === selectedCancer);
            }

            // Aggregate comparison across all cancer types
            // Compute activity_diff correctly: mean_exhausted - mean_nonexhausted (z-score difference)
            const sigAggregated = {};
            comparisonData.forEach(d => {
                if (!sigAggregated[d.signature]) {
                    sigAggregated[d.signature] = { mean_exhausted: [], mean_nonexhausted: [], pvalue: [] };
                }
                sigAggregated[d.signature].mean_exhausted.push(d.mean_exhausted);
                sigAggregated[d.signature].mean_nonexhausted.push(d.mean_nonexhausted);
                if (d.pvalue) sigAggregated[d.signature].pvalue.push(d.pvalue);
            });

            const aggregatedList = Object.entries(sigAggregated).map(([sig, vals]) => {
                const meanExhausted = vals.mean_exhausted.reduce((a, b) => a + b, 0) / vals.mean_exhausted.length;
                const meanNonexhausted = vals.mean_nonexhausted.reduce((a, b) => a + b, 0) / vals.mean_nonexhausted.length;
                // Compute activity_diff from means (z-score difference, not stored value which may be wrong)
                const activityDiff = meanExhausted - meanNonexhausted;
                return {
                    signature: sig,
                    activity_diff: activityDiff,
                    mean_exhausted: meanExhausted,
                    mean_nonexhausted: meanNonexhausted,
                    pvalue: vals.pvalue.length > 0 ? vals.pvalue.reduce((a, b) => a + b, 0) / vals.pvalue.length : 1
                };
            });

            // Sort by absolute activity_diff
            const sorted = aggregatedList.sort((a, b) => Math.abs(b.activity_diff) - Math.abs(a.activity_diff));

            // Update titles based on selection
            const sigLabel = sigType === 'cytosig' ? 'CytoSig' : 'SecAct';
            const cancerLabel = selectedCancer === 'all' ? 'All Cancers' : selectedCancer;
            const title1El = container1?.closest('.viz-container')?.querySelector('.viz-title');
            const title2El = container2?.closest('.viz-container')?.querySelector('.viz-title');
            const subtitle1El = container1?.closest('.viz-container')?.querySelector('.viz-subtitle');
            const subtitle2El = container2?.closest('.viz-container')?.querySelector('.viz-subtitle');

            if (title1El) title1El.textContent = `Differential ${sigLabel} Activity`;
            if (subtitle1El) subtitle1El.textContent = `Œî Activity (Exhausted vs Non-exhausted) - ${cancerLabel}`;
            if (title2El) title2El.textContent = `${sigLabel} Activity Correlation`;
            if (subtitle2El) subtitle2El.textContent = `Mean activity comparison - ${cancerLabel}`;

            // 1. Bar chart - exhausted vs non-exhausted activity
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                const top20 = sorted.slice(0, 20);

                Plotly.newPlot(container1, [{
                    type: 'bar',
                    orientation: 'h',
                    y: top20.map(d => d.signature),
                    x: top20.map(d => d.activity_diff),
                    marker: {
                        color: top20.map(d => d.activity_diff > 0 ? '#d62728' : '#2166ac')
                    },
                    text: top20.map(d => d.activity_diff.toFixed(2)),
                    textposition: 'auto',
                    textfont: { size: 10 },
                    hovertemplate: top20.map(d => {
                        const direction = d.activity_diff > 0 ? 'High in Exhausted' : 'High in Non-exhausted';
                        return `<b>${d.signature}</b><br>Œî Activity: ${d.activity_diff.toFixed(3)}<br>${direction}<br>P-value: ${d.pvalue.toExponential(2)}<extra></extra>`;
                    })
                }], {
                    xaxis: { title: '‚Üê High in Non-exhausted    Œî Activity    High in Exhausted ‚Üí', zeroline: true, zerolinewidth: 2 },
                    yaxis: { automargin: true },
                    margin: { l: 100, r: 30, t: 30, b: 60 },
                    height: 500,
                    annotations: [{
                        x: -0.5, y: 1.02, xref: 'paper', yref: 'paper',
                        text: '<span style="color:#2166ac">‚ñ†</span> Non-exhausted T cells',
                        showarrow: false, font: { size: 10 }, xanchor: 'left'
                    }, {
                        x: 0.5, y: 1.02, xref: 'paper', yref: 'paper',
                        text: '<span style="color:#d62728">‚ñ†</span> Exhausted T cells',
                        showarrow: false, font: { size: 10 }, xanchor: 'left'
                    }]
                }, { responsive: true });
            }

            // 2. Scatter: mean exhausted vs non-exhausted
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                if (aggregatedList.length === 0) {
                    container2.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data available for selected filters.</p>';
                    return;
                }

                // For SecAct (many signatures), only show labels for top differential
                const showLabels = sigType === 'cytosig' || aggregatedList.length <= 50;
                const topLabeled = sorted.slice(0, 10).map(d => d.signature);

                Plotly.newPlot(container2, [{
                    type: 'scatter',
                    mode: showLabels ? 'markers+text' : 'markers',
                    x: aggregatedList.map(d => d.mean_nonexhausted),
                    y: aggregatedList.map(d => d.mean_exhausted),
                    text: aggregatedList.map(d => d.signature),
                    textposition: 'top center',
                    textfont: { size: 8 },
                    marker: {
                        size: showLabels ? 8 : 10,
                        color: aggregatedList.map(d => d.activity_diff),
                        colorscale: [[0, '#2166ac'], [0.5, '#f5f5f5'], [1, '#d62728']],
                        cmin: -1,
                        cmax: 1,
                        colorbar: { title: 'Œî Activity' }
                    },
                    hovertemplate: '<b>%{text}</b><br>Non-exhausted: %{x:.3f}<br>Exhausted: %{y:.3f}<extra></extra>'
                }], {
                    xaxis: { title: 'Mean Activity (Non-exhausted T cells)' },
                    yaxis: { title: 'Mean Activity (Exhausted T cells)' },
                    margin: { l: 60, r: 30, t: 30, b: 50 },
                    shapes: [{
                        type: 'line', x0: -3, y0: -3, x1: 3, y1: 3,
                        line: { dash: 'dash', color: '#ccc' }
                    }],
                    annotations: showLabels ? [] : topLabeled.map(sig => {
                        const d = aggregatedList.find(x => x.signature === sig);
                        return {
                            x: d.mean_nonexhausted,
                            y: d.mean_exhausted,
                            text: sig,
                            showarrow: true,
                            arrowhead: 0,
                            ax: 20,
                            ay: -20,
                            font: { size: 9 }
                        };
                    })
                }, { responsive: true });
            }
        }

        // ========================================
        // NEW scAtlas PANELS: CAF Classification, Organ-Cancer Matrix, Adjacent Tissue
        // ========================================

        // scAtlas: CAF Classification
        function updateCafClassification() {
            const barContainer = document.getElementById('caf-activity-bar');
            const proportionsContainer = document.getElementById('caf-proportions');
            const heatmapContainer = document.getElementById('caf-heatmap');

            if (!barContainer) return;

            // Use real CAF data if available
            const data = state.data.cafsignatures;

            if (!data || (!data.data?.length && !data.subtypes?.length)) {
                [barContainer, proportionsContainer, heatmapContainer].forEach(c => {
                    if (c) {
                        c.classList.remove('loading');
                        c.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">CAF signature data will be available after running scAtlas cancer analysis.</p>';
                    }
                });
                return;
            }

            const cancerType = document.getElementById('caf-cancer-type')?.value || 'all';
            const sigType = document.getElementById('caf-sig-type')?.value || 'CytoSig';

            // Use subtypes data for detailed CAF analysis
            let filtered = data.subtypes || data.data;
            if (cancerType !== 'all') {
                filtered = filtered.filter(d => d.cancer_type === cancerType);
            }

            // Get unique CAF classes/subtypes
            const cafClasses = data.caf_classes || ['myCAF', 'iCAF', 'apCAF', 'Other'];
            const cafSubtypes = [...new Set(filtered.map(d => d.caf_subtype || d.caf_class))].slice(0, 10);
            const signatures = data.signatures || [...new Set(filtered.map(d => d.signature))];
            const cancerTypes = [...new Set((data.proportions || data.data).map(d => d.cancer_type))];

            const cafColors = {
                'myCAF': '#1f77b4', 'iCAF': '#ff7f0e', 'apCAF': '#2ca02c', 'Other': '#7f7f7f',
                'All_CAF': '#9467bd'
            };
            const defaultColors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f'];

            // 1. Bar chart - activity by CAF class (aggregated)
            barContainer.classList.remove('loading');
            Plotly.purge(barContainer);

            // Aggregate by caf_class across all subtypes
            const byClass = {};
            cafClasses.forEach(cls => byClass[cls] = {});
            filtered.forEach(d => {
                const cls = d.caf_class || 'Other';
                if (!byClass[cls]) byClass[cls] = {};
                if (!byClass[cls][d.signature]) byClass[cls][d.signature] = [];
                byClass[cls][d.signature].push(d.mean_activity);
            });

            const topSigs = signatures.slice(0, 15);
            const traces = cafClasses.filter(cls => Object.keys(byClass[cls] || {}).length > 0).map((cls, idx) => ({
                type: 'bar',
                name: cls,
                x: topSigs,
                y: topSigs.map(sig => {
                    const vals = byClass[cls]?.[sig] || [];
                    return vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
                }),
                marker: { color: cafColors[cls] || defaultColors[idx % defaultColors.length] }
            }));

            Plotly.newPlot(barContainer, traces, {
                barmode: 'group',
                xaxis: { tickangle: 45 },
                yaxis: { title: 'Mean Activity (z-score)' },
                margin: { l: 60, r: 30, t: 30, b: 100 },
                legend: { orientation: 'h', y: 1.12 },
                height: 450
            }, { responsive: true });

            // 2. CAF subtype breakdown by cancer type (stacked bar chart)
            if (proportionsContainer && data.subtypes?.length) {
                proportionsContainer.classList.remove('loading');
                Plotly.purge(proportionsContainer);

                // Aggregate cell counts by cancer_type and caf_class
                // Each subtype record has n_cells, but we need to dedupe by (cancer, class, subtype)
                const cellsByCanerClass = {};
                const seenSubtypes = new Set();

                data.subtypes.forEach(d => {
                    const key = `${d.cancer_type}|${d.caf_class}|${d.caf_subtype}`;
                    if (!seenSubtypes.has(key)) {
                        seenSubtypes.add(key);
                        if (!cellsByCanerClass[d.cancer_type]) {
                            cellsByCanerClass[d.cancer_type] = { myCAF: 0, iCAF: 0, apCAF: 0, Other: 0, total: 0 };
                        }
                        const cls = d.caf_class || 'Other';
                        cellsByCanerClass[d.cancer_type][cls] += d.n_cells || 0;
                        cellsByCanerClass[d.cancer_type].total += d.n_cells || 0;
                    }
                });

                // Sort cancer types by total CAF cells
                const sortedCancers = Object.keys(cellsByCanerClass)
                    .filter(c => cellsByCanerClass[c].total > 100)
                    .sort((a, b) => cellsByCanerClass[b].total - cellsByCanerClass[a].total);

                if (sortedCancers.length > 0) {
                    // Create stacked bar traces for each CAF class
                    const cafClassOrder = ['myCAF', 'iCAF', 'apCAF', 'Other'];
                    const traces = cafClassOrder.map(cls => ({
                        type: 'bar',
                        name: cls,
                        x: sortedCancers,
                        y: sortedCancers.map(cancer => {
                            const total = cellsByCanerClass[cancer].total;
                            return total > 0 ? cellsByCanerClass[cancer][cls] / total : 0;
                        }),
                        text: sortedCancers.map(cancer => {
                            const cells = cellsByCanerClass[cancer][cls];
                            return cells > 0 ? cells.toLocaleString() : '';
                        }),
                        hovertemplate: `<b>%{x}</b><br>${cls}: %{y:.1%} (%{text} cells)<extra></extra>`,
                        marker: { color: cafColors[cls] }
                    }));

                    Plotly.newPlot(proportionsContainer, traces, {
                        barmode: 'stack',
                        xaxis: { title: 'Cancer Type', tickangle: 45 },
                        yaxis: { title: 'Proportion of CAF Cells', tickformat: '.0%' },
                        margin: { l: 60, r: 30, t: 30, b: 100 },
                        legend: { orientation: 'h', y: 1.15 },
                        height: 350
                    }, { responsive: true });
                } else {
                    proportionsContainer.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Limited CAF data available in current selection.</p>';
                }
            }

            // 3. Heatmap - CAF class √ó signatures (aggregated)
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                const activeClasses = cafClasses.filter(cls => Object.keys(byClass[cls] || {}).length > 0);
                const zData = activeClasses.map(cls =>
                    topSigs.map(sig => {
                        const vals = byClass[cls]?.[sig] || [];
                        return vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : 0;
                    })
                );

                Plotly.newPlot(heatmapContainer, [{
                    type: 'heatmap',
                    z: zData,
                    x: topSigs,
                    y: activeClasses,
                    colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                    zmid: 0,
                    colorbar: { title: 'Activity' },
                    hovertemplate: '<b>%{y}</b><br>%{x}: %{z:.3f}<extra></extra>'
                }], {
                    margin: { l: 80, r: 50, t: 30, b: 100 },
                    xaxis: { tickangle: 45 },
                    height: 350
                }, { responsive: true });
            }
        }

        // Cross-Atlas: Overview
        function updateAtlasOverview() {
            const container = document.getElementById('atlas-summary-chart');
            if (!container) return;
            container.classList.remove('loading');

            // Use real data if available
            const crossData = state.data.crossatlas?.summary;
            let atlases, cells, samples, cellTypes;

            if (crossData) {
                atlases = ['CIMA', 'Inflammation', 'scAtlas Normal', 'scAtlas Cancer'];
                cells = [
                    crossData.cima?.cells / 1000000 || 6.5,
                    crossData.inflammation?.cells / 1000000 || 4.9,
                    crossData.scatlas_normal?.cells / 1000000 || 5.2,
                    crossData.scatlas_cancer?.cells / 1000000 || 1.2
                ];
                samples = [
                    crossData.cima?.samples || 421,
                    crossData.inflammation?.samples || 817,
                    crossData.scatlas_normal?.samples || 0,
                    crossData.scatlas_cancer?.samples || 0
                ];
                cellTypes = [
                    crossData.cima?.cell_types || 27,
                    crossData.inflammation?.cell_types || 66,
                    crossData.scatlas_normal?.cell_types || 376,
                    crossData.scatlas_cancer?.cell_types || 150
                ];

                // Update stat cards
                const totalCells = cells.reduce((a, b) => a + b, 0);
                document.getElementById('cross-total-cells').textContent = totalCells.toFixed(1) + 'M';
                document.getElementById('cross-total-samples').textContent = (samples[0] + samples[1]).toLocaleString();
                document.getElementById('cross-total-celltypes').textContent = Math.max(...cellTypes).toString();
            } else {
                atlases = ['CIMA', 'Inflammation', 'scAtlas Normal', 'scAtlas Cancer'];
                cells = [6.5, 4.9, 5.2, 1.2];
                cellTypes = [27, 66, 376, 150];
            }

            // Bar chart for cells (millions)
            const trace1 = {
                x: atlases,
                y: cells,
                type: 'bar',
                name: 'Cells (millions)',
                marker: { color: '#1f77b4' },
                hovertemplate: '<b>%{x}</b><br>Cells: %{y:.1f}M<extra></extra>'
            };

            // Point and line graph for cell types
            const trace2 = {
                x: atlases,
                y: cellTypes,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Cell Types',
                marker: { color: '#ff7f0e', size: 12, symbol: 'circle' },
                line: { color: '#ff7f0e', width: 2 },
                yaxis: 'y2',
                hovertemplate: '<b>%{x}</b><br>Cell Types: %{y}<extra></extra>'
            };

            Plotly.newPlot(container, [trace1, trace2], {
                yaxis: { title: 'Cells (millions)', side: 'left', rangemode: 'tozero' },
                yaxis2: { title: 'Cell Types', side: 'right', overlaying: 'y', rangemode: 'tozero' },
                margin: { t: 30, b: 60, l: 60, r: 60 },
                legend: { orientation: 'h', y: 1.1 },
                height: 450
            }, { responsive: true });
        }

        // Cross-Atlas: Conserved Signatures
        // Shows cross-atlas correlation reliability for each signature.
        // Measures whether signatures show consistent cell-type patterns across atlases.
        function updateConservedSignatures() {
            const heatmapContainer = document.getElementById('conserved-heatmap');
            const tableContainer = document.getElementById('conserved-table');
            const pairCorrelationsContainer = document.getElementById('conserved-pair-correlations');

            // Get dropdown values
            const sigType = document.getElementById('conserved-sig-type')?.value || 'cytosig';
            const filterType = document.getElementById('conserved-filter')?.value || 'all';

            // Use signature_reliability data from cross_atlas.json
            const reliabilityData = state.data.crossatlas?.signature_reliability?.[sigType];
            const searchInput = document.getElementById('conserved-search');
            const datalist = document.getElementById('conserved-signature-list');
            const detailPanel = document.getElementById('conserved-signature-detail');

            if (!reliabilityData) {
                if (heatmapContainer) {
                    heatmapContainer.classList.remove('loading');
                    heatmapContainer.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Signature reliability data not available. Run generate_atlas_comparison.py to generate.</p>';
                }
                if (tableContainer) {
                    tableContainer.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data available.</p>';
                }
                if (datalist) datalist.innerHTML = '';
                if (detailPanel) detailPanel.style.display = 'none';
                return;
            }

            // Populate signature search datalist
            const allSignatures = reliabilityData.signatures || [];
            if (datalist) {
                datalist.innerHTML = allSignatures.map(s => `<option value="${s.signature}">`).join('');
            }

            // Handle signature search/selection
            const searchValue = searchInput?.value?.trim() || '';
            const selectedSig = allSignatures.find(s => s.signature.toLowerCase() === searchValue.toLowerCase());

            if (selectedSig && detailPanel) {
                detailPanel.style.display = 'block';
                document.getElementById('conserved-detail-name').textContent = selectedSig.signature;

                // Category display
                const categoryColors = {
                    'highly_conserved': { bg: '#e8f5e9', text: '#2e7d32', label: 'Highly Conserved (r > 0.7 in 2+ pairs)' },
                    'moderately_conserved': { bg: '#fff3e0', text: '#e65100', label: 'Moderately Conserved (r > 0.5 in 2+ pairs)' },
                    'atlas_specific': { bg: '#fce4ec', text: '#c2185b', label: 'Atlas-Specific (low cross-atlas correlation)' },
                    'insufficient_data': { bg: '#f5f5f5', text: '#616161', label: 'Limited Data (only 1 atlas pair)' }
                };
                const catInfo = categoryColors[selectedSig.category] || { bg: '#f5f5f5', text: '#666', label: selectedSig.category };
                document.getElementById('conserved-detail-category').innerHTML = `<span style="background: ${catInfo.bg}; color: ${catInfo.text}; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.85rem;">${catInfo.label}</span>`;

                // Correlation details for each atlas pair
                const pairLabels = {
                    'cima_vs_inflammation': 'CIMA vs Inflammation',
                    'cima_vs_scatlas': 'CIMA vs scAtlas',
                    'inflammation_vs_scatlas': 'Inflammation vs scAtlas'
                };
                let corrHtml = '';
                for (const [pairKey, pairLabel] of Object.entries(pairLabels)) {
                    const corrData = selectedSig.correlations?.[pairKey];
                    if (corrData && corrData.r !== undefined) {
                        const r = corrData.r;
                        const color = r > 0.7 ? '#2e7d32' : r > 0.5 ? '#e65100' : r > 0 ? '#1565c0' : '#c2185b';
                        corrHtml += `
                            <div style="text-align: center; background: white; padding: 0.75rem; border-radius: 6px;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: ${color};">r = ${r.toFixed(3)}</div>
                                <div style="font-size: 0.85rem; color: #666;">${pairLabel}</div>
                                <div style="font-size: 0.75rem; color: #999;">n = ${corrData.n} cell types</div>
                            </div>
                        `;
                    } else {
                        corrHtml += `
                            <div style="text-align: center; background: white; padding: 0.75rem; border-radius: 6px; opacity: 0.6;">
                                <div style="font-size: 1.5rem; font-weight: bold; color: #999;">N/A</div>
                                <div style="font-size: 0.85rem; color: #666;">${pairLabel}</div>
                                <div style="font-size: 0.75rem; color: #999;">No data</div>
                            </div>
                        `;
                    }
                }
                document.getElementById('conserved-detail-correlations').innerHTML = corrHtml;
            } else if (detailPanel) {
                detailPanel.style.display = 'none';
            }

            // Update summary cards
            const summary = reliabilityData.summary || {};
            document.getElementById('conserved-highly-count').textContent = summary.highly_conserved || 0;
            document.getElementById('conserved-moderate-count').textContent = summary.moderately_conserved || 0;
            document.getElementById('conserved-specific-count').textContent = summary.atlas_specific || 0;
            document.getElementById('conserved-insufficient-count').textContent = summary.insufficient_data || 0;

            // Update pair correlations display
            if (pairCorrelationsContainer) {
                const pairCorr = reliabilityData.pair_correlations || {};
                const pairLabels = {
                    'cima_vs_inflammation': 'CIMA vs Inflammation',
                    'cima_vs_scatlas': 'CIMA vs scAtlas',
                    'inflammation_vs_scatlas': 'Inflammation vs scAtlas'
                };

                let pairHtml = '';
                for (const [pairKey, data] of Object.entries(pairCorr)) {
                    const r = data.correlation || 0;
                    const color = r > 0.7 ? '#2e7d32' : r > 0.5 ? '#e65100' : '#c2185b';
                    pairHtml += `
                        <div style="text-align: center; min-width: 150px;">
                            <div style="font-size: 1.5rem; font-weight: bold; color: ${color};">r = ${r.toFixed(2)}</div>
                            <div style="font-size: 0.85rem; color: #666;">${pairLabels[pairKey] || pairKey}</div>
                            <div style="font-size: 0.75rem; color: #999;">n = ${data.n || 0} points</div>
                        </div>
                    `;
                }
                pairCorrelationsContainer.innerHTML = pairHtml;
            }

            // Render category distribution chart
            const categoryChartContainer = document.getElementById('conserved-category-chart');
            if (categoryChartContainer) {
                Plotly.purge(categoryChartContainer);
                const categories = ['Highly Conserved', 'Moderate', 'Atlas-Specific', 'Limited Data'];
                const values = [
                    summary.highly_conserved || 0,
                    summary.moderately_conserved || 0,
                    summary.atlas_specific || 0,
                    summary.insufficient_data || 0
                ];
                const colors = ['#2e7d32', '#e65100', '#c2185b', '#9e9e9e'];

                const maxVal = Math.max(...values, 1);
                Plotly.newPlot(categoryChartContainer, [{
                    type: 'bar',
                    x: categories,
                    y: values,
                    marker: { color: colors },
                    text: values.map(v => v.toString()),
                    textposition: 'outside',
                    hovertemplate: '<b>%{x}</b><br>%{y} signatures<extra></extra>'
                }], {
                    margin: { t: 30, b: 50, l: 40, r: 20 },
                    yaxis: { title: 'Count', range: [0, maxVal * 1.2] },
                    xaxis: { tickangle: -20 },
                    height: 160
                }, { responsive: true, displayModeBar: false });
            }

            // Filter signatures
            let signatures = reliabilityData.signatures || [];
            if (filterType !== 'all') {
                signatures = signatures.filter(s => s.category === filterType);
            }

            // Render heatmap of correlation coefficients
            if (heatmapContainer) {
                heatmapContainer.classList.remove('loading');
                Plotly.purge(heatmapContainer);

                if (signatures.length === 0) {
                    heatmapContainer.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No signatures match the current filter.</p>`;
                } else {
                    const displaySigs = signatures.slice(0, 50);
                    const pairKeys = ['cima_vs_inflammation', 'cima_vs_scatlas', 'inflammation_vs_scatlas'];
                    const pairLabels = ['CIMA-Inflam', 'CIMA-scAtlas', 'Inflam-scAtlas'];

                    const zData = [];
                    const yLabels = [];
                    const hoverText = [];

                    for (const sig of displaySigs) {
                        const row = [];
                        const hoverRow = [];
                        yLabels.push(sig.signature);
                        for (const pairKey of pairKeys) {
                            const corrData = sig.correlations?.[pairKey];
                            if (corrData && corrData.r !== undefined) {
                                row.push(corrData.r);
                                hoverRow.push(`${sig.signature}<br>${pairKey.replace(/_/g, ' ')}<br>r = ${corrData.r.toFixed(3)}<br>n = ${corrData.n} cell types`);
                            } else {
                                row.push(null);
                                hoverRow.push(`${sig.signature}<br>${pairKey.replace(/_/g, ' ')}<br>No data`);
                            }
                        }
                        zData.push(row);
                        hoverText.push(hoverRow);
                    }

                    Plotly.newPlot(heatmapContainer, [{
                        type: 'heatmap',
                        z: zData,
                        x: pairLabels,
                        y: yLabels,
                        text: hoverText,
                        hoverinfo: 'text',
                        colorscale: [
                            [0, '#c2185b'], [0.25, '#f8bbd9'], [0.5, '#ffffff'],
                            [0.75, '#c8e6c9'], [1, '#2e7d32']
                        ],
                        zmin: -1, zmax: 1,
                        colorbar: { title: 'Correlation (r)', titleside: 'right' }
                    }], {
                        title: { text: `Cell-type Pattern Correlation (${sigType.toUpperCase()}, top ${displaySigs.length})`, font: { size: 14 } },
                        xaxis: { title: 'Atlas Pair', side: 'bottom' },
                        yaxis: { automargin: true, autorange: 'reversed' },
                        margin: { l: 100, r: 80, t: 50, b: 60 },
                        height: 450
                    }, { responsive: true });
                }
            }

            // Render table
            if (tableContainer) {
                if (signatures.length === 0) {
                    tableContainer.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No signatures match the current filter.</p>`;
                } else {
                    const categoryColors = {
                        'highly_conserved': '#2e7d32',
                        'moderately_conserved': '#e65100',
                        'atlas_specific': '#c2185b',
                        'insufficient_data': '#9e9e9e',
                        'unknown': '#666'
                    };
                    const categoryLabels = {
                        'highly_conserved': 'Highly Conserved',
                        'moderately_conserved': 'Moderate',
                        'atlas_specific': 'Atlas-Specific',
                        'insufficient_data': 'Limited Data',
                        'unknown': 'Unknown'
                    };

                    let tableHtml = `
                        <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                            <thead>
                                <tr style="background: #f5f5f5; position: sticky; top: 0;">
                                    <th style="padding: 8px; text-align: left; border-bottom: 2px solid #ddd;">Signature</th>
                                    <th style="padding: 8px; text-align: center; border-bottom: 2px solid #ddd;">Mean r</th>
                                    <th style="padding: 8px; text-align: center; border-bottom: 2px solid #ddd;">Category</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    for (const sig of signatures) {
                        const category = sig.category || 'unknown';
                        const color = categoryColors[category];
                        const label = categoryLabels[category];
                        const meanR = sig.mean_correlation || 0;

                        const corrDetails = [];
                        for (const [pairKey, data] of Object.entries(sig.correlations || {})) {
                            const shortPair = pairKey.replace('cima_vs_', 'C-').replace('inflammation_vs_', 'I-').replace('inflammation', 'I').replace('scatlas', 'S');
                            corrDetails.push(`${shortPair}: ${data.r.toFixed(2)}`);
                        }

                        tableHtml += `
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 8px;">
                                    <strong>${sig.signature}</strong>
                                    <div style="font-size: 0.75rem; color: #999;">${corrDetails.join(' | ')}</div>
                                </td>
                                <td style="padding: 8px; text-align: center; font-weight: bold; color: ${color};">${meanR.toFixed(2)}</td>
                                <td style="padding: 8px; text-align: center;">
                                    <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.75rem;">${label}</span>
                                </td>
                            </tr>
                        `;
                    }

                    tableHtml += '</tbody></table>';
                    tableContainer.innerHTML = tableHtml;
                }
            }
        }

        // Clear conserved signature search and hide detail panel
        function clearConservedSearch() {
            const searchInput = document.getElementById('conserved-search');
            const detailPanel = document.getElementById('conserved-signature-detail');
            if (searchInput) searchInput.value = '';
            if (detailPanel) detailPanel.style.display = 'none';
        }

        // Cross-Atlas: Comparison
        // Multiple comparison views: scatter, bootstrap CI, prediction concordance
        function updateAtlasComparison() {
            const container1 = document.getElementById('atlas-scatter');
            const container2 = document.getElementById('atlas-diff-bar');

            // Get dropdown values
            const atlasSelect = document.getElementById('atlas-comparison-type')?.value || 'cima-inflam';
            const sigType = document.getElementById('atlas-comp-sig-type')?.value || 'CytoSig';
            const level = document.getElementById('atlas-comp-level')?.value || 'coarse';
            const viewType = document.getElementById('atlas-comp-view')?.value || 'scatter';

            // Map select value to comparison key
            const compKeyMap = {
                'cima-inflam': 'cima_vs_inflammation',
                'cima-scatlas': 'cima_vs_scatlas',
                'inflam-scatlas': 'inflammation_vs_scatlas'
            };
            const compKey = compKeyMap[atlasSelect] || 'cima_vs_inflammation';

            // Atlas name maps for labels
            const atlasLabels = {
                'cima-inflam': { x: 'CIMA', y: 'Inflammation Atlas' },
                'cima-scatlas': { x: 'CIMA', y: 'scAtlas' },
                'inflam-scatlas': { x: 'Inflammation Atlas', y: 'scAtlas' }
            };
            const labels = atlasLabels[atlasSelect];

            // Get comparison data from new structure
            const atlasComparison = state.data.crossatlas?.atlas_comparison;
            const sigKey = sigType.toLowerCase();
            const compData = atlasComparison?.[sigKey]?.[compKey];

            console.log('[AtlasComparison] Config:', { atlasSelect, sigType, level, viewType, hasData: !!compData });

            // Update titles based on view
            const scatterTitle = document.getElementById('atlas-scatter-title');
            const scatterSubtitle = document.getElementById('atlas-scatter-subtitle');
            const diffTitle = document.getElementById('atlas-diff-title');
            const diffSubtitle = document.getElementById('atlas-diff-subtitle');

            if (viewType === 'scatter') {
                if (scatterTitle) scatterTitle.textContent = 'Pseudobulk Aggregated Activity';
                if (scatterSubtitle) scatterSubtitle.textContent = `${level === 'coarse' ? 'Coarse (8 lineages)' : 'Fine (~21 types)'}: Mean activity per cell type (sample-weighted)`;
                if (diffTitle) diffTitle.textContent = 'Per-Cell Type Correlation';
                if (diffSubtitle) diffSubtitle.textContent = 'Cross-atlas correlation breakdown by harmonized cell type';
            } else if (viewType === 'singlecell') {
                const levelLabel = level === 'coarse' ? 'Coarse (8 lineages)' : 'Fine (~21 types)';
                if (scatterTitle) scatterTitle.textContent = 'Single-cell Mean Activity';
                if (scatterSubtitle) scatterSubtitle.textContent = `${levelLabel}: Direct mean of individual cell activities (cell-weighted, 50K cells sampled)`;
                if (diffTitle) diffTitle.textContent = 'Per-Cell Type Comparison';
                if (diffSubtitle) diffSubtitle.textContent = `Mean activity per harmonized cell type (${levelLabel.toLowerCase()})`;
            }

            // Render based on view type
            if (viewType === 'scatter') {
                renderAtlasScatter(container1, container2, compData, level, labels);
            } else if (viewType === 'singlecell') {
                renderSinglecellMean(container1, container2, compData, level, labels);
            }

            // Update summary
            updateAtlasComparisonSummary(compData, level, viewType, labels);
        }

        // Render scatter plot view
        function renderAtlasScatter(container1, container2, compData, level, labels) {
            const dataKey = level === 'coarse' ? 'celltype_aggregated_coarse' : 'celltype_aggregated_fine';
            const aggData = compData?.[dataKey];

            if (!aggData || !aggData.data || aggData.data.length === 0) {
                if (container1) {
                    container1.classList.remove('loading');
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Comparison data not available for this atlas pair.</p>';
                }
                if (container2) {
                    container2.classList.remove('loading');
                    container2.innerHTML = '';
                }
                return;
            }

            const plotData = aggData.data;
            const correlation = aggData.correlation;
            const pvalue = aggData.pvalue;

            // Render scatter
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                const xData = plotData.map(d => d.x);
                const yData = plotData.map(d => d.y);

                const xMin = Math.min(...xData), xMax = Math.max(...xData);
                const yMin = Math.min(...yData), yMax = Math.max(...yData);
                const padding = 0.2;

                const pvalText = pvalue !== null ? `, p<0.001` : '';
                const titleText = `Spearman r = ${correlation?.toFixed(3) || 'N/A'}${pvalText} (n=${plotData.length})`;

                Plotly.newPlot(container1, [{
                    type: 'scatter',
                    mode: 'markers',
                    x: xData,
                    y: yData,
                    text: plotData.map(d => `${d.signature} (${d.cell_type})`),
                    marker: {
                        size: 7,
                        color: plotData.map(d => Math.abs(d.x - d.y)),
                        colorscale: 'Viridis',
                        colorbar: { title: '|Œî|', len: 0.5 }
                    },
                    hovertemplate: '<b>%{text}</b><br>' + labels.x + ': %{x:.2f}<br>' + labels.y + ': %{y:.2f}<extra></extra>'
                }, {
                    type: 'scatter',
                    mode: 'lines',
                    x: [Math.min(xMin, yMin) - padding, Math.max(xMax, yMax) + padding],
                    y: [Math.min(xMin, yMin) - padding, Math.max(xMax, yMax) + padding],
                    line: { dash: 'dash', color: '#ccc' },
                    showlegend: false,
                    hoverinfo: 'skip'
                }], {
                    xaxis: { title: `${labels.x} Activity (z-score)`, zeroline: true },
                    yaxis: { title: `${labels.y} Activity (z-score)`, zeroline: true },
                    margin: { l: 60, r: 30, t: 50, b: 60 },
                    title: { text: titleText, font: { size: 12 } },
                    height: 430
                }, { responsive: true });
            }

            // Render per-cell-type correlation breakdown
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                // Group data by cell type and compute per-type correlation
                const cellTypeGroups = {};
                plotData.forEach(d => {
                    if (!cellTypeGroups[d.cell_type]) {
                        cellTypeGroups[d.cell_type] = { x: [], y: [] };
                    }
                    cellTypeGroups[d.cell_type].x.push(d.x);
                    cellTypeGroups[d.cell_type].y.push(d.y);
                });

                // Compute Spearman correlation for each cell type
                const cellTypeCorr = Object.entries(cellTypeGroups).map(([cellType, data]) => {
                    // Simple Pearson correlation (approximation for visualization)
                    const n = data.x.length;
                    if (n < 3) return { cellType, correlation: null, n };

                    const meanX = data.x.reduce((a, b) => a + b, 0) / n;
                    const meanY = data.y.reduce((a, b) => a + b, 0) / n;
                    let num = 0, denX = 0, denY = 0;
                    for (let i = 0; i < n; i++) {
                        const dx = data.x[i] - meanX;
                        const dy = data.y[i] - meanY;
                        num += dx * dy;
                        denX += dx * dx;
                        denY += dy * dy;
                    }
                    const correlation = denX * denY > 0 ? num / Math.sqrt(denX * denY) : 0;
                    return { cellType, correlation, n };
                }).filter(d => d.correlation !== null);

                // Sort by correlation
                cellTypeCorr.sort((a, b) => b.correlation - a.correlation);

                const colors = cellTypeCorr.map(d => {
                    const r = d.correlation;
                    if (r >= 0.7) return '#1a9850';
                    if (r >= 0.5) return '#91cf60';
                    if (r >= 0.3) return '#d9ef8b';
                    if (r >= 0) return '#fee08b';
                    return '#d73027';
                });

                Plotly.newPlot(container2, [{
                    type: 'bar',
                    orientation: 'h',
                    y: cellTypeCorr.map(d => d.cellType),
                    x: cellTypeCorr.map(d => d.correlation),
                    marker: { color: colors },
                    text: cellTypeCorr.map(d => `r=${d.correlation.toFixed(2)} (n=${d.n})`),
                    textposition: 'outside',
                    hovertemplate: '<b>%{y}</b><br>Correlation: %{x:.3f}<br>n=%{customdata}<extra></extra>',
                    customdata: cellTypeCorr.map(d => d.n)
                }], {
                    xaxis: {
                        title: 'Pearson Correlation',
                        range: [-0.2, 1.1],
                        zeroline: true,
                        zerolinecolor: '#ccc'
                    },
                    yaxis: { automargin: true },
                    margin: { l: 100, r: 80, t: 40, b: 50 },
                    height: 430,
                    shapes: [{
                        type: 'line',
                        x0: 0.7, x1: 0.7,
                        y0: -0.5, y1: cellTypeCorr.length - 0.5,
                        line: { dash: 'dash', color: '#1a9850', width: 1 }
                    }],
                    annotations: [{
                        x: 0.7, y: cellTypeCorr.length - 0.5,
                        text: 'Good (r‚â•0.7)',
                        showarrow: false,
                        font: { size: 9, color: '#1a9850' },
                        xanchor: 'left',
                        yanchor: 'bottom'
                    }]
                }, { responsive: true });
            }
        }

        // Render single-cell mean activity comparison
        function renderSinglecellMean(container1, container2, compData, level, labels) {
            // Use level-specific data key (singlecell_mean_coarse or singlecell_mean_fine)
            // Fall back to legacy 'singlecell_mean' for backward compatibility
            const dataKey = `singlecell_mean_${level}`;
            const scData = compData?.[dataKey] || compData?.singlecell_mean;

            if (!scData || !scData.data || scData.data.length === 0) {
                if (container1) {
                    container1.classList.remove('loading');
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Single-cell mean activity data not available. This requires joining activity data with original h5ad files.</p>';
                }
                if (container2) {
                    container2.classList.remove('loading');
                    container2.innerHTML = '';
                }
                return;
            }

            const plotData = scData.data;
            const correlation = scData.overall_correlation;

            // Left panel: Scatter plot of single-cell means
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                const xData = plotData.map(d => d.x);
                const yData = plotData.map(d => d.y);

                const xMin = Math.min(...xData), xMax = Math.max(...xData);
                const yMin = Math.min(...yData), yMax = Math.max(...yData);
                const padding = 0.2;

                const titleText = `Spearman r = ${correlation?.toFixed(3) || 'N/A'} (n=${plotData.length})`;

                // Color by cell type
                const cellTypes = [...new Set(plotData.map(d => d.cell_type))];
                const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

                const traces = cellTypes.map(ct => {
                    const ctData = plotData.filter(d => d.cell_type === ct);
                    return {
                        type: 'scatter',
                        mode: 'markers',
                        name: ct,
                        x: ctData.map(d => d.x),
                        y: ctData.map(d => d.y),
                        text: ctData.map(d => `${d.signature}<br>${d.n_cells_x} vs ${d.n_cells_y} cells`),
                        marker: {
                            size: 8,
                            color: colorScale(ct),
                            opacity: 0.7
                        },
                        hovertemplate: '<b>%{text}</b><br>' + labels.x + ': %{x:.2f}<br>' + labels.y + ': %{y:.2f}<extra>' + ct + '</extra>'
                    };
                });

                // Add diagonal line
                traces.push({
                    type: 'scatter',
                    mode: 'lines',
                    x: [Math.min(xMin, yMin) - padding, Math.max(xMax, yMax) + padding],
                    y: [Math.min(xMin, yMin) - padding, Math.max(xMax, yMax) + padding],
                    line: { dash: 'dash', color: '#ccc' },
                    showlegend: false,
                    hoverinfo: 'skip'
                });

                Plotly.newPlot(container1, traces, {
                    xaxis: { title: `${labels.x} Mean Activity (z-score)`, zeroline: true },
                    yaxis: { title: `${labels.y} Mean Activity (z-score)`, zeroline: true },
                    margin: { l: 60, r: 30, t: 50, b: 60 },
                    title: { text: titleText, font: { size: 12 } },
                    height: 430,
                    legend: { orientation: 'h', y: -0.2 }
                }, { responsive: true });
            }

            // Right panel: Per-cell type mean comparison (bar chart)
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                // Compute mean of means per cell type
                const cellTypeStats = {};
                plotData.forEach(d => {
                    if (!cellTypeStats[d.cell_type]) {
                        cellTypeStats[d.cell_type] = { x: [], y: [], n_x: 0, n_y: 0 };
                    }
                    cellTypeStats[d.cell_type].x.push(d.x);
                    cellTypeStats[d.cell_type].y.push(d.y);
                    cellTypeStats[d.cell_type].n_x = d.n_cells_x;
                    cellTypeStats[d.cell_type].n_y = d.n_cells_y;
                });

                const ctNames = Object.keys(cellTypeStats).sort();
                const xMeans = ctNames.map(ct => {
                    const vals = cellTypeStats[ct].x;
                    return vals.reduce((a, b) => a + b, 0) / vals.length;
                });
                const yMeans = ctNames.map(ct => {
                    const vals = cellTypeStats[ct].y;
                    return vals.reduce((a, b) => a + b, 0) / vals.length;
                });

                Plotly.newPlot(container2, [{
                    type: 'bar',
                    name: labels.x,
                    x: ctNames,
                    y: xMeans,
                    marker: { color: '#1f77b4' },
                    text: ctNames.map(ct => `${cellTypeStats[ct].n_x} cells`),
                    hovertemplate: '<b>%{x}</b><br>Mean: %{y:.2f}<br>%{text}<extra>' + labels.x + '</extra>'
                }, {
                    type: 'bar',
                    name: labels.y,
                    x: ctNames,
                    y: yMeans,
                    marker: { color: '#ff7f0e' },
                    text: ctNames.map(ct => `${cellTypeStats[ct].n_y} cells`),
                    hovertemplate: '<b>%{x}</b><br>Mean: %{y:.2f}<br>%{text}<extra>' + labels.y + '</extra>'
                }], {
                    barmode: 'group',
                    xaxis: { title: 'Cell Type', tickangle: -45 },
                    yaxis: { title: 'Mean Activity (z-score)' },
                    margin: { l: 60, r: 30, t: 40, b: 100 },
                    height: 430,
                    legend: { orientation: 'h', y: 1.1 },
                    title: { text: `Per-Cell Type Mean (${scData.n_cells_atlas1 || '?'} vs ${scData.n_cells_atlas2 || '?'} cells)`, font: { size: 12 } }
                }, { responsive: true });
            }
        }

        // Render signature agreement view (similarity-focused)
        function renderSignatureAgreement(container1, container2, compData, labels) {
            const agreementData = compData?.signature_agreement;

            if (!agreementData || !agreementData.equivalence || agreementData.n === 0) {
                if (container1) {
                    container1.classList.remove('loading');
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Signature agreement data not available.</p>';
                }
                if (container2) {
                    container2.classList.remove('loading');
                    container2.innerHTML = '';
                }
                return;
            }

            const equiv = agreementData.equivalence;
            const celltypeData = agreementData.celltype_agreement || [];

            // Left panel: Equivalence summary - stacked bar showing % within bounds
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                // Create gauge-like visualization for equivalence
                const bounds = ['¬±0.5', '¬±1.0', '¬±2.0', '¬±3.0'];
                const values = [
                    equiv.within_0_5 * 100,
                    equiv.within_1_0 * 100,
                    equiv.within_2_0 * 100,
                    equiv.within_3_0 * 100
                ];

                // Interpretation colors: green = high agreement
                const colors = values.map(v => {
                    if (v >= 80) return '#2ca02c';  // Excellent
                    if (v >= 60) return '#98df8a';  // Good
                    if (v >= 40) return '#ffbb78';  // Moderate
                    return '#d62728';  // Poor
                });

                const traces = [{
                    type: 'bar',
                    x: bounds,
                    y: values,
                    marker: { color: colors },
                    text: values.map(v => `${v.toFixed(1)}%`),
                    textposition: 'auto',
                    hovertemplate: '<b>Within %{x} z-score</b><br>%{y:.1f}% of signatures<extra></extra>'
                }];

                // Add reference lines
                const shapes = [
                    { type: 'line', x0: -0.5, x1: 3.5, y0: 80, y1: 80, line: { dash: 'dash', color: '#2ca02c', width: 1 } },
                    { type: 'line', x0: -0.5, x1: 3.5, y0: 60, y1: 60, line: { dash: 'dot', color: '#666', width: 1 } }
                ];

                const ccc = agreementData.overall_ccc;
                const cccText = ccc !== null ? `CCC = ${ccc.toFixed(3)}` : '';
                const dirAgree = agreementData.direction_agreement;
                const dirText = dirAgree !== null ? `, ${(dirAgree * 100).toFixed(0)}% same direction` : '';

                Plotly.newPlot(container1, traces, {
                    xaxis: { title: 'Equivalence Bound (z-score)' },
                    yaxis: { title: '% Signatures Within Bound', range: [0, 105] },
                    margin: { l: 60, r: 30, t: 50, b: 60 },
                    height: 430,
                    shapes: shapes,
                    annotations: [
                        { x: 3.2, y: 82, text: 'Excellent', showarrow: false, font: { size: 10, color: '#2ca02c' } },
                        { x: 3.2, y: 62, text: 'Good', showarrow: false, font: { size: 10, color: '#666' } }
                    ],
                    title: { text: `Overall Agreement: ${cccText}${dirText}`, font: { size: 12 } }
                }, { responsive: true });
            }

            // Right panel: Per-cell type CCC bar chart
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                if (celltypeData.length === 0) {
                    container2.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No cell type data available.</p>';
                    return;
                }

                // Sort by CCC descending
                const sortedData = [...celltypeData]
                    .filter(d => d.ccc !== null)
                    .sort((a, b) => b.ccc - a.ccc);

                const cellTypes = sortedData.map(d => d.cell_type);
                const cccValues = sortedData.map(d => d.ccc);

                // Color by CCC value
                const barColors = cccValues.map(v => {
                    if (v >= 0.9) return '#1a5f1a';   // Excellent
                    if (v >= 0.7) return '#2ca02c';   // Good
                    if (v >= 0.5) return '#98df8a';   // Moderate
                    if (v >= 0.3) return '#ffbb78';   // Fair
                    return '#d62728';   // Poor
                });

                Plotly.newPlot(container2, [{
                    type: 'bar',
                    x: cccValues,
                    y: cellTypes,
                    orientation: 'h',
                    marker: { color: barColors },
                    text: cccValues.map(v => v.toFixed(2)),
                    textposition: 'auto',
                    hovertemplate: '<b>%{y}</b><br>CCC: %{x:.3f}<br>%{customdata}<extra></extra>',
                    customdata: sortedData.map(d => `${(d.equiv_1_0 * 100).toFixed(0)}% within ¬±1.0`)
                }], {
                    xaxis: { title: "Lin's Concordance (CCC)", range: [0, 1.05] },
                    yaxis: { automargin: true },
                    margin: { l: 120, r: 30, t: 40, b: 50 },
                    height: 430,
                    shapes: [
                        { type: 'line', x0: 0.9, x1: 0.9, y0: -0.5, y1: cellTypes.length - 0.5, line: { dash: 'dash', color: '#1a5f1a', width: 1 } },
                        { type: 'line', x0: 0.7, x1: 0.7, y0: -0.5, y1: cellTypes.length - 0.5, line: { dash: 'dot', color: '#2ca02c', width: 1 } }
                    ],
                    title: { text: `Per-Cell Type Agreement (n=${celltypeData.length})`, font: { size: 12 } }
                }, { responsive: true });
            }
        }

        // Render prediction concordance view
        function renderPredictionConcordance(container1, container2, compData, labels) {
            const concData = compData?.prediction_concordance;

            if (!concData || concData.overall_accuracy === null) {
                if (container1) {
                    container1.classList.remove('loading');
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Prediction concordance data not available.</p>';
                }
                if (container2) {
                    container2.classList.remove('loading');
                    container2.innerHTML = '';
                }
                return;
            }

            // Overall accuracy gauge in container1
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                const accuracy = concData.overall_accuracy * 100;

                Plotly.newPlot(container1, [{
                    type: 'indicator',
                    mode: 'gauge+number',
                    value: accuracy,
                    title: { text: `Cross-Atlas Prediction Accuracy<br><span style="font-size:0.8em">${labels.x} ‚Üí ${labels.y}</span>` },
                    gauge: {
                        axis: { range: [0, 100], ticksuffix: '%' },
                        bar: { color: accuracy > 50 ? '#2ca02c' : '#d62728' },
                        steps: [
                            { range: [0, 25], color: '#ffebee' },
                            { range: [25, 50], color: '#fff3e0' },
                            { range: [50, 75], color: '#e8f5e9' },
                            { range: [75, 100], color: '#c8e6c9' }
                        ],
                        threshold: {
                            line: { color: 'black', width: 2 },
                            value: 12.5  // Random baseline for 8 classes
                        }
                    },
                    number: { suffix: '%', font: { size: 40 } }
                }], {
                    margin: { l: 30, r: 30, t: 80, b: 30 },
                    height: 350,
                    annotations: [{
                        x: 0.5, y: -0.15, xref: 'paper', yref: 'paper',
                        text: `n=${concData.n_samples} samples | Random baseline: 12.5%`,
                        showarrow: false, font: { size: 11 }
                    }]
                }, { responsive: true });
            }

            // Per-celltype accuracy in container2
            if (container2 && concData.per_celltype_accuracy) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                const ctAcc = concData.per_celltype_accuracy;
                const celltypes = Object.keys(ctAcc).sort((a, b) => ctAcc[b] - ctAcc[a]);
                const accuracies = celltypes.map(ct => ctAcc[ct] * 100);

                Plotly.newPlot(container2, [{
                    type: 'bar',
                    x: celltypes.map(ct => ct.replace(/_/g, ' ')),
                    y: accuracies,
                    marker: { color: accuracies.map(a => a > 50 ? '#2ca02c' : a > 25 ? '#ff9800' : '#d62728') },
                    text: accuracies.map(a => a.toFixed(0) + '%'),
                    textposition: 'auto',
                    hovertemplate: '<b>%{x}</b><br>Accuracy: %{y:.1f}%<extra></extra>'
                }], {
                    xaxis: { tickangle: -45 },
                    yaxis: { title: 'Classification Accuracy (%)', range: [0, 100] },
                    margin: { l: 60, r: 30, t: 40, b: 100 },
                    height: 430,
                    shapes: [{
                        type: 'line', x0: -0.5, x1: celltypes.length - 0.5, y0: 12.5, y1: 12.5,
                        line: { color: '#999', dash: 'dash', width: 1 }
                    }]
                }, { responsive: true });
            }
        }

        // Update summary
        function updateAtlasComparisonSummary(compData, level, viewType, labels) {
            const summaryDiv = document.getElementById('atlas-comparison-summary');
            if (!summaryDiv) return;

            if (!compData) {
                summaryDiv.innerHTML = '<strong>Note:</strong> Comparison data not available for this atlas pair.';
                return;
            }

            const dataKey = level === 'coarse' ? 'celltype_aggregated_coarse' : 'celltype_aggregated_fine';
            const aggData = compData[dataKey];

            let html = '<strong>Comparison Summary:</strong> ';

            if (viewType === 'scatter' && aggData) {
                html += `${labels.x} vs ${labels.y} | `;
                html += `<span style="color:#1f77b4">Spearman r = ${aggData.correlation?.toFixed(3) || 'N/A'}</span> | `;
                html += `${aggData.n_celltypes || '?'} cell types √ó ${aggData.n_signatures || '?'} signatures = ${aggData.n || 0} data points`;
            } else if (viewType === 'singlecell') {
                const scKey = `singlecell_mean_${level}`;
                const sc = compData[scKey] || compData.singlecell_mean;
                if (sc) {
                    const levelLabel = level === 'coarse' ? 'Coarse' : 'Fine';
                    html += `<span style="color:#2ca02c">${levelLabel} level</span> | `;
                    html += `<span style="color:#1f77b4">Spearman r = ${sc.overall_correlation?.toFixed(3) || 'N/A'}</span> | `;
                    html += `${sc.n_cells_atlas1?.toLocaleString() || '?'} vs ${sc.n_cells_atlas2?.toLocaleString() || '?'} cells sampled | `;
                    html += `${sc.n_celltypes || '?'} cell types √ó ${sc.n_signatures || '?'} signatures`;
                } else {
                    html += 'Single-cell mean data not available for this configuration.';
                }
            }

            summaryDiv.innerHTML = html;
        }

        // Cross-Atlas: Cell Type Mapping
        // Shows harmonized cell type mapping across CIMA, Inflammation Atlas, and scAtlas
        // Two levels: Coarse (8 lineages) and Fine (~32 types)
        function updateCelltypeMapping() {
            const container = document.getElementById('celltype-sankey');
            if (!container) {
                console.log('[CelltypeMapping] Container not found');
                return;
            }

            // Check if container is visible (tab must be active)
            const rect = container.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                console.log('[CelltypeMapping] Container not visible, skipping render');
                return;
            }

            container.classList.remove('loading');
            Plotly.purge(container);

            // Get mapping data and controls
            const mappingData = state.data.crossatlas?.celltype_mapping;
            const mappingLevel = document.getElementById('mapping-level')?.value || 'coarse';
            const lineageFilter = document.getElementById('mapping-lineage')?.value || 'all';

            console.log('[CelltypeMapping] Data check:', {
                hasCrossatlas: !!state.data.crossatlas,
                hasCelltypeMapping: !!mappingData,
                mappingLevel: mappingLevel,
                lineageFilter: lineageFilter
            });

            if (!mappingData || !mappingData.coarse_mapping) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">Cell type mapping data not available.</p>';
                return;
            }

            // Update subtitles based on level
            const subtitle = document.getElementById('celltype-mapping-subtitle');
            const detailTitle = document.getElementById('celltype-detail-title');
            const detailSubtitle = document.getElementById('celltype-detail-subtitle');

            if (mappingLevel === 'coarse') {
                if (subtitle) subtitle.textContent = 'Mapping of cell types across atlases - Coarse level (8 lineages)';
                if (detailTitle) detailTitle.textContent = 'Original Annotations per Lineage';
                if (detailSubtitle) detailSubtitle.textContent = 'Number of atlas-specific cell type annotations mapped to each harmonized lineage';
                renderCoarseMapping(container, mappingData, lineageFilter);
            } else {
                if (subtitle) subtitle.textContent = 'Mapping of cell types across atlases - Fine level (~32 types)';
                if (detailTitle) detailTitle.textContent = 'Cell Counts per Fine Type';
                if (detailSubtitle) detailSubtitle.textContent = 'Total cell counts for each harmonized fine type across atlases';
                renderFineMapping(container, mappingData, lineageFilter);
            }

            // Update summary annotation
            const summary = mappingData.summary;
            const infoDiv = document.getElementById('celltype-mapping-info');
            if (summary && infoDiv) {
                const levelInfo = mappingLevel === 'coarse'
                    ? `Showing ${summary.coarse.n_lineages} coarse lineages (${summary.coarse.n_shared} shared across all atlases)`
                    : `Showing ${summary.fine.n_types} fine types (${summary.fine.n_shared} shared across all atlases)`;
                infoDiv.innerHTML = `
                    <strong>Mapping Summary:</strong> ${levelInfo}
                    <br><span style="margin-top: 5px; display: inline-block;">
                    <span style="color: #e41a1c;">‚óè</span> CIMA: ${summary.coarse.cima_types} original types
                    <span style="margin-left: 15px; color: #377eb8;">‚óè</span> Inflammation: ${summary.coarse.inflammation_types} original types
                    <span style="margin-left: 15px; color: #4daf4a;">‚óè</span> scAtlas: ${summary.coarse.scatlas_types} original types
                    </span>
                `;
            }
        }

        // Render coarse level mapping (Sankey diagram)
        function renderCoarseMapping(container, mappingData, lineageFilter) {
            // Filter coarse mapping by lineage
            let coarseData = mappingData.coarse_mapping;
            if (lineageFilter !== 'all') {
                const lineageMap = {
                    'T_cell': ['CD4_T', 'CD8_T', 'Unconventional_T'],
                    'Myeloid': ['Myeloid'],
                    'B_cell': ['B', 'Plasma'],
                    'NK_ILC': ['NK']
                };
                const targetLineages = lineageMap[lineageFilter] || [];
                coarseData = coarseData.filter(d => targetLineages.includes(d.lineage));
            }

            if (coarseData.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No cell types found for selected lineage filter.</p>';
                return;
            }

            // Build Sankey diagram
            const nodes = [];
            const links = [];
            const nodeIdx = {};

            // Atlas nodes
            const atlasColors = { 'CIMA': '#e41a1c', 'Inflammation': '#377eb8', 'scAtlas': '#4daf4a' };
            ['CIMA', 'Inflammation', 'scAtlas'].forEach(atlas => {
                nodeIdx[atlas] = nodes.length;
                nodes.push({ label: atlas, color: atlasColors[atlas] });
            });

            // Lineage nodes
            const lineageColors = {
                'CD4_T': '#984ea3', 'CD8_T': '#ff7f00', 'NK': '#a65628',
                'B': '#f781bf', 'Plasma': '#999999', 'Myeloid': '#66c2a5',
                'Unconventional_T': '#fc8d62', 'Progenitor': '#8da0cb'
            };
            coarseData.forEach(d => {
                nodeIdx[d.lineage] = nodes.length;
                nodes.push({ label: d.lineage.replace(/_/g, ' '), color: lineageColors[d.lineage] || '#999' });
            });

            // Links from atlases to lineages (scaled by cell count, log scale for visibility)
            coarseData.forEach(d => {
                const atlasKeys = [
                    { key: 'cima', name: 'CIMA' },
                    { key: 'inflammation', name: 'Inflammation' },
                    { key: 'scatlas', name: 'scAtlas' }
                ];
                atlasKeys.forEach(({ key, name }) => {
                    if (d[key].total_cells > 0) {
                        const scaledValue = Math.log10(d[key].total_cells + 1) * 10;
                        links.push({
                            source: nodeIdx[name],
                            target: nodeIdx[d.lineage],
                            value: Math.max(scaledValue, 1),
                            customdata: {
                                cells: d[key].total_cells,
                                types: d[key].types.map(t => t.name).join(', ')
                            }
                        });
                    }
                });
            });

            // Create Sankey trace
            Plotly.newPlot(container, [{
                type: 'sankey',
                orientation: 'h',
                node: {
                    pad: 15,
                    thickness: 20,
                    line: { color: 'black', width: 0.5 },
                    label: nodes.map(n => n.label),
                    color: nodes.map(n => n.color)
                },
                link: {
                    source: links.map(l => l.source),
                    target: links.map(l => l.target),
                    value: links.map(l => l.value),
                    customdata: links.map(l => l.customdata),
                    hovertemplate: '%{source.label} ‚Üí %{target.label}<br>' +
                        'Cells: %{customdata.cells:,}<br>' +
                        'Types: %{customdata.types}<extra></extra>'
                }
            }], {
                margin: { t: 20, b: 20, l: 10, r: 10 },
                height: 400
            }, { responsive: true });

            console.log('[CelltypeMapping] Coarse Sankey rendered with', nodes.length, 'nodes and', links.length, 'links');

            // Update the bar chart showing original type counts per lineage
            const detailContainer = document.getElementById('celltype-detail-bar');
            if (detailContainer) {
                Plotly.purge(detailContainer);

                const lineages = coarseData.map(d => d.lineage.replace(/_/g, ' '));
                const cimaTypeCounts = coarseData.map(d => d.cima.types.length);
                const inflamTypeCounts = coarseData.map(d => d.inflammation.types.length);
                const scatlasTypeCounts = coarseData.map(d => d.scatlas.types.length);

                Plotly.newPlot(detailContainer, [
                    { name: 'CIMA', x: lineages, y: cimaTypeCounts, type: 'bar', marker: { color: '#e41a1c' } },
                    { name: 'Inflammation', x: lineages, y: inflamTypeCounts, type: 'bar', marker: { color: '#377eb8' } },
                    { name: 'scAtlas', x: lineages, y: scatlasTypeCounts, type: 'bar', marker: { color: '#4daf4a' } }
                ], {
                    barmode: 'group',
                    xaxis: { title: 'Harmonized Lineage', tickangle: -30 },
                    yaxis: { title: 'Number of Original Types' },
                    legend: { orientation: 'h', y: 1.12 },
                    margin: { t: 40, b: 80, l: 60, r: 30 },
                    height: 300
                }, { responsive: true });
            }
        }

        // Render fine level mapping (heatmap + bar chart)
        function renderFineMapping(container, mappingData, lineageFilter) {
            let fineData = mappingData.fine_mapping || [];

            // Filter fine types by lineage category
            if (lineageFilter !== 'all') {
                const lineagePrefixes = {
                    'T_cell': ['CD4', 'CD8', 'Treg', 'MAIT', 'gdT', 'NKT', 'ILC'],
                    'Myeloid': ['Mono', 'Mac', 'DC', 'pDC', 'cDC', 'Mast', 'Neutro', 'Baso', 'Eosino'],
                    'B_cell': ['B_', 'Plasma'],
                    'NK_ILC': ['NK', 'ILC']
                };
                const prefixes = lineagePrefixes[lineageFilter] || [];
                fineData = fineData.filter(d =>
                    prefixes.some(p => d.fine_type.startsWith(p) || d.fine_type.includes(p))
                );
            }

            if (fineData.length === 0) {
                container.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No fine types found for selected lineage filter.</p>';
                return;
            }

            // Sort by total cells across atlases
            fineData = fineData.map(d => ({
                ...d,
                totalCells: d.cima.total_cells + d.inflammation.total_cells + d.scatlas.total_cells
            })).sort((a, b) => b.totalCells - a.totalCells);

            // Build presence/absence heatmap data
            const fineTypes = fineData.map(d => d.fine_type.replace(/_/g, ' '));
            const atlases = ['CIMA', 'Inflammation', 'scAtlas'];

            // Create heatmap z values (log cell counts) and text
            const z = [];
            const text = [];
            const atlasKeys = ['cima', 'inflammation', 'scatlas'];

            atlasKeys.forEach((key, i) => {
                const row = [];
                const textRow = [];
                fineData.forEach(d => {
                    const count = d[key].total_cells;
                    row.push(count > 0 ? Math.log10(count + 1) : 0);
                    textRow.push(count > 0 ? count.toLocaleString() + ' cells' : 'Not present');
                });
                z.push(row);
                text.push(textRow);
            });

            // Create heatmap
            Plotly.newPlot(container, [{
                type: 'heatmap',
                z: z,
                x: fineTypes,
                y: atlases,
                text: text,
                hovertemplate: '%{y} - %{x}<br>%{text}<extra></extra>',
                colorscale: [
                    [0, '#f7f7f7'],
                    [0.2, '#d1e5f0'],
                    [0.4, '#92c5de'],
                    [0.6, '#4393c3'],
                    [0.8, '#2166ac'],
                    [1, '#053061']
                ],
                showscale: true,
                colorbar: {
                    title: 'log‚ÇÅ‚ÇÄ(cells)',
                    titleside: 'right'
                }
            }], {
                margin: { t: 20, b: 120, l: 100, r: 80 },
                height: 200,
                xaxis: { tickangle: -45, tickfont: { size: 10 } },
                yaxis: { tickfont: { size: 11 } }
            }, { responsive: true });

            console.log('[CelltypeMapping] Fine heatmap rendered with', fineTypes.length, 'types');

            // Update bar chart to show cell counts per fine type
            const detailContainer = document.getElementById('celltype-detail-bar');
            if (detailContainer) {
                Plotly.purge(detailContainer);

                // Show top 15 fine types by cell count
                const topFineData = fineData.slice(0, 15);
                const topTypes = topFineData.map(d => d.fine_type.replace(/_/g, ' '));

                Plotly.newPlot(detailContainer, [
                    {
                        name: 'CIMA',
                        x: topTypes,
                        y: topFineData.map(d => d.cima.total_cells),
                        type: 'bar',
                        marker: { color: '#e41a1c' }
                    },
                    {
                        name: 'Inflammation',
                        x: topTypes,
                        y: topFineData.map(d => d.inflammation.total_cells),
                        type: 'bar',
                        marker: { color: '#377eb8' }
                    },
                    {
                        name: 'scAtlas',
                        x: topTypes,
                        y: topFineData.map(d => d.scatlas.total_cells),
                        type: 'bar',
                        marker: { color: '#4daf4a' }
                    }
                ], {
                    barmode: 'group',
                    xaxis: { title: 'Harmonized Fine Type (Top 15)', tickangle: -45 },
                    yaxis: { title: 'Cell Count', type: 'log' },
                    legend: { orientation: 'h', y: 1.15 },
                    margin: { t: 50, b: 120, l: 70, r: 30 },
                    height: 350
                }, { responsive: true });
            }
        }

        // Cross-Atlas: Meta-Analysis (Replicated Signatures Only)
        function updateMetaAnalysis() {
            const container1 = document.getElementById('meta-forest');
            const container2 = document.getElementById('meta-heterogeneity');

            // Get dropdown values
            const analysisType = document.getElementById('meta-analysis-type')?.value || 'age';

            // Use real meta-analysis data - filter for 2+ atlases only
            const realMetaData = state.data.crossatlas?.meta_analysis;

            if (!realMetaData || !realMetaData[analysisType]) {
                if (container1) {
                    container1.classList.remove('loading');
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No meta-analysis data available.</p>';
                }
                if (container2) {
                    container2.classList.remove('loading');
                    container2.innerHTML = '';
                }
                return;
            }

            // Filter for signatures with data from 2+ atlases
            const multiAtlasData = realMetaData[analysisType].filter(d => d.n_atlases >= 2);

            // Group by signature
            const sigGroups = {};
            multiAtlasData.forEach(d => {
                if (!sigGroups[d.signature]) {
                    sigGroups[d.signature] = {
                        signature: d.signature,
                        effects: [],
                        I2: d.I2 || 0,
                        pooled_pvalue: d.pvalue
                    };
                }
                sigGroups[d.signature].effects.push({
                    atlas: d.atlas,
                    effect: d.effect,
                    se: d.se,
                    ci_low: d.ci_low,
                    ci_high: d.ci_high
                });
                sigGroups[d.signature].pooled = {
                    effect: d.pooled_effect,
                    se: d.pooled_se,
                    ci_low: d.pooled_effect - 1.96 * d.pooled_se,
                    ci_high: d.pooled_effect + 1.96 * d.pooled_se
                };
            });

            const metaData = Object.values(sigGroups);

            // Update summary cards
            const replicatedCount = metaData.length;
            const consistentCount = metaData.filter(m => {
                // Check if all effects have the same sign
                const signs = m.effects.map(e => Math.sign(e.effect));
                return signs.every(s => s === signs[0]);
            }).length;
            const significantCount = metaData.filter(m => {
                // Pooled CI doesn't cross zero
                return (m.pooled.ci_low > 0 || m.pooled.ci_high < 0);
            }).length;

            document.getElementById('meta-replicated-count').textContent = replicatedCount;
            document.getElementById('meta-consistent-count').textContent = consistentCount;
            document.getElementById('meta-significant-count').textContent = significantCount;

            // Sort by absolute pooled effect for visualization
            const sortedMeta = [...metaData].sort((a, b) => Math.abs(b.pooled.effect) - Math.abs(a.pooled.effect)).slice(0, 20);

            // 1. Forest plot
            if (container1) {
                container1.classList.remove('loading');
                Plotly.purge(container1);

                if (sortedMeta.length === 0) {
                    container1.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No replicated signatures found (data from 2+ atlases required).</p>';
                    return;
                }

                const traces = [];
                const yLabels = [];
                let yPos = 0;

                sortedMeta.forEach((meta, sigIdx) => {
                    // Add individual study effects
                    meta.effects.forEach((e, i) => {
                        yLabels.push(`${meta.signature} - ${e.atlas}`);
                        traces.push({
                            type: 'scatter',
                            mode: 'markers',
                            x: [e.effect],
                            y: [yPos],
                            marker: { size: 8, color: ['#1f77b4', '#ff7f0e', '#2ca02c'][i] },
                            error_x: {
                                type: 'data',
                                symmetric: false,
                                array: [e.ci_high - e.effect],
                                arrayminus: [e.effect - e.ci_low]
                            },
                            showlegend: sigIdx === 0,
                            name: e.atlas,
                            hovertemplate: `<b>${meta.signature} - ${e.atlas}</b><br>Effect: ${e.effect.toFixed(2)} [${e.ci_low.toFixed(2)}, ${e.ci_high.toFixed(2)}]<extra></extra>`
                        });
                        yPos++;
                    });

                    // Add pooled effect (diamond)
                    yLabels.push(`${meta.signature} - Pooled`);
                    traces.push({
                        type: 'scatter',
                        mode: 'markers',
                        x: [meta.pooled.effect],
                        y: [yPos],
                        marker: { size: 12, symbol: 'diamond', color: '#333' },
                        error_x: {
                            type: 'data',
                            symmetric: false,
                            array: [meta.pooled.ci_high - meta.pooled.effect],
                            arrayminus: [meta.pooled.effect - meta.pooled.ci_low]
                        },
                        showlegend: sigIdx === 0,
                        name: 'Pooled',
                        hovertemplate: `<b>${meta.signature} - Pooled</b><br>Effect: ${meta.pooled.effect.toFixed(2)} [${meta.pooled.ci_low.toFixed(2)}, ${meta.pooled.ci_high.toFixed(2)}]<br>I¬≤: ${meta.I2.toFixed(0)}%<extra></extra>`
                    });
                    yPos++;
                });

                Plotly.newPlot(container1, traces, {
                    xaxis: { title: 'Effect Size (z-score)', zeroline: true, zerolinecolor: '#000', zerolinewidth: 2 },
                    yaxis: {
                        tickvals: [...Array(yLabels.length).keys()],
                        ticktext: yLabels,
                        automargin: true
                    },
                    shapes: [{
                        type: 'line',
                        x0: 0, y0: -0.5, x1: 0, y1: yPos - 0.5,
                        line: { color: '#000', width: 1 }
                    }],
                    margin: { l: 150, r: 30, t: 30, b: 50 },
                    height: Math.max(400, yPos * 20),
                    legend: { orientation: 'h', y: -0.1 }
                }, { responsive: true });
            }

            // 2. Heterogeneity bar chart (I¬≤ statistics)
            if (container2) {
                container2.classList.remove('loading');
                Plotly.purge(container2);

                // Use same filtered data as forest plot
                const sortedByI2 = [...metaData].sort((a, b) => b.I2 - a.I2);

                if (sortedByI2.length === 0) {
                    container2.innerHTML = '<p style="text-align:center; color:#666; padding:2rem;">No data available.</p>';
                    return;
                }

                // Check if all I¬≤ values are 0 (perfectly consistent)
                const allZero = sortedByI2.every(d => d.I2 === 0);

                if (allZero) {
                    container2.innerHTML = `
                        <div style="padding: 2rem; text-align: center; color: #666;">
                            <div style="font-size: 3rem; color: #2ca02c; margin-bottom: 1rem;">I¬≤ = 0%</div>
                            <p><strong>Perfect Consistency</strong></p>
                            <p style="font-size: 0.9rem; margin-top: 1rem;">
                                All ${sortedByI2.length} replicated signatures show <span style="color: #2ca02c; font-weight: bold;">identical effects</span>
                                across CIMA and Inflammation Atlas.
                            </p>
                            <p style="font-size: 0.85rem; margin-top: 0.5rem; color: #999;">
                                I¬≤ = 0% indicates no heterogeneity between atlas estimates.
                            </p>
                        </div>
                    `;
                    return;
                }

                Plotly.newPlot(container2, [{
                    type: 'bar',
                    orientation: 'h',
                    y: sortedByI2.map(d => d.signature),
                    x: sortedByI2.map(d => Math.max(d.I2, 2)), // Minimum bar width for visibility
                    marker: {
                        color: sortedByI2.map(d => {
                            if (d.I2 < 25) return '#2ca02c';  // Low
                            if (d.I2 < 50) return '#ffdd57';  // Moderate
                            if (d.I2 < 75) return '#ff7f0e';  // Substantial
                            return '#d62728';  // Considerable
                        })
                    },
                    text: sortedByI2.map(d => `${d.I2.toFixed(0)}%`),
                    textposition: 'auto',
                    hovertemplate: '<b>%{y}</b><br>I¬≤ = %{text}<extra></extra>'
                }], {
                    xaxis: { title: 'I¬≤ Heterogeneity (%)', range: [0, 100] },
                    yaxis: { automargin: true },
                    margin: { l: 80, r: 30, t: 30, b: 50 },
                    shapes: [
                        { type: 'line', x0: 25, y0: -0.5, x1: 25, y1: sortedByI2.length - 0.5, line: { dash: 'dot', color: '#999' } },
                        { type: 'line', x0: 50, y0: -0.5, x1: 50, y1: sortedByI2.length - 0.5, line: { dash: 'dot', color: '#999' } },
                        { type: 'line', x0: 75, y0: -0.5, x1: 75, y1: sortedByI2.length - 0.5, line: { dash: 'dot', color: '#999' } }
                    ],
                    annotations: [
                        { x: 12.5, y: sortedByI2.length, text: 'Low', showarrow: false, font: { size: 9, color: '#2ca02c' } },
                        { x: 37.5, y: sortedByI2.length, text: 'Moderate', showarrow: false, font: { size: 9, color: '#ffdd57' } },
                        { x: 62.5, y: sortedByI2.length, text: 'Substantial', showarrow: false, font: { size: 9, color: '#ff7f0e' } },
                        { x: 87.5, y: sortedByI2.length, text: 'High', showarrow: false, font: { size: 9, color: '#d62728' } }
                    ],
                    height: Math.max(400, sortedByI2.length * 25)
                }, { responsive: true });
            }
        }

        // ========================================
        // NEW CROSS-ATLAS PANELS: Signature Correlation, Pathway Enrichment
        // ========================================

        // Cross-Atlas: Signature Correlation Matrix
        // Shows pairwise correlations between signatures across all atlases
        // CytoSig: 43 signatures, SecAct: top 200 most variable signatures
        function updateSignatureCorrelation() {
            const matrixContainer = document.getElementById('sigcorr-matrix');
            const modulesContainer = document.getElementById('sigcorr-modules');

            if (!matrixContainer) return;

            // Get dropdown values
            const sigType = document.getElementById('sigcorr-sig-type')?.value || 'CytoSig';
            const method = document.getElementById('sigcorr-method')?.value || 'spearman';
            const atlasFilter = document.getElementById('sigcorr-atlas')?.value || 'all';

            // Use real correlation data based on signature type
            const corrData = state.data.crossatlas?.correlation;
            let signatures, corrMatrix, modules, nSamples;

            // Select data based on sigType
            const typeKey = sigType === 'SecAct' ? 'secact' : 'cytosig';
            const typeData = corrData?.[typeKey];

            if (typeData && typeData.matrix && typeData.signatures) {
                signatures = typeData.signatures;
                corrMatrix = typeData.matrix;
                modules = typeData.modules || [];
                nSamples = typeData.n_samples || 0;
            } else if (corrData && corrData.matrix && corrData.signatures) {
                // Backward compatibility: use root-level data
                signatures = corrData.signatures;
                corrMatrix = corrData.matrix;
                modules = corrData.modules || [];
                nSamples = 0;
            } else {
                // Fallback if no data
                matrixContainer.innerHTML = `<p style="text-align:center; color:#666; padding:2rem;">No ${sigType} correlation data available.</p>`;
                if (modulesContainer) {
                    modulesContainer.innerHTML = '';
                }
                return;
            }

            // 1. Correlation heatmap
            matrixContainer.classList.remove('loading');
            Plotly.purge(matrixContainer);

            const nSigs = signatures.length;
            const title = sigType === 'SecAct'
                ? `SecAct Correlation (${nSigs} top variable signatures)`
                : `CytoSig Correlation (${nSigs} signatures)`;

            Plotly.newPlot(matrixContainer, [{
                type: 'heatmap',
                z: corrMatrix,
                x: signatures,
                y: signatures,
                colorscale: [[0, '#2166ac'], [0.5, '#f7f7f7'], [1, '#b2182b']],
                zmid: 0,
                zmin: -1,
                zmax: 1,
                colorbar: { title: 'Spearman œÅ', len: 0.8 },
                hovertemplate: '<b>%{x} vs %{y}</b><br>r = %{z:.3f}<extra></extra>'
            }], {
                title: { text: title, font: { size: 14 } },
                margin: { l: 100, r: 50, t: 50, b: 100 },
                xaxis: { tickangle: 45, tickfont: { size: nSigs > 50 ? 6 : 10 } },
                yaxis: { tickfont: { size: nSigs > 50 ? 6 : 10 } },
                height: 550
            }, { responsive: true });

            // 2. Modules summary
            if (modulesContainer) {
                modulesContainer.classList.remove('loading');

                let html = `<div style="padding: 1rem;">
                    <h4 style="margin-top: 0;">Identified Co-regulation Modules</h4>
                    <p style="color: #666; font-size: 0.85rem; margin-bottom: 1rem;">
                        ${modules.length} modules identified from ${nSigs} signatures (${nSamples.toLocaleString()} samples across atlases)
                    </p>`;

                modules.forEach(mod => {
                    const memberList = mod.members.length > 10
                        ? mod.members.slice(0, 10).join(', ') + ` ... (+${mod.members.length - 10} more)`
                        : mod.members.join(', ');
                    const meanCorr = mod.mean_correlation !== undefined
                        ? ` (mean r=${mod.mean_correlation.toFixed(2)})`
                        : '';

                    html += `<div style="margin-bottom: 0.8rem;">
                        <span class="badge" style="background: ${mod.color || '#999'}; color: white; font-size: 0.75rem;">
                            ${mod.name.toUpperCase()}${meanCorr}
                        </span>
                        <span style="margin-left: 0.5rem; font-size: 0.85rem; color: #555;">${memberList}</span>
                    </div>`;
                });

                html += '<p style="color: #888; font-size: 0.8rem; margin-top: 1rem; font-style: italic;">Modules identified by hierarchical clustering (Ward linkage) on cross-atlas activity data.</p></div>';
                modulesContainer.innerHTML = html;
            }
        }

        // Cross-Atlas: Pathway Enrichment
        function updatePathwayEnrichment() {
            const barContainer = document.getElementById('pathway-bar');
            const networkContainer = document.getElementById('pathway-network');
            const comparisonContainer = document.getElementById('pathway-comparison');

            if (!barContainer) return;

            // Get dropdown values
            const db = document.getElementById('pathway-db')?.value || 'kegg';
            const cytokineModule = document.getElementById('pathway-module')?.value || 'all';
            const maxPathways = parseInt(document.getElementById('pathway-max')?.value || '20');

            // Use real pathway data if available
            const pathwayData = state.data.crossatlas?.pathways;
            let enrichmentData;

            if (pathwayData && pathwayData[db]) {
                enrichmentData = pathwayData[db].slice(0, maxPathways).map(p => ({
                    pathway: p.pathway.length > 40 ? p.pathway.substring(0, 37) + '...' : p.pathway,
                    fullName: p.pathway,
                    negLogFDR: p.neg_log_fdr,
                    nGenes: p.n_genes,
                    genes: p.genes || '',
                    enrichment: p.odds_ratio > 1 ? Math.log2(p.odds_ratio) : 0
                }));
            } else {
                // Fallback mock data
                const mockPathways = [
                    'Cytokine-cytokine receptor interaction', 'JAK-STAT signaling', 'NF-kappa B signaling',
                    'TNF signaling pathway', 'IL-17 signaling pathway', 'Th1 and Th2 cell differentiation'
                ];
                enrichmentData = mockPathways.slice(0, maxPathways).map(p => ({
                    pathway: p,
                    fullName: p,
                    negLogFDR: Math.random() * 10 + 2,
                    nGenes: Math.floor(Math.random() * 10 + 3),
                    genes: '',
                    enrichment: Math.random() * 2
                }));
            }

            enrichmentData.sort((a, b) => b.negLogFDR - a.negLogFDR);

            // 1. Bar chart
            barContainer.classList.remove('loading');
            Plotly.purge(barContainer);

            Plotly.newPlot(barContainer, [{
                type: 'bar',
                orientation: 'h',
                y: enrichmentData.map(d => d.pathway),
                x: enrichmentData.map(d => d.negLogFDR),
                marker: {
                    color: enrichmentData.map(d => d.enrichment),
                    colorscale: [[0, '#a8d4e6'], [0.5, '#f5f5f5'], [1, '#f4a6a6']],
                    
                    colorbar: { title: 'NES' }
                },
                text: enrichmentData.map(d => `n=${d.nGenes}`),
                textposition: 'auto',
                hovertemplate: '<b>%{y}</b><br>-log10(FDR): %{x:.2f}<br>Genes: %{text}<extra></extra>'
            }], {
                xaxis: { title: '-log10(FDR)' },
                yaxis: { automargin: true },
                margin: { l: 200, r: 80, t: 30, b: 50 },
                height: Math.max(400, enrichmentData.length * 25)
            }, { responsive: true });

            // 2. Pathway-Cytokine network (simplified)
            if (networkContainer) {
                networkContainer.classList.remove('loading');
                Plotly.purge(networkContainer);

                const topPathways = enrichmentData.slice(0, 6);
                const cytokines = ['IFNG', 'TNF', 'IL6', 'IL1B', 'IL10', 'IL17A'];

                // Generate mock connections
                const edges = [];
                topPathways.forEach(p => {
                    const nConnections = Math.floor(Math.random() * 4) + 2;
                    const connectedCytokines = cytokines.sort(() => Math.random() - 0.5).slice(0, nConnections);
                    connectedCytokines.forEach(c => {
                        edges.push({ source: p.pathway, target: c });
                    });
                });

                // Simple bipartite layout
                const pathwayX = topPathways.map((_, i) => 0);
                const pathwayY = topPathways.map((_, i) => i);
                const cytokineX = cytokines.map((_, i) => 1);
                const cytokineY = cytokines.map((_, i) => i * (topPathways.length - 1) / (cytokines.length - 1));

                // Edge traces
                const edgeTraces = edges.map(e => {
                    const si = topPathways.findIndex(p => p.pathway === e.source);
                    const ti = cytokines.indexOf(e.target);
                    return {
                        type: 'scatter',
                        mode: 'lines',
                        x: [0, 1],
                        y: [si, cytokineY[ti]],
                        line: { color: '#ccc', width: 1 },
                        hoverinfo: 'skip',
                        showlegend: false
                    };
                });

                // Node traces
                const pathwayTrace = {
                    type: 'scatter',
                    mode: 'markers+text',
                    x: pathwayX,
                    y: pathwayY,
                    text: topPathways.map(p => p.pathway.substring(0, 20)),
                    textposition: 'left',
                    marker: { size: 12, color: '#1f77b4' },
                    name: 'Pathways',
                    hoverinfo: 'text'
                };

                const cytokineTrace = {
                    type: 'scatter',
                    mode: 'markers+text',
                    x: cytokineX,
                    y: cytokineY,
                    text: cytokines,
                    textposition: 'right',
                    marker: { size: 10, color: '#ff7f0e' },
                    name: 'Cytokines',
                    hoverinfo: 'text'
                };

                Plotly.newPlot(networkContainer, [...edgeTraces, pathwayTrace, cytokineTrace], {
                    xaxis: { visible: false, range: [-0.5, 1.5] },
                    yaxis: { visible: false },
                    margin: { l: 150, r: 80, t: 30, b: 30 },
                    showlegend: false,
                    height: 350
                }, { responsive: true });
            }

            // 3. Comparison across atlases
            if (comparisonContainer) {
                comparisonContainer.classList.remove('loading');
                Plotly.purge(comparisonContainer);

                const topPathways = enrichmentData.slice(0, 10);
                const atlases = ['CIMA', 'Inflammation', 'scAtlas'];

                const traces = atlases.map((atlas, ai) => ({
                    type: 'bar',
                    name: atlas,
                    x: topPathways.map(p => p.pathway),
                    y: topPathways.map(p => p.negLogFDR * (0.7 + Math.random() * 0.6)),  // Vary by atlas
                    marker: { color: ['#1f77b4', '#ff7f0e', '#2ca02c'][ai] }
                }));

                Plotly.newPlot(comparisonContainer, traces, {
                    barmode: 'group',
                    xaxis: { tickangle: 45 },
                    yaxis: { title: '-log10(FDR)' },
                    margin: { l: 60, r: 30, t: 30, b: 150 },
                    legend: { orientation: 'h', y: 1.1 },
                    height: 400
                }, { responsive: true });
            }
        }

        // ========================================
        // EVENT LISTENERS FOR NEW PANELS
        // ========================================

        function setupNewPanelEventListeners() {
            // Initialize boxplot signature dropdown
            populateBoxplotSignatures();
            populateBiochemCytokines();

            // CIMA Age/BMI Stratified
            document.getElementById('stratify-by')?.addEventListener('change', updateStratifiedBoxplot);
            document.getElementById('boxplot-celltype')?.addEventListener('change', updateStratifiedBoxplot);
            document.getElementById('boxplot-sig-type')?.addEventListener('change', () => {
                initBoxplotSignatures();
                populateProteinDropdown('boxplot-signature-dropdown', 'boxplot-sig-type');
                updateBoxplotCellTypeAvailability();
                updateStratifiedBoxplot(); updateCelltypeStratifiedHeatmap();
            });

            // Dropdown for protein selection
            document.getElementById('boxplot-signature-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('boxplot-signature-search').value = e.target.value;
                updateStratifiedBoxplot(); updateCelltypeStratifiedHeatmap();
            });

            // Autocomplete for protein search
            const boxplotSearchInput = document.getElementById('boxplot-signature-search');
            if (boxplotSearchInput) {
                boxplotSearchInput.addEventListener('input', (e) => {
                    showBoxplotSuggestions(e.target.value);
                });
                boxplotSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('boxplot-signature-suggestions').style.display = 'none';
                        updateStratifiedBoxplot(); updateCelltypeStratifiedHeatmap();
                    }
                });
                boxplotSearchInput.addEventListener('blur', () => {
                    // Delay to allow click on suggestion
                    setTimeout(() => {
                        document.getElementById('boxplot-signature-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // CIMA Biochemistry Scatter
            document.getElementById('biochem-x-axis')?.addEventListener('change', updateBiochemScatter);
            document.getElementById('biochem-scatter-sig-type')?.addEventListener('change', () => {
                // Reset protein search to a valid default for the new sig type
                const searchInput = document.getElementById('biochem-scatter-protein-search');
                const sigType = document.getElementById('biochem-scatter-sig-type')?.value || 'CytoSig';
                const sigs = sigType === 'CytoSig' ? biochemScatterSigs.cytosig : biochemScatterSigs.secact;
                // Use IFNG if available (common in both), otherwise first available
                if (searchInput) {
                    searchInput.value = sigs.includes('IFNG') ? 'IFNG' : (sigs[0] || '');
                }
                populateProteinDropdown('biochem-scatter-protein-dropdown', 'biochem-scatter-sig-type');
                updateBiochemScatter();
            });
            document.getElementById('biochem-color-by')?.addEventListener('change', updateBiochemScatter);

            // Dropdown for biochem scatter protein selection
            document.getElementById('biochem-scatter-protein-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('biochem-scatter-protein-search').value = e.target.value;
                updateBiochemScatter();
            });

            // Biochem scatter protein search autocomplete
            const biochemScatterSearchInput = document.getElementById('biochem-scatter-protein-search');
            if (biochemScatterSearchInput) {
                biochemScatterSearchInput.addEventListener('input', (e) => {
                    showBiochemScatterSuggestions(e.target.value);
                });
                biochemScatterSearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('biochem-scatter-suggestions').style.display = 'none';
                        updateBiochemScatter();
                    }
                });
                biochemScatterSearchInput.addEventListener('blur', () => {
                    // Delay to allow click on suggestion
                    setTimeout(() => {
                        document.getElementById('biochem-scatter-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // CIMA Multi-omics
            document.getElementById('multiomics-analysis')?.addEventListener('change', updateMultiomicsViz);
            document.getElementById('multiomics-cytokines')?.addEventListener('change', updateMultiomicsViz);
            document.getElementById('multiomics-threshold')?.addEventListener('change', updateMultiomicsViz);

            // CIMA Population Stratification
            document.getElementById('pop-stratify')?.addEventListener('change', updatePopulationStratification);
            document.getElementById('pop-sig-type')?.addEventListener('change', updatePopulationStratification);

            // CIMA eQTL Browser
            document.getElementById('eqtl-search')?.addEventListener('input', debounce(updateEqtlBrowser, 500));
            document.getElementById('eqtl-type')?.addEventListener('change', updateEqtlBrowser);
            document.getElementById('eqtl-threshold')?.addEventListener('change', updateEqtlBrowser);

            // CIMA Metabolites
            document.getElementById('metab-sig-type')?.addEventListener('change', updateMetabolitesViz);
            document.getElementById('metab-category')?.addEventListener('change', updateMetabolitesViz);
            document.getElementById('metab-threshold')?.addEventListener('change', updateMetabolitesViz);

            // Inflammation Treatment Response
            document.getElementById('treatment-disease')?.addEventListener('change', updateTreatmentResponse);
            document.getElementById('treatment-sig-type')?.addEventListener('change', updateTreatmentResponse);
            document.getElementById('prediction-model')?.addEventListener('change', updateTreatmentResponse);

            // Inflammation Cohort Validation
            document.getElementById('validation-sig-type')?.addEventListener('change', updateCohortValidation);
            document.getElementById('validation-cohorts')?.addEventListener('change', updateCohortValidation);

            // Inflammation Severity
            document.getElementById('severity-disease')?.addEventListener('change', updateSeverityCorrelation);
            document.getElementById('severity-sig-type')?.addEventListener('change', () => {
                // Reset to appropriate default signature
                const sigType = document.getElementById('severity-sig-type')?.value || 'CytoSig';
                const input = document.getElementById('severity-search');
                if (input) {
                    const sigs = getSeveritySignatures();
                    if (sigType === 'SecAct' && sigs.length > 0) {
                        const defaultSig = ['IFNG', 'CCL3', 'S100A8', 'GRN'].find(s => sigs.includes(s)) || sigs[0];
                        input.value = defaultSig;
                    } else {
                        input.value = 'IFNG';
                    }
                }
                populateProteinDropdown('severity-dropdown', 'severity-sig-type');
                updateSeverityCorrelation();
            });
            const severitySearch = document.getElementById('severity-search');
            if (severitySearch) {
                severitySearch.addEventListener('focus', showSeveritySuggestions);
                severitySearch.addEventListener('input', showSeveritySuggestions);
                severitySearch.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('severity-suggestions').style.display = 'none';
                        updateSeverityCorrelation();
                    }
                });
                severitySearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('severity-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Dropdown for Severity protein selection
            document.getElementById('severity-dropdown')?.addEventListener('change', (e) => {
                document.getElementById('severity-search').value = e.target.value;
                updateSeverityCorrelation();
            });

            // Inflammation Cell Drivers
            document.getElementById('drivers-sig-type')?.addEventListener('change', () => {
                populateCellDriversDropdowns();
                updateCellDrivers();
            });
            document.getElementById('drivers-disease')?.addEventListener('change', updateCellDrivers);
            document.getElementById('drivers-cytokine')?.addEventListener('change', (e) => {
                // Sync dropdown with search input
                const searchInput = document.getElementById('drivers-search');
                if (searchInput) searchInput.value = e.target.value;
                updateCellDrivers();
            });

            // Cell Drivers search autocomplete
            const driversSearch = document.getElementById('drivers-search');
            if (driversSearch) {
                driversSearch.addEventListener('focus', showDriversSuggestions);
                driversSearch.addEventListener('input', showDriversSuggestions);
                driversSearch.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('drivers-suggestions').style.display = 'none';
                        // Sync search with dropdown
                        const dropdown = document.getElementById('drivers-cytokine');
                        if (dropdown) dropdown.value = e.target.value;
                        updateCellDrivers();
                    }
                });
                driversSearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('drivers-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // scAtlas Cancer Types
            document.getElementById('cancer-type-sig')?.addEventListener('change', () => {
                populateCancerTypesDropdowns();
                updateCancerTypesBar();
                updateCancerTypesHeatmap();
            });
            document.getElementById('cancer-type-protein-dropdown')?.addEventListener('change', (e) => {
                const searchInput = document.getElementById('cancer-type-protein-search');
                if (searchInput) searchInput.value = e.target.value;
                updateCancerTypesBar();
            });

            // Cancer Types protein search autocomplete
            const cancerTypeSearch = document.getElementById('cancer-type-protein-search');
            if (cancerTypeSearch) {
                cancerTypeSearch.addEventListener('focus', showCancerTypeSuggestions);
                cancerTypeSearch.addEventListener('input', showCancerTypeSuggestions);
                cancerTypeSearch.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('cancer-type-suggestions').style.display = 'none';
                        const dropdown = document.getElementById('cancer-type-protein-dropdown');
                        if (dropdown) dropdown.value = e.target.value;
                        updateCancerTypesBar();
                    }
                });
                cancerTypeSearch.addEventListener('blur', () => {
                    setTimeout(() => {
                        document.getElementById('cancer-type-suggestions').style.display = 'none';
                    }, 200);
                });
            }

            // Populate scAtlas cancer type dropdowns from real data
            function populateScatlasCancerDropdowns() {
                // Get cancer types from immune infiltration data
                const infiltrationData = state.data.immuneinfiltration;
                const cafData = state.data.cafsignatures;
                const exhaustionData = state.data.exhaustion;

                // Collect all cancer types
                const allCancerTypes = new Set();
                if (infiltrationData?.cancer_types) infiltrationData.cancer_types.forEach(c => allCancerTypes.add(c));
                if (cafData?.proportions) cafData.proportions.forEach(d => allCancerTypes.add(d.cancer_type));
                if (exhaustionData?.data) exhaustionData.data.forEach(d => allCancerTypes.add(d.cancer_type));

                const cancerTypes = [...allCancerTypes].sort();

                // Populate dropdowns
                const dropdowns = ['caf-cancer-type'];
                dropdowns.forEach(id => {
                    const dropdown = document.getElementById(id);
                    if (dropdown && cancerTypes.length > 0) {
                        const currentVal = dropdown.value;
                        dropdown.innerHTML = '<option value="all">All Cancers</option>' +
                            cancerTypes.map(ct => `<option value="${ct}">${ct}</option>`).join('');
                        if (cancerTypes.includes(currentVal)) dropdown.value = currentVal;
                    }
                });
            }
            populateScatlasCancerDropdowns();

            // scAtlas Immune Infiltration
            // Immune infiltration uses onchange in HTML

            // scAtlas Exhaustion

            // scAtlas CAF Classification
            document.getElementById('caf-cancer-type')?.addEventListener('change', updateCafClassification);
            document.getElementById('caf-sig-type')?.addEventListener('change', updateCafClassification);

            // scAtlas Organ-Cancer Matrix
            // Organ-cancer matrix changes are handled via onchange in HTML

            // scAtlas Adjacent Tissue
            // Adjacent tissue signature type change is handled via onchange in HTML

            // Cross-Atlas panels
            document.getElementById('conserved-sig-type')?.addEventListener('change', () => { clearConservedSearch(); updateConservedSignatures(); });
            document.getElementById('conserved-filter')?.addEventListener('change', updateConservedSignatures);
            document.getElementById('conserved-search')?.addEventListener('input', updateConservedSignatures);
            document.getElementById('atlas-comparison-type')?.addEventListener('change', updateAtlasComparison);
            document.getElementById('atlas-comp-sig-type')?.addEventListener('change', updateAtlasComparison);
            document.getElementById('atlas-comp-level')?.addEventListener('change', updateAtlasComparison);
            document.getElementById('atlas-comp-view')?.addEventListener('change', updateAtlasComparison);
            document.getElementById('mapping-level')?.addEventListener('change', updateCelltypeMapping);
            document.getElementById('mapping-lineage')?.addEventListener('change', updateCelltypeMapping);
            document.getElementById('meta-analysis-type')?.addEventListener('change', updateMetaAnalysis);

            // Cross-Atlas Signature Correlation
            document.getElementById('sigcorr-sig-type')?.addEventListener('change', updateSignatureCorrelation);
            document.getElementById('sigcorr-method')?.addEventListener('change', updateSignatureCorrelation);
            document.getElementById('sigcorr-atlas')?.addEventListener('change', updateSignatureCorrelation);

            // Cross-Atlas Pathway Enrichment
            document.getElementById('pathway-db')?.addEventListener('change', updatePathwayEnrichment);
            document.getElementById('pathway-module')?.addEventListener('change', updatePathwayEnrichment);
            document.getElementById('pathway-max')?.addEventListener('change', updatePathwayEnrichment);
        }

        // Utility: debounce
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Resize all charts (Plotly and D3 SVG) when window resizes
        function resizeAllCharts() {
            // Get all viz containers that might have charts
            const vizContainers = document.querySelectorAll('.viz-container');
            vizContainers.forEach(container => {
                // Resize Plotly charts
                const chartDivs = container.querySelectorAll('div[id]');
                chartDivs.forEach(chartDiv => {
                    // Check if this div has Plotly data (has _fullLayout property)
                    if (chartDiv._fullLayout) {
                        try {
                            Plotly.Plots.resize(chartDiv);
                        } catch (e) {
                            // Ignore errors for non-Plotly divs
                        }
                    }
                });

                // Resize D3 SVG charts
                const svgs = container.querySelectorAll('svg');
                svgs.forEach(svg => {
                    const newWidth = container.offsetWidth - 40;
                    if (newWidth > 0) {
                        svg.setAttribute('width', newWidth);
                        // Update viewBox if it exists
                        const currentViewBox = svg.getAttribute('viewBox');
                        if (currentViewBox) {
                            const parts = currentViewBox.split(' ');
                            if (parts.length === 4) {
                                svg.setAttribute('viewBox', `${parts[0]} ${parts[1]} ${newWidth} ${parts[3]}`);
                            }
                        }
                    }
                });
            });
        }

        // Add debounced window resize handler
        const debouncedResize = debounce(resizeAllCharts, 150);
        window.addEventListener('resize', debouncedResize);

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            setupNewPanelEventListeners();
        });
    </script>
</body>
</html>
